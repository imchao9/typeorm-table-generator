{"version":3,"sources":["../../src/persistence/SubjectOperationExecutor.ts"],"names":[],"mappings":"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","file":"SubjectOperationExecutor.js","sourcesContent":["import {ObjectLiteral} from \"../common/ObjectLiteral\";\nimport {EntityMetadata} from \"../metadata/EntityMetadata\";\nimport {Connection} from \"../connection/Connection\";\nimport {QueryRunner} from \"../query-runner/QueryRunner\";\nimport {Subject, JunctionInsert, JunctionRemove} from \"./Subject\";\nimport {OrmUtils} from \"../util/OrmUtils\";\nimport {QueryRunnerProvider} from \"../query-runner/QueryRunnerProvider\";\nimport {RelationMetadata} from \"../metadata/RelationMetadata\";\nimport {EntityManager} from \"../entity-manager/EntityManager\";\nimport {PromiseUtils} from \"../util/PromiseUtils\";\n\n/**\n * Executes all database operations (inserts, updated, deletes) that must be executed\n * with given persistence subjects.\n */\nexport class SubjectOperationExecutor {\n\n    // -------------------------------------------------------------------------\n    // Protected Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * All subjects that needs to be operated.\n     */\n    protected allSubjects: Subject[];\n\n    /**\n     * Subjects that must be inserted.\n     */\n    protected insertSubjects: Subject[];\n\n    /**\n     * Subjects that must be updated.\n     */\n    protected updateSubjects: Subject[];\n\n    /**\n     * Subjects that must be removed.\n     */\n    protected removeSubjects: Subject[];\n\n    /**\n     * Subjects which relations should be updated.\n     */\n    protected relationUpdateSubjects: Subject[];\n\n    /**\n     * Query runner used to execute queries.\n     */\n    protected queryRunner: QueryRunner;\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(protected connection: Connection,\n                protected transactionEntityManager: EntityManager,\n                protected queryRunnerProvider: QueryRunnerProvider) {\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Executes all operations over given array of subjects.\n     * Executes queries using given query runner.\n     */\n    async execute(subjects: Subject[]): Promise<void> {\n\n        /*subjects.forEach(subject => {\n            console.log(subject.entity);\n            console.log(\"mustBeInserted: \", subject.mustBeInserted);\n            console.log(\"mustBeUpdated: \", subject.mustBeUpdated);\n            console.log(\"mustBeRemoved: \", subject.mustBeRemoved);\n        });*/\n\n        // validate all subjects first\n        subjects.forEach(subject => subject.validate());\n\n        // set class properties for easy use\n        this.allSubjects = subjects;\n        this.insertSubjects = subjects.filter(subject => subject.mustBeInserted);\n        this.updateSubjects = subjects.filter(subject => subject.mustBeUpdated);\n        this.removeSubjects = subjects.filter(subject => subject.mustBeRemoved);\n        this.relationUpdateSubjects = subjects.filter(subject => subject.hasRelationUpdates);\n\n        // if there are no operations to execute then don't need to do something including opening a transaction\n        if (!this.insertSubjects.length &&\n            !this.updateSubjects.length &&\n            !this.removeSubjects.length &&\n            !this.relationUpdateSubjects.length &&\n            subjects.every(subject => !subject.junctionInserts.length) &&\n            subjects.every(subject => !subject.junctionRemoves.length))\n            return;\n\n        // start execute queries in a transaction\n        // if transaction is already opened in this query runner then we don't touch it\n        // if its not opened yet then we open it here, and once we finish - we close it\n        let isTransactionStartedByItself = false;\n        try {\n\n            this.queryRunner = await this.queryRunnerProvider.provide();\n\n            // open transaction if its not opened yet\n            if (!this.queryRunner.isTransactionActive()) {\n                isTransactionStartedByItself = true;\n                await this.queryRunner.beginTransaction();\n            }\n\n            // broadcast \"before\" events before we start updating\n            await this.connection.broadcaster.broadcastBeforeEventsForAll(this.transactionEntityManager, this.insertSubjects, this.updateSubjects, this.removeSubjects);\n\n            // since events can trigger some internal changes (for example update depend property) we need to perform some re-computations here\n            this.updateSubjects.forEach(subject => subject.recompute());\n\n            await this.executeInsertOperations();\n            await this.executeInsertClosureTableOperations();\n            await this.executeInsertJunctionsOperations();\n            await this.executeRemoveJunctionsOperations();\n            await this.executeUpdateOperations();\n            await this.executeUpdateRelations();\n            await this.executeRemoveOperations();\n\n            // commit transaction if it was started by us\n            if (isTransactionStartedByItself === true)\n                await this.queryRunner.commitTransaction();\n\n            // update all special columns in persisted entities, like inserted id or remove ids from the removed entities\n            await this.updateSpecialColumnsInPersistedEntities();\n\n            // finally broadcast \"after\" events\n            // note that we are broadcasting events after commit because we want to have ids of the entities inside them to be available in subscribers\n            await this.connection.broadcaster.broadcastAfterEventsForAll(this.transactionEntityManager, this.insertSubjects, this.updateSubjects, this.removeSubjects);\n\n        } catch (error) {\n\n            // rollback transaction if it was started by us\n            if (isTransactionStartedByItself) {\n                try {\n                    await this.queryRunner.rollbackTransaction();\n\n                } catch (secondaryError) {\n                }\n            }\n\n            throw error;\n        }\n\n    }\n\n    // -------------------------------------------------------------------------\n    // Private Methods: Insertion\n    // -------------------------------------------------------------------------\n\n    /**\n     * Executes insert operations.\n     *\n     * For insertion we separate two groups of entities:\n     * - first group of entities are entities which do not have any relations\n     *      or entities which do not have any non-nullable relation\n     * - second group of entities are entities which does have non-nullable relations\n     *\n     * Insert process of the entities from the first group which can only have nullable relations are actually a two-step process:\n     * - first we insert entities without their relations, explicitly left them NULL\n     * - later we update inserted entity once again with id of the object inserted with it\n     *\n     * Yes, two queries are being executed, but this is by design.\n     * There is no better way to solve this problem and others at the same time.\n     *\n     * Insert process of the entities from the second group which can have only non nullable relations is a single-step process:\n     * - we simply insert all entities and get into attention all its dependencies which were inserted in the first group\n     */\n    private async executeInsertOperations(): Promise<void> {\n\n        // separate insert entities into groups:\n\n        // TODO: current ordering mechanism is bad. need to create a correct order in which entities should be persisted, need to build a dependency graph\n\n        // first group of subjects are subjects without any non-nullable column\n        // we need to insert first such entities because second group entities may rely on those entities.\n        const firstInsertSubjects = this.insertSubjects.filter(subject => !subject.metadata.hasNonNullableColumns);\n\n        // second group - are all other subjects\n        // since in this group there are non nullable columns, some of them may depend on value of the\n        // previously inserted entity (which only can be entity with all nullable columns)\n        const secondInsertSubjects = this.insertSubjects.filter(subject => subject.metadata.hasNonNullableColumns);\n\n        // note: these operations should be executed in sequence, not in parallel\n        // because second group depend of obtained data from the first group\n        await Promise.all(firstInsertSubjects.map(subject => this.insert(subject, [])));\n        await Promise.all(secondInsertSubjects.map(subject => this.insert(subject, firstInsertSubjects)));\n\n        // we need to update relation ids of the newly inserted objects (where we inserted NULLs in relations)\n        // once we inserted all entities, we need to update relations which were bind to inserted entities.\n        // For example we have a relation many-to-one Post<->Category. Relation is nullable.\n        // New category was set to the new post and post where persisted.\n        // Here this method executes two inserts: one for post, one for category,\n        // but category in post is inserted with \"null\".\n        // now we need to update post table - set category with a newly persisted category id.\n        const updatePromises: Promise<any>[] = [];\n        firstInsertSubjects.forEach(subject => {\n\n            // first update relations with join columns (one-to-one owner and many-to-one relations)\n            const updateOptions: ObjectLiteral = {};\n            subject.metadata.relationsWithJoinColumns.forEach(relation => {\n                const referencedColumn = relation.joinColumn.referencedColumn;\n                const relatedEntity = relation.getEntityValue(subject.entity);\n\n                // if relation value is not set then nothing to do here\n                if (!relatedEntity)\n                    return;\n\n                // check if relation reference column is a relation\n                let relationId: any;\n                const columnRelation = relation.inverseEntityMetadata.relations.find(rel => rel.propertyName === relation.joinColumn.referencedColumn.propertyName);\n                if (columnRelation) { // if referenced column is a relation\n                    const insertSubject = this.insertSubjects.find(insertedSubject => insertedSubject.entity === relatedEntity[referencedColumn.propertyName]);\n\n                    // if this relation was just inserted\n                    if (insertSubject) {\n\n                        // check if we have this relation id already\n                        relationId = relatedEntity[referencedColumn.propertyName][columnRelation.propertyName];\n                        if (!relationId) {\n\n                            // if we don't have relation id then use special values\n                            if (referencedColumn.isGenerated) {\n                                relationId = insertSubject.newlyGeneratedId;\n                            }\n                            // todo: handle other special types too\n                        }\n                    }\n\n                } else { // if referenced column is a simple non relational column\n                    const insertSubject = this.insertSubjects.find(insertedSubject => insertedSubject.entity === relatedEntity);\n\n                    // if this relation was just inserted\n                    if (insertSubject) {\n\n                        // check if we have this relation id already\n                        relationId = relatedEntity[referencedColumn.propertyName];\n                        if (!relationId) {\n\n                            // if we don't have relation id then use special values\n                            if (referencedColumn.isGenerated) {\n                                relationId = insertSubject.newlyGeneratedId;\n                            }\n                            // todo: handle other special types too\n                        }\n                    }\n\n                }\n\n                if (relationId) {\n                    updateOptions[relation.name] = relationId;\n                }\n\n            });\n\n            // if we found relations which we can update - then update them\n            if (Object.keys(updateOptions).length > 0 /*&& subject.hasEntity*/) {\n                // const relatedEntityIdMap = subject.getPersistedEntityIdMap; // todo: this works incorrectly\n\n                const columns = subject.metadata.parentEntityMetadata ? subject.metadata.primaryColumnsWithParentIdColumns : subject.metadata.primaryColumns;\n                const conditions: ObjectLiteral = {};\n\n                columns.forEach(column => {\n                    const entityValue = subject.entity[column.propertyName];\n\n                    // if entity id is a relation, then extract referenced column from that relation\n                    const columnRelation = subject.metadata.relations.find(relation => relation.propertyName === column.propertyName);\n\n                    if (entityValue && columnRelation && columnRelation.joinColumn) { // not sure if we need handle join column from inverse side\n                        let relationIdOfEntityValue = entityValue[columnRelation.joinColumn.referencedColumn.propertyName];\n                        if (!relationIdOfEntityValue) {\n                            const entityValueInsertSubject = this.insertSubjects.find(subject => subject.entity === entityValue);\n                            if (entityValueInsertSubject && columnRelation.joinColumn.referencedColumn.isGenerated) {\n                                relationIdOfEntityValue = entityValueInsertSubject.newlyGeneratedId;\n                            }\n                        }\n                        if (relationIdOfEntityValue) {\n                            conditions[column.name] = relationIdOfEntityValue;\n                        }\n\n                    } else {\n                        if (entityValue) {\n                            conditions[column.name] = entityValue;\n                        } else {\n                            if (subject.newlyGeneratedId) {\n                                conditions[column.name] = subject.newlyGeneratedId;\n                            }\n                        }\n                    }\n                });\n                if (!Object.keys(conditions).length)\n                    return;\n\n                const updatePromise = this.queryRunner.update(subject.metadata.table.name, updateOptions, conditions);\n                updatePromises.push(updatePromise);\n            }\n\n            // we need to update relation ids if newly inserted objects are used from inverse side in one-to-many inverse relation\n            // we also need to update relation ids if newly inserted objects are used from inverse side in one-to-one inverse relation\n            const oneToManyAndOneToOneNonOwnerRelations = subject.metadata.oneToManyRelations.concat(subject.metadata.oneToOneRelations.filter(relation => !relation.isOwning));\n            subject.metadata.extractRelationValuesFromEntity(subject.entity, oneToManyAndOneToOneNonOwnerRelations)\n                .forEach(([relation, subRelatedEntity, inverseEntityMetadata]) => {\n                    const referencedColumn = relation.inverseRelation.joinColumn.referencedColumn;\n                    const columns = inverseEntityMetadata.parentEntityMetadata ? inverseEntityMetadata.primaryColumnsWithParentIdColumns : inverseEntityMetadata.primaryColumns;\n                    const conditions: ObjectLiteral = {};\n\n                    columns.forEach(column => {\n                        const entityValue = subRelatedEntity[column.propertyName];\n\n                        // if entity id is a relation, then extract referenced column from that relation\n                        const columnRelation = inverseEntityMetadata.relations.find(relation => relation.propertyName === column.propertyName);\n\n                        if (entityValue && columnRelation && columnRelation.joinColumn) { // not sure if we need handle join column from inverse side\n                            let relationIdOfEntityValue = entityValue[columnRelation.joinColumn.referencedColumn.propertyName];\n                            if (!relationIdOfEntityValue) {\n                                const entityValueInsertSubject = this.insertSubjects.find(subject => subject.entity === entityValue);\n                                if (entityValueInsertSubject && columnRelation.joinColumn.referencedColumn.isGenerated) {\n                                    relationIdOfEntityValue = entityValueInsertSubject.newlyGeneratedId;\n                                }\n                            }\n                            if (relationIdOfEntityValue) {\n                                conditions[column.name] = relationIdOfEntityValue;\n                            }\n\n                        } else {\n                            const entityValueInsertSubject = this.insertSubjects.find(subject => subject.entity === subRelatedEntity);\n                            if (entityValue) {\n                                conditions[column.name] = entityValue;\n                            } else {\n                                if (entityValueInsertSubject && entityValueInsertSubject.newlyGeneratedId) {\n                                    conditions[column.name] = entityValueInsertSubject.newlyGeneratedId;\n                                }\n                            }\n                        }\n                    });\n                    if (!Object.keys(conditions).length)\n                        return;\n\n                    const updateOptions: ObjectLiteral = {};\n                    const columnRelation = relation.inverseEntityMetadata.relations.find(rel => rel.propertyName === referencedColumn.propertyName);\n                    if (columnRelation) {\n                        let id = subject.entity[referencedColumn.propertyName][columnRelation.propertyName];\n                        if (!id) {\n                            const insertSubject = this.insertSubjects.find(subject => subject.entity === subject.entity[referencedColumn.propertyName]);\n                            if (insertSubject) {\n                                id = insertSubject.newlyGeneratedId;\n                            }\n                        }\n                        updateOptions[relation.inverseRelation.joinColumn.name] = id;\n                    } else {\n                        updateOptions[relation.inverseRelation.joinColumn.name] = subject.entity[referencedColumn.propertyName] || subject.newlyGeneratedId;\n                    }\n\n                    const updatePromise = this.queryRunner.update(relation.inverseEntityMetadata.table.name, updateOptions, conditions);\n                    updatePromises.push(updatePromise);\n                });\n\n        });\n\n        await Promise.all(updatePromises);\n\n        // todo: make sure to search in all insertSubjects during updating too if updated entity uses links to the newly persisted entity\n    }\n\n    /**\n     * Inserts an entity from the given insert operation into the database.\n     * If entity has an generated column, then after saving new generated value will be stored to the InsertOperation.\n     * If entity uses class-table-inheritance, then multiple inserts may by performed to save all entities.\n     */\n    private async insert(subject: Subject, alreadyInsertedSubjects: Subject[]): Promise<any> {\n\n        const parentEntityMetadata = subject.metadata.parentEntityMetadata;\n        const metadata = subject.metadata;\n        const entity = subject.entity;\n        let newlyGeneratedId: any, parentGeneratedId: any;\n\n        // if entity uses class table inheritance then we need to separate entity into sub values that will be inserted into multiple tables\n        if (metadata.table.isClassTableChild) { // todo: with current implementation inheritance of multiple class table children will not work\n\n            // first insert entity values into parent class table\n            const parentValuesMap = this.collectColumnsAndValues(parentEntityMetadata, entity, subject.date, undefined, metadata.discriminatorValue, alreadyInsertedSubjects);\n            newlyGeneratedId = parentGeneratedId = await this.queryRunner.insert(parentEntityMetadata.table.name, parentValuesMap, parentEntityMetadata.generatedColumnIfExist);\n\n            // second insert entity values into child class table\n            const childValuesMap = this.collectColumnsAndValues(metadata, entity, subject.date, newlyGeneratedId, undefined, alreadyInsertedSubjects);\n            const secondGeneratedId = await this.queryRunner.insert(metadata.table.name, childValuesMap, metadata.generatedColumnIfExist);\n            if (!newlyGeneratedId && secondGeneratedId) newlyGeneratedId = secondGeneratedId;\n\n        } else { // in the case when class table inheritance is not used\n\n            const valuesMap = this.collectColumnsAndValues(metadata, entity, subject.date, undefined, undefined, alreadyInsertedSubjects);\n            newlyGeneratedId = await this.queryRunner.insert(metadata.table.name, valuesMap, metadata.generatedColumnIfExist);\n        }\n\n        if (parentGeneratedId)\n            subject.parentGeneratedId = parentGeneratedId;\n\n        if (newlyGeneratedId && metadata.hasGeneratedColumn)\n            subject.newlyGeneratedId = newlyGeneratedId;\n    }\n\n    /**\n     * Collects columns and values for the insert operation.\n     */\n    private collectColumnsAndValues(metadata: EntityMetadata, entity: ObjectLiteral, date: Date, parentIdColumnValue: any, discriminatorValue: any, alreadyInsertedSubjects: Subject[]): ObjectLiteral {\n\n        // extract all columns\n        const columns = metadata.columns.filter(column => {\n            return !column.isVirtual && !column.isParentId && !column.isDiscriminator && column.hasEntityValue(entity);\n        });\n\n        const relationColumns: RelationMetadata[] = [];\n        const relationValues: any[] = [];\n        metadata.relationsWithJoinColumns.forEach(relation => {\n\n            let relationValue: any;\n            const value = relation.getEntityValue(entity);\n\n            if (value) {\n                // if relation value is stored in the entity itself then use it from there\n                const relationId = relation.getInverseEntityRelationId(value); // todo: check it\n                if (relationId) {\n                    relationValue = relationId;\n                }\n\n                // otherwise try to find relational value from just inserted subjects\n                const alreadyInsertedSubject = alreadyInsertedSubjects.find(insertedSubject => {\n                    return insertedSubject.entity === value;\n                });\n                if (alreadyInsertedSubject) {\n                    const referencedColumn = relation.joinColumn.referencedColumn;\n                    // if join column references to the primary generated column then seek in the newEntityId of the insertedSubject\n                    if (referencedColumn.referencedColumn && referencedColumn.referencedColumn.isGenerated) {\n                        if (referencedColumn.isParentId) {\n                            relationValue = alreadyInsertedSubject.parentGeneratedId;\n                        }\n                        // todo: what if reference column is not generated?\n                        // todo: what if reference column is not related to table inheritance?\n                    }\n\n                    if (referencedColumn.isGenerated)\n                        relationValue = alreadyInsertedSubject.newlyGeneratedId;\n                    // if it references to create or update date columns\n                    if (referencedColumn.isCreateDate || referencedColumn.isUpdateDate)\n                        relationValue = this.connection.driver.preparePersistentValue(alreadyInsertedSubject.date, referencedColumn);\n                    // if it references to version column\n                    if (referencedColumn.isVersion)\n                        relationValue = this.connection.driver.preparePersistentValue(1, referencedColumn);\n                }\n            } else if (relation.hasInverseSide) {\n                const inverseSubject = this.allSubjects.find(subject => {\n                    if (!subject.hasEntity || subject.entityTarget !== relation.inverseRelation.target)\n                        return false;\n\n                    const inverseRelationValue = subject.entity[relation.inverseRelation.propertyName];\n                    if (inverseRelationValue) {\n                        if (inverseRelationValue instanceof Array) {\n                            return inverseRelationValue.find(subValue => subValue === subValue);\n                        } else {\n                            return inverseRelationValue === entity;\n                        }\n                    }\n                });\n                if (inverseSubject && inverseSubject.entity[relation.joinColumn.referencedColumn.propertyName]) {\n                    relationValue = inverseSubject.entity[relation.joinColumn.referencedColumn.propertyName];\n                }\n            }\n\n            if (relationValue) {\n                relationColumns.push(relation);\n                relationValues.push(relationValue);\n            }\n        });\n\n        const columnNames = columns.map(column => column.name);\n        const relationColumnNames = relationColumns.map(relation => relation.name);\n        const allColumnNames = columnNames.concat(relationColumnNames);\n\n        const columnValues = columns.map(column => {\n            return this.connection.driver.preparePersistentValue(column.getEntityValue(entity), column);\n        });\n\n        const allValues = columnValues.concat(relationValues);\n\n        // add special column and value - date of creation\n        if (metadata.hasCreateDateColumn) {\n            allColumnNames.push(metadata.createDateColumn.name);\n            allValues.push(this.connection.driver.preparePersistentValue(date, metadata.createDateColumn));\n        }\n\n        // add special column and value - date of updating\n        if (metadata.hasUpdateDateColumn) {\n            allColumnNames.push(metadata.updateDateColumn.name);\n            allValues.push(this.connection.driver.preparePersistentValue(date, metadata.updateDateColumn));\n        }\n\n        // add special column and value - version column\n        if (metadata.hasVersionColumn) {\n            allColumnNames.push(metadata.versionColumn.name);\n            allValues.push(this.connection.driver.preparePersistentValue(1, metadata.versionColumn));\n        }\n\n        // add special column and value - discriminator value (for tables using table inheritance)\n        if (metadata.hasDiscriminatorColumn) {\n            allColumnNames.push(metadata.discriminatorColumn.name);\n            allValues.push(this.connection.driver.preparePersistentValue(discriminatorValue || metadata.discriminatorValue, metadata.discriminatorColumn));\n        }\n\n        // add special column and value - tree level and tree parents (for tree-type tables)\n        if (metadata.hasTreeLevelColumn && metadata.hasTreeParentRelation) {\n            const parentEntity = entity[metadata.treeParentRelation.propertyName];\n            const parentLevel = parentEntity ? (parentEntity[metadata.treeLevelColumn.propertyName] || 0) : 0;\n\n            allColumnNames.push(metadata.treeLevelColumn.name);\n            allValues.push(parentLevel + 1);\n        }\n\n        // add special column and value - parent id column (for tables using table inheritance)\n        if (metadata.parentEntityMetadata && metadata.hasParentIdColumn) {\n            allColumnNames.push(metadata.parentIdColumn.name); // todo: should be array of primary keys\n            allValues.push(parentIdColumnValue || entity[metadata.parentEntityMetadata.firstPrimaryColumn.propertyName]); // todo: should be array of primary keys\n        }\n\n        return OrmUtils.zipObject(allColumnNames, allValues);\n    }\n\n    // -------------------------------------------------------------------------\n    // Private Methods: Insertion into closure tables\n    // -------------------------------------------------------------------------\n\n    /**\n     * Inserts all given subjects into closure table.\n     */\n    private executeInsertClosureTableOperations(/*, updatesByRelations: Subject[]*/) { // todo: what to do with updatesByRelations\n        const promises = this.insertSubjects\n            .filter(subject => subject.metadata.table.isClosure)\n            .map(async subject => {\n                // const relationsUpdateMap = this.findUpdateOperationForEntity(updatesByRelations, insertSubjects, subject.entity);\n                // subject.treeLevel = await this.insertIntoClosureTable(subject, relationsUpdateMap);\n                await this.insertClosureTableValues(subject);\n            });\n        return Promise.all(promises);\n    }\n\n    /**\n     * Inserts given subject into closure table.\n     */\n    private async insertClosureTableValues(subject: Subject): Promise<void> {\n        // todo: since closure tables do not support compose primary keys - throw an exception?\n        // todo: what if parent entity or parentEntityId is empty?!\n        const tableName = subject.metadata.closureJunctionTable.table.name;\n        const referencedColumn = subject.metadata.treeParentRelation.joinColumn.referencedColumn; // todo: check if joinColumn works\n\n        let newEntityId = subject.entity[referencedColumn.propertyName];\n        if (!newEntityId && referencedColumn.isGenerated) {\n            newEntityId = subject.newlyGeneratedId;\n        } // todo: implement other special column types too\n\n        const parentEntity = subject.entity[subject.metadata.treeParentRelation.propertyName];\n        let parentEntityId: any = 0; // zero is important\n        if (parentEntity) {\n            parentEntityId = parentEntity[referencedColumn.propertyName];\n            if (!parentEntityId && referencedColumn.isGenerated) {\n                const parentInsertedSubject = this.insertSubjects.find(subject => subject.entity === parentEntity);\n                // todo: throw exception if parentInsertedSubject is not set\n                parentEntityId = parentInsertedSubject!.newlyGeneratedId;\n            } // todo: implement other special column types too\n        }\n\n        // try to find parent entity id in some other entity that has this entity in its children\n        if (!parentEntityId) {\n            const parentSubject = this.allSubjects.find(allSubject => {\n                if (!allSubject.hasEntity || !allSubject.metadata.table.isClosure || !allSubject.metadata.hasTreeChildrenRelation)\n                    return false;\n\n                const children = allSubject.entity[subject.metadata.treeChildrenRelation.propertyName];\n                return children instanceof Array ? children.indexOf(subject.entity) !== -1 : false;\n            });\n\n            if (parentSubject) {\n                parentEntityId = parentSubject.entity[referencedColumn.propertyName];\n                if (!parentEntityId && parentSubject.newlyGeneratedId) { // if still not found then it means parent just inserted with generated column\n                    parentEntityId = parentSubject.newlyGeneratedId;\n                }\n            }\n        }\n\n        // if parent entity exist then insert a new row into closure table\n        subject.treeLevel = await this.queryRunner.insertIntoClosureTable(tableName, newEntityId, parentEntityId, subject.metadata.hasTreeLevelColumn);\n\n        if (subject.metadata.hasTreeLevelColumn) {\n            const values = { [subject.metadata.treeLevelColumn.name]: subject.treeLevel };\n            await this.queryRunner.update(subject.metadata.table.name, values, { [referencedColumn.name]: newEntityId });\n        }\n    }\n\n    // -------------------------------------------------------------------------\n    // Private Methods: Update\n    // -------------------------------------------------------------------------\n\n    /**\n     * Updates all given subjects in the database.\n     */\n    private async executeUpdateOperations(): Promise<void> {\n        await Promise.all(this.updateSubjects.map(subject => this.update(subject)));\n    }\n\n    /**\n     * Updates given subject in the database.\n     */\n    private async update(subject: Subject): Promise<void> {\n        const entity = subject.entity;\n\n        // we group by table name, because metadata can have different table names\n        const valueMaps: { tableName: string, metadata: EntityMetadata, values: ObjectLiteral }[] = [];\n\n        subject.diffColumns.forEach(column => {\n            if (!column.entityTarget) return; // todo: how this can be possible?\n            const metadata = this.connection.getMetadata(column.entityTarget);\n            let valueMap = valueMaps.find(valueMap => valueMap.tableName === metadata.table.name);\n            if (!valueMap) {\n                valueMap = { tableName: metadata.table.name, metadata: metadata, values: {} };\n                valueMaps.push(valueMap);\n            }\n\n            valueMap.values[column.name] = this.connection.driver.preparePersistentValue(column.getEntityValue(entity), column);\n        });\n\n        subject.diffRelations.forEach(relation => {\n            const metadata = this.connection.getMetadata(relation.entityTarget);\n            let valueMap = valueMaps.find(valueMap => valueMap.tableName === metadata.table.name);\n            if (!valueMap) {\n                valueMap = { tableName: metadata.table.name, metadata: metadata, values: {} };\n                valueMaps.push(valueMap);\n            }\n\n            const value = relation.getEntityValue(entity);\n            valueMap.values[relation.name] = value !== null && value !== undefined ? value[relation.inverseEntityMetadata.firstPrimaryColumn.propertyName] : null; // todo: should not have a call to primaryColumn, instead join column metadata should be used\n        });\n\n        // if number of updated columns = 0 no need to update updated date and version columns\n        if (Object.keys(valueMaps).length === 0)\n            return;\n\n        if (subject.metadata.hasUpdateDateColumn) {\n            let valueMap = valueMaps.find(valueMap => valueMap.tableName === subject.metadata.table.name);\n            if (!valueMap) {\n                valueMap = { tableName: subject.metadata.table.name, metadata: subject.metadata, values: {} };\n                valueMaps.push(valueMap);\n            }\n\n            valueMap.values[subject.metadata.updateDateColumn.name] = this.connection.driver.preparePersistentValue(new Date(), subject.metadata.updateDateColumn);\n        }\n\n        if (subject.metadata.hasVersionColumn) {\n            let valueMap = valueMaps.find(valueMap => valueMap.tableName === subject.metadata.table.name);\n            if (!valueMap) {\n                valueMap = { tableName: subject.metadata.table.name, metadata: subject.metadata, values: {} };\n                valueMaps.push(valueMap);\n            }\n\n            valueMap.values[subject.metadata.versionColumn.name] = this.connection.driver.preparePersistentValue(entity[subject.metadata.versionColumn.propertyName] + 1, subject.metadata.versionColumn);\n        }\n\n        if (subject.metadata.parentEntityMetadata) {\n            if (subject.metadata.parentEntityMetadata.hasUpdateDateColumn) {\n                let valueMap = valueMaps.find(valueMap => valueMap.tableName === subject.metadata.parentEntityMetadata.table.name);\n                if (!valueMap) {\n                    valueMap = {\n                        tableName: subject.metadata.parentEntityMetadata.table.name,\n                        metadata: subject.metadata.parentEntityMetadata,\n                        values: {}\n                    };\n                    valueMaps.push(valueMap);\n                }\n\n                valueMap.values[subject.metadata.parentEntityMetadata.updateDateColumn.name] = this.connection.driver.preparePersistentValue(new Date(), subject.metadata.parentEntityMetadata.updateDateColumn);\n            }\n\n            if (subject.metadata.parentEntityMetadata.hasVersionColumn) {\n                let valueMap = valueMaps.find(valueMap => valueMap.tableName === subject.metadata.parentEntityMetadata.table.name);\n                if (!valueMap) {\n                    valueMap = {\n                        tableName: subject.metadata.parentEntityMetadata.table.name,\n                        metadata: subject.metadata.parentEntityMetadata,\n                        values: {}\n                    };\n                    valueMaps.push(valueMap);\n                }\n\n                valueMap.values[subject.metadata.parentEntityMetadata.versionColumn.name] = this.connection.driver.preparePersistentValue(entity[subject.metadata.parentEntityMetadata.versionColumn.propertyName] + 1, subject.metadata.parentEntityMetadata.versionColumn);\n            }\n        }\n\n        await Promise.all(valueMaps.map(valueMap => {\n            const idMap = valueMap.metadata.getDatabaseEntityIdMap(entity);\n            if (!idMap)\n                throw new Error(`Internal error. Cannot get id of the updating entity.`);\n\n            return this.queryRunner.update(valueMap.tableName, valueMap.values, idMap);\n        }));\n    }\n\n    // -------------------------------------------------------------------------\n    // Private Methods: Update only relations\n    // -------------------------------------------------------------------------\n\n    /**\n     * Updates relations of all given subjects in the database.\n     */\n    private executeUpdateRelations() {\n        return Promise.all(this.relationUpdateSubjects.map(subject => this.updateRelations(subject)));\n    }\n\n    /**\n     * Updates relations of the given subject in the database.\n     */\n    private async updateRelations(subject: Subject) {\n        const values: ObjectLiteral = {};\n        subject.relationUpdates.forEach(setRelation => {\n            const value = setRelation.value ? setRelation.value[setRelation.relation.joinColumn.referencedColumn.propertyName] : null;\n            values[setRelation.relation.name] = value; // todo: || fromInsertedSubjects ??\n        });\n\n        const idMap = subject.metadata.getDatabaseEntityIdMap(subject.databaseEntity);\n        if (!idMap)\n            throw new Error(`Internal error. Cannot get id of the updating entity.`);\n\n        return this.queryRunner.update(subject.metadata.table.name, values, idMap);\n    }\n\n    // -------------------------------------------------------------------------\n    // Private Methods: Remove\n    // -------------------------------------------------------------------------\n\n    /**\n     * Removes all given subjects from the database.\n     */\n    private async executeRemoveOperations(): Promise<void> {\n        await PromiseUtils.runInSequence(this.removeSubjects, async subject => await this.remove(subject));\n    }\n\n    /**\n     * Updates given subject from the database.\n     */\n    private async remove(subject: Subject): Promise<void> {\n        if (subject.metadata.parentEntityMetadata) {\n            const parentConditions: ObjectLiteral = {};\n            subject.metadata.parentPrimaryColumns.forEach(column => {\n                parentConditions[column.name] = subject.databaseEntity[column.propertyName];\n            });\n            await this.queryRunner.delete(subject.metadata.parentEntityMetadata.table.name, parentConditions);\n\n            const childConditions: ObjectLiteral = {};\n            subject.metadata.primaryColumnsWithParentIdColumns.forEach(column => {\n                childConditions[column.name] = subject.databaseEntity[column.propertyName];\n            });\n            await this.queryRunner.delete(subject.metadata.table.name, childConditions);\n        } else {\n            await this.queryRunner.delete(subject.metadata.table.name, subject.metadata.getEntityIdColumnMap(subject.databaseEntity)!);\n        }\n    }\n\n    // -------------------------------------------------------------------------\n    // Private Methods: Insertion into junction tables\n    // -------------------------------------------------------------------------\n\n    /**\n     * Inserts into database junction tables all given array of subjects junction data.\n     */\n    private async executeInsertJunctionsOperations(): Promise<void> {\n        const promises: Promise<any>[] = [];\n        this.allSubjects.forEach(subject => {\n            subject.junctionInserts.forEach(junctionInsert => {\n                promises.push(this.insertJunctions(subject, junctionInsert));\n            });\n        });\n\n        await Promise.all(promises);\n    }\n\n    /**\n     * Inserts into database junction table given subject's junction insert data.\n     */\n    private async insertJunctions(subject: Subject, junctionInsert: JunctionInsert): Promise<void> {\n        // I think here we can only support to work only with single primary key entities\n\n        const relation = junctionInsert.relation;\n        const joinTable = relation.isOwning ? relation.joinTable : relation.inverseRelation.joinTable;\n        const firstColumn = relation.isOwning ? joinTable.referencedColumn : joinTable.inverseReferencedColumn;\n        const secondColumn = relation.isOwning ? joinTable.inverseReferencedColumn : joinTable.referencedColumn;\n\n        let ownId = relation.getOwnEntityRelationId(subject.entity);\n        if (!ownId) {\n            if (firstColumn.isGenerated) {\n                ownId = subject.newlyGeneratedId;\n            }\n            // todo: implement other special referenced column types (update date, create date, version, discriminator column, etc.)\n        }\n\n        if (!ownId)\n            throw new Error(`Cannot insert object of ${subject.entityTarget} type. Looks like its not persisted yet, or cascades are not set on the relation.`); // todo: better error message\n\n        const promises = junctionInsert.junctionEntities.map(newBindEntity => {\n\n            // get relation id from the newly bind entity\n            let relationId: any;\n            if (relation.isManyToManyOwner) {\n                relationId = newBindEntity[relation.joinTable.inverseReferencedColumn.propertyName];\n\n            } else if (relation.isManyToManyNotOwner) {\n                relationId = newBindEntity[relation.inverseRelation.joinTable.referencedColumn.propertyName];\n            }\n\n            // if relation id is missing in the newly bind entity then check maybe it was just persisted\n            // and we can use special newly generated value\n            if (!relationId) {\n                const insertSubject = this.insertSubjects.find(subject => subject.entity === newBindEntity);\n                if (insertSubject) {\n                    if (secondColumn.isGenerated) {\n                        relationId = insertSubject.newlyGeneratedId;\n                    }\n                    // todo: implement other special values too\n                }\n            }\n\n            // if relation id still does not exist - we arise an error\n            if (!relationId)\n                throw new Error(`Cannot insert object of ${(newBindEntity.constructor as any).name} type. Looks like its not persisted yet, or cascades are not set on the relation.`); // todo: better error message\n\n            const columns = relation.junctionEntityMetadata.columns.map(column => column.name);\n            const values = relation.isOwning ? [ownId, relationId] : [relationId, ownId];\n\n            return this.queryRunner.insert(relation.junctionEntityMetadata.table.name, OrmUtils.zipObject(columns, values));\n        });\n\n        await Promise.all(promises);\n    }\n\n    // -------------------------------------------------------------------------\n    // Private Methods: Remove from junction tables\n    // -------------------------------------------------------------------------\n\n    /**\n     * Removes from database junction tables all given array of subjects removal junction data.\n     */\n    private async executeRemoveJunctionsOperations(): Promise<void> {\n        const promises: Promise<any>[] = [];\n        this.allSubjects.forEach(subject => {\n            subject.junctionRemoves.forEach(junctionRemove => {\n                promises.push(this.removeJunctions(subject, junctionRemove));\n            });\n        });\n\n        await Promise.all(promises);\n    }\n\n    /**\n     * Removes from database junction table all given subject's removal junction data.\n     */\n    private async removeJunctions(subject: Subject, junctionRemove: JunctionRemove) {\n        const junctionMetadata = junctionRemove.relation.junctionEntityMetadata;\n        const entity = subject.hasEntity ? subject.entity : subject.databaseEntity;\n        const ownId = junctionRemove.relation.getOwnEntityRelationId(entity);\n        const ownColumn = junctionRemove.relation.isOwning ? junctionMetadata.columns[0] : junctionMetadata.columns[1];\n        const relateColumn = junctionRemove.relation.isOwning ? junctionMetadata.columns[1] : junctionMetadata.columns[0];\n        const removePromises = junctionRemove.junctionRelationIds.map(relationId => {\n            return this.queryRunner.delete(junctionMetadata.table.name, {\n                [ownColumn.name]: ownId,\n                [relateColumn.name]: relationId\n            });\n        });\n\n        await Promise.all(removePromises);\n    }\n\n    // -------------------------------------------------------------------------\n    // Private Methods: Refresh entity values after persistence\n    // -------------------------------------------------------------------------\n\n    /**\n     * Updates all special columns of the saving entities (create date, update date, versioning).\n     */\n    private updateSpecialColumnsInPersistedEntities() {\n\n        // update entity columns that gets updated on each entity insert\n        this.insertSubjects.forEach(subject => {\n            subject.metadata.primaryColumns.forEach(primaryColumn => {\n                if (subject.newlyGeneratedId)\n                    subject.entity[primaryColumn.propertyName] = subject.newlyGeneratedId;\n            });\n            subject.metadata.parentPrimaryColumns.forEach(primaryColumn => {\n                if (subject.parentGeneratedId)\n                    subject.entity[primaryColumn.propertyName] = subject.parentGeneratedId;\n            });\n\n            if (subject.metadata.hasUpdateDateColumn)\n                subject.entity[subject.metadata.updateDateColumn.propertyName] = subject.date;\n            if (subject.metadata.hasCreateDateColumn)\n                subject.entity[subject.metadata.createDateColumn.propertyName] = subject.date;\n            if (subject.metadata.hasVersionColumn)\n                subject.entity[subject.metadata.versionColumn.propertyName]++;\n            if (subject.metadata.hasTreeLevelColumn) {\n                // const parentEntity = insertOperation.entity[metadata.treeParentMetadata.propertyName];\n                // const parentLevel = parentEntity ? (parentEntity[metadata.treeLevelColumn.propertyName] || 0) : 0;\n                subject.entity[subject.metadata.treeLevelColumn.propertyName] = subject.treeLevel;\n            }\n            /*if (subject.metadata.hasTreeChildrenCountColumn) {\n                 subject.entity[subject.metadata.treeChildrenCountColumn.propertyName] = 0;\n            }*/\n        });\n\n        // update special columns that gets updated on each entity update\n        this.updateSubjects.forEach(subject => {\n            if (subject.metadata.hasUpdateDateColumn)\n                subject.entity[subject.metadata.updateDateColumn.propertyName] = subject.date;\n            if (subject.metadata.hasVersionColumn)\n                subject.entity[subject.metadata.versionColumn.propertyName]++;\n        });\n\n        // remove ids from the entities that were removed\n        this.removeSubjects\n            .filter(subject => subject.hasEntity)\n            .forEach(subject => {\n                subject.metadata.primaryColumns.forEach(primaryColumn => {\n                    subject.entity[primaryColumn.propertyName] = undefined;\n                });\n            });\n    }\n\n}"],"sourceRoot":".."}