{"version":3,"sources":["../../src/persistence/SubjectBuilder.ts"],"names":[],"mappings":"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","file":"SubjectBuilder.js","sourcesContent":["import {EntityMetadata} from \"../metadata/EntityMetadata\";\nimport {ObjectLiteral} from \"../common/ObjectLiteral\";\nimport {Connection} from \"../connection/Connection\";\nimport {Subject} from \"./Subject\";\nimport {QueryRunnerProvider} from \"../query-runner/QueryRunnerProvider\";\nimport {SpecificRepository} from \"../repository/SpecificRepository\";\n\n/**\n * To be able to execute persistence operations we need to load all entities from the database we need.\n * Loading should be efficient - we need to load entities in as few queries as possible + load as less data as we can.\n * This is how we determine which entities needs to be loaded from db:\n *\n * 1. example with cascade updates and inserts:\n *\n * [Y] - means \"yes, we load\"\n * [N] - means \"no, we don't load\"\n * in {} braces we specify what cascade options are set between relations\n *\n * if Post is new, author is not set in the post\n *\n * [Y] Post -> {all} // yes because of \"update\" and \"insert\" cascades, no because of \"remove\"\n *   [Y] Author -> {all} // no because author is not set\n *     [Y] Photo -> {all} // no because author and its photo are not set\n *       [Y] Tag -> {all} // no because author and its photo and its tag are not set\n *\n * if Post is new, author is new (or anything else is new)\n * if Post is updated\n * if Post and/or Author are updated\n *\n * [Y] Post -> {all} // yes because of \"update\" and \"insert\" cascades, no because of \"remove\"\n *   [Y] Author -> {all} // yes because of \"update\" and \"insert\" cascades, no because of \"remove\"\n *     [Y] Photo -> {all} // yes because of \"update\" and \"insert\" cascades, no because of \"remove\"\n *       [Y] Tag -> {all} // yes because of \"update\" and \"insert\" cascades, no because of \"remove\"\n *\n * Here we load post, author, photo, tag to check if they are new or not to persist insert or update operation.\n * We load post, author, photo, tag only if they exist in the relation.\n * From these examples we can see that we always load entity relations when it has \"update\" or \"insert\" cascades.\n *\n * 2. example with cascade removes\n *\n * if entity is new its remove operations by cascades should not be executed\n * if entity is updated then values that are null or missing in array (not undefined!, undefined means skip - don't do anything) are treated as removed\n * if entity is removed then all its downside relations which has cascade remove should be removed\n *\n * Once we find removed entity - we load it, and every downside entity which has \"remove\" cascade set.\n *\n * At the end we have all entities we need to operate with.\n * Next step is to store all loaded entities to manipulate them efficiently.\n *\n * Rules of updating by cascades.\n * Insert operation can lead to:\n *  - insert operations\n *  - update operations\n * Update operation can lead to:\n *  - insert operations\n *  - update operations\n *  - remove operations\n * Remove operation can lead to:\n *  - remove operation\n */\nexport class SubjectBuilder<Entity extends ObjectLiteral> {\n\n    // -------------------------------------------------------------------------\n    // Protected properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * If this gonna be reused then what to do with marked flags?\n     * One of solution can be clone this object and reset all marked states for this persistence.\n     * Or from reused just extract databaseEntities from their subjects? (looks better)\n     */\n    operateSubjects: Subject[] = [];\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(protected connection: Connection,\n                protected queryRunnerProvider: QueryRunnerProvider) {\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Builds operations for entity that is being inserted/updated.\n     */\n    async persist(entity: Entity, metadata: EntityMetadata): Promise<void> {\n\n        // create subject for currently persisted entity and mark that it can be inserted and updated\n        const mainPersistedSubject = new Subject(metadata, entity);\n        mainPersistedSubject.canBeInserted = true;\n        mainPersistedSubject.canBeUpdated = true;\n        this.operateSubjects.push(mainPersistedSubject);\n\n        // next step we build list of subjects we will operate with\n        // these subjects are subjects that we need to insert or update alongside with main persisted entity\n        this.buildCascadeUpdateAndInsertOperateSubjects(mainPersistedSubject);\n\n        // next step is to load database entities of all operate subjects\n        await this.loadOperateSubjectsDatabaseEntities();\n\n        // next step - we filter subjects with database entities (only for non-new entities)\n        // and find operate subjects that needs to be removed\n        // here we also find operate subjects which relations should be updated\n        // these relations usually are \"update from inverse side\" operations\n        const operateSubjectsWithDatabaseEntities = this.operateSubjects.filter(subject => subject.hasDatabaseEntity);\n        await Promise.all(operateSubjectsWithDatabaseEntities.map(subject => {\n            return this.buildCascadeRemovedAndRelationUpdateOperateSubjects(subject);\n        }));\n\n        // finally find which operate subjects have insert and remove operations in their junction tables\n        await this.buildJunctionOperations({ insert: true, remove: true });\n    }\n\n    /**\n     * Builds only remove operations for entity that is being removed.\n     */\n    async remove(entity: Entity, metadata: EntityMetadata): Promise<void> {\n\n        // create subject for currently removed entity and mark that it must be removed\n        const mainRemovedSubject = new Subject(metadata, entity);\n        mainRemovedSubject.mustBeRemoved = true;\n        this.operateSubjects.push(mainRemovedSubject);\n\n        // next step we build list of subjects we will operate with\n        // these subjects are subjects that we need to remove alongside with main removed entity\n        this.buildCascadeRemoveOperateSubjects(mainRemovedSubject);\n\n        // next step is to load database entities for all operate subjects\n        await this.loadOperateSubjectsDatabaseEntities();\n\n        // next step - we filter subjects with database entities (only for non-new entities)\n        // and find operate subjects that needs to be removed\n        // todo(this should not be in remove?) // here we also find operate subjects which relations should be updated\n        // todo(this should not be in remove?) // these relations usually are \"update from inverse side\" operations\n        const operateSubjectsWithDatabaseEntities = this.operateSubjects.filter(subject => subject.hasDatabaseEntity);\n        await Promise.all(operateSubjectsWithDatabaseEntities.map(subject => {\n            return this.buildCascadeRemovedAndRelationUpdateOperateSubjects(subject);\n        }));\n\n        // finally find which operate subjects have remove operations in their junction tables\n        await this.buildJunctionOperations({ insert: false, remove: true });\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Builds and pushes to array of operate entities all entities that we will work with.\n     * These are only relational entities which has insert and update cascades.\n     * All such entities will be loaded from the database, because they can be inserted or updated.\n     * That's why we load them - to understand if they should be inserted or updated, or which columns we need to update.\n     * We can't add removed entities here, because to know which entity was removed we need first to\n     * load original entity (particularly its id) from the database.\n     * That's why we first need to load all changed entities, then extract ids of the removed entities from them,\n     * and only then load removed entities by extracted ids.\n     */\n    protected buildCascadeUpdateAndInsertOperateSubjects(subject: Subject): void {\n        subject.metadata\n            .extractRelationValuesFromEntity(subject.entity, subject.metadata.relations)\n            .filter(([relation, value, valueMetadata]) => {\n\n                // we need only defined values and insert or update cascades of the relation should be set\n                return value !== undefined && value !== null && (relation.isCascadeInsert || relation.isCascadeUpdate);\n            })\n            .forEach(([relation, value, valueMetadata]) => {\n\n                // if we already has this entity in list of operated subjects then skip it to avoid recursion\n                const alreadyExistValueSubject = this.findByEntityLike(valueMetadata.target, value);\n                if (alreadyExistValueSubject) {\n                    if (alreadyExistValueSubject.canBeInserted === false)\n                        alreadyExistValueSubject.canBeInserted = relation.isCascadeInsert === true;\n                    if (alreadyExistValueSubject.canBeUpdated === false)\n                        alreadyExistValueSubject.canBeUpdated = relation.isCascadeUpdate === true;\n                    return;\n                }\n\n                // mark subject with what we can do with it\n                // and add to the array of subjects to load only if there is no same entity there already\n                const valueSubject = new Subject(valueMetadata, value);\n                valueSubject.canBeInserted = relation.isCascadeInsert === true;\n                valueSubject.canBeUpdated = relation.isCascadeUpdate === true;\n                this.operateSubjects.push(valueSubject);\n\n                // go recursively and find other entities we need to operate with\n                this.buildCascadeUpdateAndInsertOperateSubjects(valueSubject);\n            });\n    }\n\n    /**\n     * Builds and pushes to array of operate entities all entities that must be removed.\n     */\n    protected buildCascadeRemoveOperateSubjects(subject: Subject): void {\n        subject.metadata\n            .extractRelationValuesFromEntity(subject.entity, subject.metadata.relations)\n            .filter(([relation, value, valueMetadata]) => {\n\n                // we need only defined values and insert cascades of the relation should be set\n                return value !== undefined && value !== null && relation.isCascadeRemove;\n            })\n            .forEach(([relation, value, valueMetadata]) => {\n\n                // if we already has this entity in list of operated subjects then skip it to avoid recursion\n                const alreadyExistValueSubject = this.findByEntityLike(valueMetadata.target, value);\n                if (alreadyExistValueSubject) {\n                    alreadyExistValueSubject.mustBeRemoved = true;\n                    return;\n                }\n\n                // add to the array of subjects to load only if there is no same entity there already\n                const valueSubject = new Subject(valueMetadata, value);\n                valueSubject.mustBeRemoved = true;\n                this.operateSubjects.push(valueSubject);\n\n                // go recursively and find other entities to load by cascades in currently inserted entities\n                this.buildCascadeRemoveOperateSubjects(valueSubject);\n            });\n    }\n\n    /**\n     * Loads database entities for all operate subjects which do not have database entity set.\n     * All entities that we load database entities for are marked as updated or inserted.\n     * To understand which of them really needs to be inserted or updated we need to load\n     * their original representations from the database.\n     */\n    protected async loadOperateSubjectsDatabaseEntities(): Promise<void> {\n\n        // we are grouping subjects by target to perform more optimized queries using WHERE IN operator\n        // go throw the groups and perform loading of database entities of each subject in the group\n        const promises = this.groupByEntityTargets().map(async subjectGroup => {\n\n            // prepare entity ids of the subjects we need to load\n            const allIds = subjectGroup.subjects\n                .filter(subject => !subject.hasDatabaseEntity) // we don't load if subject already has a database entity loaded\n                .map(subject => subject.metadata.getEntityIdMixedMap(subject.entity)) // we only need entity id\n                .filter(mixedId => { // we don't need empty ids\n                    if (mixedId instanceof Object)\n                        return Object.keys(mixedId).every(key => mixedId[key] !== undefined && mixedId[key] !== null && mixedId[key] !== \"\");\n\n                    return mixedId !== undefined && mixedId !== null && mixedId !== \"\";\n                });\n\n            // if there no ids found (which means all entities are new and have generated ids) - then nothing to load there\n            if (!allIds.length)\n                return;\n\n            // load database entities for all given ids\n            const entities = await this.connection\n                .getRepository<ObjectLiteral>(subjectGroup.target)\n                .createQueryBuilder(\"operateSubject\", this.queryRunnerProvider)\n                .andWhereInIds(allIds)\n                .enableOption(\"RELATION_ID_VALUES\")\n                .getMany();\n\n            // now when we have entities we need to find subject of each entity\n            // and insert that entity into database entity of the found subject\n            entities.forEach(entity => {\n                const subject = this.findByEntityLike(subjectGroup.target, entity);\n                if (subject)\n                    subject.databaseEntity = entity;\n            });\n\n        });\n\n        await Promise.all(promises);\n    }\n\n    /**\n     * We need to load removed entity when:\n     *  - entity with relations is not new (this can be determined only after entity is loaded from db)\n     *      (note: simple \"id\" check will not work because id can be not generated)\n     *  - entity missing relation. When relation is simple\n     *      - in the case of one-to-one owner (with join column) relation we need to load owner entity\n     *      - in the case of one-to-one (without join column) relation we need to load inverse side entity\n     *      - in the case of many-to-one relations we need to load entity itself\n     *      - in the case of one-to-many relations we need to load entities by relation from inverse side\n     *\n     *  Before loading each entity we need to check in the loaded subjects - maybe it was already loaded.\n     *\n     *  BIG NOTE: objects are being removed by cascades not only when relation is removed, but also when\n     *  relation is replaced (e.g. changed with different object).\n     */\n    protected async buildCascadeRemovedAndRelationUpdateOperateSubjects(subject: Subject): Promise<void> {\n\n        // note: we can't use extractRelationValuesFromEntity here because it does not handle empty arrays\n        const promises = subject.metadata.relations.map(async relation => {\n            const valueMetadata = relation.inverseEntityMetadata;\n            const qbAlias = valueMetadata.table.name;\n\n            // added for type-safety, but subject without databaseEntity cant come here anyway because of checks on upper levels\n            if (!subject.hasDatabaseEntity) return;\n\n            // for one-to-one owner and many-to-one relations no need to load entity to check if something removed\n            // because join column is in this side of relation and we have a database entity with which we can compare\n            // and understand if relation was removed or not\n            if (relation.isOneToOneOwner || relation.isManyToOne) {\n\n                // we only work with cascade removes here\n                if (!relation.isCascadeRemove) return;\n\n                /**\n                 * By example (one-to-one owner). Let's say we have a one-to-one relation between Post and Details.\n                 * Post contains detailsId. It means he owns relation. Post has cascade remove with details.\n                 * Now here we have a post object with removed details.\n                 * We need to remove Details if post.details = null\n                 * or if post.details != databasePost.details\n                 */\n\n                /**\n                 * By example (many-to-one). Let's say we have a many-to-one relation between Post and Details.\n                 * Post contains detailsId. It means he owns relation.\n                 * It also means that post can have only one details, and details can have multiple posts.\n                 * Post has cascade remove with details.\n                 * Now here we have a post object with removed details.\n                 * We need to remove Details (one) if post.details = null\n                 * or if post.details != databasePost.details\n                 */\n\n                // (example) \"relation\" - is a relation in post with details.\n                // (example) \"valueMetadata\" - is an entity metadata of the Details object.\n                // (example) \"persistValue\" - is a detailsId from the persisted entity\n\n                // note that if databaseEntity has relation, it can only be a relation id,\n                // because of query builder option \"RELATION_ID_VALUES\" we used\n                const relationIdInDatabaseEntity = subject.databaseEntity[relation.joinColumn.propertyName]; // (example) returns post.detailsId\n\n                // if database relation id does not exist in the database object then nothing to remove\n                if (relationIdInDatabaseEntity === null || relationIdInDatabaseEntity === undefined)\n                    return;\n\n                // if this subject is persisted subject then we get its value to check if its not empty or its values changed\n                let persistValueRelationId: any = undefined;\n                if (subject.hasEntity) {\n                    const persistValue = relation.getEntityValue(subject.entity);\n                    if (persistValue === null) persistValueRelationId = null;\n                    if (persistValue) persistValueRelationId = persistValue[relation.joinColumn.referencedColumn.propertyName];\n                    if (persistValueRelationId === undefined) return; // skip undefined properties\n                }\n\n                // object is removed only if relation id in the persisted entity is empty or is changed\n                if (persistValueRelationId !== null && persistValueRelationId === relationIdInDatabaseEntity)\n                    return;\n\n                // first check if we already loaded this object before load from the database\n                let alreadyLoadedRelatedDatabaseSubject = this.operateSubjects.find(relatedSubject => {\n\n                    // (example) filter only subject that has database entity loaded and its target is Details\n                    if (!relatedSubject.hasDatabaseEntity || relatedSubject.entityTarget !== valueMetadata.target)\n                        return false;\n\n                    // (example) here we seek a Details loaded from the database in the subjects\n                    // (example) here relatedSubject.databaseEntity is a Details\n                    // (example) and we need to compare details.id === post.detailsId\n                    return relatedSubject.databaseEntity[relation.joinColumn.referencedColumn.propertyName] === relationIdInDatabaseEntity;\n                });\n\n                // if not loaded yet then load it from the database\n                if (!alreadyLoadedRelatedDatabaseSubject) {\n\n                    // (example) we need to load a details where details.id = post.details\n                    const databaseEntity = await this.connection\n                        .getRepository<ObjectLiteral>(valueMetadata.target)\n                        .createQueryBuilder(qbAlias, this.queryRunnerProvider)\n                        .where(qbAlias + \".\" + relation.joinColumn.referencedColumn.propertyName + \"=:id\")\n                        .setParameter(\"id\", relationIdInDatabaseEntity) // (example) subject.entity is a post here\n                        .enableOption(\"RELATION_ID_VALUES\")\n                        .getOne();\n\n                    if (databaseEntity) {\n                        alreadyLoadedRelatedDatabaseSubject = new Subject(valueMetadata, undefined, databaseEntity);\n                        this.operateSubjects.push(alreadyLoadedRelatedDatabaseSubject);\n                    }\n                }\n\n                if (alreadyLoadedRelatedDatabaseSubject) {\n\n                    // if object is already marked as removed then no need to proceed because it already was proceed\n                    // if we remove this it will cause a recursion\n                    if (alreadyLoadedRelatedDatabaseSubject.mustBeRemoved)\n                        return;\n\n                    alreadyLoadedRelatedDatabaseSubject.mustBeRemoved = true;\n                    await this.buildCascadeRemovedAndRelationUpdateOperateSubjects(alreadyLoadedRelatedDatabaseSubject);\n                }\n            }\n\n            // for one-to-one not owner we need to load entity to understand that it was really removed or not,\n            // since column value that indicates relation is stored on inverse side\n            if (relation.isOneToOneNotOwner) {\n\n                // we only work with cascade removes here\n                if (!relation.isCascadeRemove) return; // todo: no\n\n                /**\n                 * By example. Let's say we have a one-to-one relation between Post and Details.\n                 * Post contains detailsId. It means he owns relation. Details has cascade remove with post.\n                 * Now here we have a details object with removed post.\n                 * We need to remove Post if details.post = null and databasePost.detailsId = details.id exist in the db,\n                 * or if databasePost.id === details.post.id (we need to load it) and databasePost.detailsId != details.id\n                 */\n\n                // (example) \"relation\" - is a relation in details with post.\n                // (example) \"valueMetadata\" - is an entity metadata of the Post object.\n                // (example) \"subject.databaseEntity\" - is a details object\n\n                // if this subject is persisted subject then we get its value to check if its not empty or its values changed\n                let persistValueRelationId: any = undefined;\n                if (subject.hasEntity && !subject.mustBeRemoved) {\n                    const persistValue = relation.getEntityValue(subject.entity);\n                    if (persistValue) persistValueRelationId = persistValue[relation.inverseRelation.joinColumn.propertyName];\n                    if (persistValueRelationId === undefined) return; // skip undefined properties\n                }\n\n                // (example) returns us referenced column (detail's id)\n                const relationIdInDatabaseEntity = subject.databaseEntity[relation.inverseRelation.joinColumn.referencedColumn.propertyName];\n\n                // if database relation id does not exist then nothing to remove (but can this be possible?)\n                if (relationIdInDatabaseEntity === null || relationIdInDatabaseEntity === undefined)\n                    return;\n\n                // first check if we already have this object loaded before load from the database\n                let alreadyLoadedRelatedDatabaseSubject = this.operateSubjects.find(relatedSubject => {\n\n                    // (example) filter only subject that has database entity loaded and its target is Post\n                    if (!relatedSubject.hasDatabaseEntity || relatedSubject.entityTarget !== valueMetadata.target)\n                        return false;\n\n                    // (example) here we seek a Post loaded from the database in the subjects\n                    // (example) here relatedSubject.databaseEntity is a Post\n                    // (example) and we need to compare post.detailsId === details.id\n                    return relatedSubject.databaseEntity[relation.inverseRelation.joinColumn.propertyName] === relationIdInDatabaseEntity;\n                });\n\n                // if not loaded yet then load it from the database\n                if (!alreadyLoadedRelatedDatabaseSubject) {\n\n                    // (example) we need to load a post where post.detailsId = details.id\n                    const databaseEntity = await this.connection\n                        .getRepository<ObjectLiteral>(valueMetadata.target)\n                        .createQueryBuilder(qbAlias, this.queryRunnerProvider)\n                        .where(qbAlias + \".\" + relation.inverseSideProperty + \"=:id\")\n                        .setParameter(\"id\", relationIdInDatabaseEntity) // (example) subject.entity is a details here, and the value is details.id\n                        .enableOption(\"RELATION_ID_VALUES\")\n                        .getOne();\n\n                    // add only if database entity exist - because in the case of inverse side of the one-to-one relation\n                    // we cannot check if it was removed or not until we query the database\n                    // and it can be a situation that relation wasn't exist at all. This is particular that case\n                    alreadyLoadedRelatedDatabaseSubject = new Subject(valueMetadata, undefined, databaseEntity);\n                    this.operateSubjects.push(alreadyLoadedRelatedDatabaseSubject);\n                }\n\n                // check if we really has a relation between entities. If relation not found then alreadyLoadedRelatedDatabaseSubject will be empty\n                if (alreadyLoadedRelatedDatabaseSubject && alreadyLoadedRelatedDatabaseSubject.hasDatabaseEntity) {\n\n                    // also check if relation value exist then then make sure its changed\n                    // (example) persistValue is a postFromPersistedDetails here\n                    // (example) alreadyLoadedRelatedDatabaseSubject.databaseEntity is a postFromDatabaseDetails here\n                    // (example) postFromPersistedDetails.id === postFromDatabaseDetails - means nothing changed\n                    const inverseEntityRelationId = alreadyLoadedRelatedDatabaseSubject.databaseEntity[relation.inverseRelation.joinColumn.propertyName];\n                    if (persistValueRelationId && persistValueRelationId === inverseEntityRelationId)\n                        return;\n\n                    // if object is already marked as removed then no need to proceed because it already was proceed\n                    // if we remove this it will cause a recursion\n                    if (alreadyLoadedRelatedDatabaseSubject.mustBeRemoved)\n                        return;\n\n                    alreadyLoadedRelatedDatabaseSubject.mustBeRemoved = true;\n                    await this.buildCascadeRemovedAndRelationUpdateOperateSubjects(alreadyLoadedRelatedDatabaseSubject);\n                }\n            }\n\n            // for one-to-many we need to load entities to understand which was really removed\n            // since column value that indicates relation is stored on inverse side\n            if (relation.isOneToMany || relation.isManyToMany) {\n\n                // we only work with cascade removes here\n                // if (!relation.isCascadeRemove && !relation.isCascadeUpdate) return;\n\n                /**\n                 * By example. Let's say we have a one-to-many relation between Post and Details.\n                 * Post contains detailsId. It means he owns relation.\n                 * It also means that one details contains multiple post, and one post contain only one details.\n                 * Details has cascade remove with post.\n                 * Now here we have a details object with removed post.\n                 * There can be one or multiple removed posts, because posts is an array in details.\n                 * If details.posts is undefined then we skip it as we do with any persisted undefined property.\n                 * If details.posts is an empty array it means all its items should be removed.\n                 * If details.posts is a null it means same - all its items has been removed.\n                 * We need to remove each Post in the databaseDetails where post is missing in details.posts\n                 * but databasePost.detailsId = details.id exist in the db.\n                 */\n\n                // (example) \"relation\" - is a relation in details with post.\n                // (example) \"valueMetadata\" - is an entity metadata of the Post object.\n                // (example) \"subject.databaseEntity\" - is a details object\n\n                // if this subject is persisted subject then we get its value to check if its not empty or its values changed\n                let persistValue: any = undefined;\n                if (subject.hasEntity) {\n                    persistValue = relation.getEntityValue(subject.entity);\n                    if (persistValue === undefined) return; // skip undefined properties\n                }\n\n                // we can't get already loaded objects from loadMap because we don't know exactly how\n                // many objects are in database entity, and entities from loadMap may return us not all of them\n                // that's why we are forced to load all its entities from the database even if loaded some of them before\n                // (example) we need to load a posts where post.detailsId = details.id\n                let databaseEntities: ObjectLiteral[] = [];\n\n                // create shortcuts for better readability\n                const escapeAlias = (alias: string) => this.connection.driver.escapeAliasName(alias);\n                const escapeColumn = (column: string) => this.connection.driver.escapeColumnName(column);\n\n                if (relation.isManyToManyOwner) {\n\n                    // (example) returns us referenced column (detail's id)\n                    const relationIdInDatabaseEntity = subject.databaseEntity[relation.joinTable.referencedColumn.propertyName];\n\n                    // we only need to load inverse entities if cascade removes are set\n                    // because remove by cascades is the only reason we need relational entities here\n                    if (!relation.isCascadeRemove) return;\n\n                    databaseEntities = await this.connection\n                        .getRepository<ObjectLiteral>(valueMetadata.target)\n                        .createQueryBuilder(qbAlias, this.queryRunnerProvider)\n                        .innerJoin(relation.junctionEntityMetadata.table.name, \"persistenceJoinedRelation\",\n                            escapeAlias(\"persistenceJoinedRelation\") + \".\" + escapeColumn(relation.joinTable.inverseJoinColumnName) + \"=\" + escapeAlias(qbAlias) + \".\" + escapeColumn(relation.joinTable.inverseReferencedColumn.name) +\n                            \" AND \" + escapeAlias(\"persistenceJoinedRelation\") + \".\" + escapeColumn(relation.joinTable.joinColumnName) + \"=:id\")\n                        .setParameter(\"id\", relationIdInDatabaseEntity)\n                        .enableOption(\"RELATION_ID_VALUES\")\n                        .getMany();\n\n                } else if (relation.isManyToManyNotOwner) {\n\n                    // (example) returns us referenced column (detail's id)\n                    const relationIdInDatabaseEntity = subject.databaseEntity[relation.inverseRelation.joinTable.inverseReferencedColumn.propertyName];\n\n                    // we only need to load inverse entities if cascade removes are set\n                    // because remove by cascades is the only reason we need relational entities here\n                    if (!relation.isCascadeRemove) return;\n\n                    databaseEntities = await this.connection\n                        .getRepository<ObjectLiteral>(valueMetadata.target)\n                        .createQueryBuilder(qbAlias, this.queryRunnerProvider)\n                        .innerJoin(relation.junctionEntityMetadata.table.name, \"persistenceJoinedRelation\",\n                            escapeAlias(\"persistenceJoinedRelation\") + \".\" + escapeColumn(relation.joinTable.joinColumnName) + \"=\" + escapeAlias(qbAlias) + \".\" + escapeColumn(relation.joinTable.referencedColumn.name) +\n                            \" AND \" + escapeAlias(\"persistenceJoinedRelation\") + \".\" + escapeColumn(relation.inverseRelation.joinTable.inverseJoinColumnName) + \"=:id\")\n                        .setParameter(\"id\", relationIdInDatabaseEntity)\n                        .enableOption(\"RELATION_ID_VALUES\")\n                        .getMany();\n\n                } else { // this case can only be a oneToMany relation\n\n                    // (example) returns us referenced column (detail's id)\n                    const relationIdInDatabaseEntity = subject.databaseEntity[relation.inverseRelation.joinColumn.referencedColumn.propertyName];\n\n                    // in this case we need inverse entities not only because of cascade removes\n                    // because we also need inverse entities to be able to perform update of entities\n                    // in the inverse side when entities is detached from one-to-many relation\n\n                    databaseEntities = await this.connection\n                        .getRepository<ObjectLiteral>(valueMetadata.target)\n                        .createQueryBuilder(qbAlias, this.queryRunnerProvider)\n                        .where(qbAlias + \".\" + relation.inverseSideProperty + \"=:id\")\n                        .setParameter(\"id\", relationIdInDatabaseEntity)\n                        .enableOption(\"RELATION_ID_VALUES\")\n                        .getMany();\n                }\n\n                // add to loadMap loaded entities if some of them are missing\n                databaseEntities.forEach(databaseEntity => {\n                    const subjectInLoadMap = this.findByEntityLike(valueMetadata.target, databaseEntity);\n                    if (subjectInLoadMap && !subjectInLoadMap.hasDatabaseEntity) {\n                        subjectInLoadMap.databaseEntity = databaseEntity;\n\n                    } else if (!subjectInLoadMap) {\n                        const subject = new Subject(valueMetadata, undefined, databaseEntity);\n                        this.operateSubjects.push(subject);\n                    }\n                });\n\n\n                // add new relations for newly bind entities from the one-to-many relations\n                if (relation.isOneToMany && persistValue) { // todo: implement same for one-to-one\n                    const promises = (persistValue as ObjectLiteral[]).map(async persistValue => {\n\n                        // try to find in the database entities persistedValue (entity bind to this relation)\n                        const persistedValueInDatabaseEntity = databaseEntities.find(databaseEntity => {\n                            return valueMetadata.compareEntities(persistValue, databaseEntity);\n                        });\n\n                        // if it does not exist in the database entity - it means we need to bind it\n                        // to bind it we need to update related entity itself\n                        // this operation is performed only in one-to-many relations\n                        if (!persistedValueInDatabaseEntity) {\n\n                            // now find subject with\n                            let loadedSubject = this.findByDatabaseEntityLike(valueMetadata.target, persistValue);\n                            if (!loadedSubject) {\n                                const id = valueMetadata.getEntityIdMixedMap(persistValue);\n                                if (id) { // if there is no id (for newly inserted) then we cant load\n                                    const databaseEntity = await this.connection\n                                        .getRepository<ObjectLiteral>(valueMetadata.target)\n                                        .createQueryBuilder(qbAlias, this.queryRunnerProvider)\n                                        .andWhereInIds([id])\n                                        .enableOption(\"RELATION_ID_VALUES\")\n                                        .getOne();\n\n                                    if (databaseEntity) {\n                                        loadedSubject = new Subject(valueMetadata, undefined, databaseEntity); // todo: what if entity like object exist in the loaded subjects but without databaseEntity?\n                                        this.operateSubjects.push(loadedSubject);\n                                    }\n                                }\n                            }\n\n                            if (loadedSubject)\n                                loadedSubject.relationUpdates.push({\n                                    relation: relation.inverseRelation,\n                                    value: subject.entity\n                                });\n                        }\n                    });\n\n                    await Promise.all(promises);\n                }\n\n                // iterate throw loaded inverse entities to find out removed entities and inverse updated entities (only for one-to-many relation)\n                const promises = databaseEntities.map(async databaseEntity => {\n\n                    // find a subject object of the related database entity\n                    let relatedEntitySubject = this.findByDatabaseEntityLike(valueMetadata.target, databaseEntity);\n                    if (!relatedEntitySubject) return; // should not be possible, anyway add it for type-safety\n\n                    // if object is already marked as removed then no need to proceed because it already was proceed\n                    // if we remove this check it will cause a recursion\n                    if (relatedEntitySubject.mustBeRemoved) return;  // todo: add another check for entity in unsetRelations?\n\n                    // check if in persisted value there is a database value to understand if it was removed or not\n                    let relatedValue = ((persistValue || []) as ObjectLiteral[]).find(persistValueItem => {\n                        return valueMetadata.compareEntities(relatedEntitySubject!.databaseEntity, persistValueItem);\n                    });\n\n                    // if relation value is set to undefined then we don't do anything - simply skip any check and remove\n                    // but if relation value is set to null then it means user wants to remove each entity in this relation\n                    // OR\n                    // value was removed from persisted value - means we need to mark it as removed\n                    // and check if mark as removed all underlying entities that has cascade remove\n                    if (persistValue === null || !relatedValue) {\n\n                        // if cascade remove option is set then need to remove related entity\n                        if (relation.isCascadeRemove) {\n                            relatedEntitySubject.mustBeRemoved = true;\n\n                            // mark as removed all underlying entities that has cascade remove\n                            await this.buildCascadeRemovedAndRelationUpdateOperateSubjects(relatedEntitySubject);\n\n                        // if cascade remove option is not set then it means we simply need to remove\n                        // reference to this entity from inverse side (from loaded database entity)\n                        // this applies only on one-to-many relationship\n                        } else if (relation.isOneToMany && relation.inverseRelation) {\n                            relatedEntitySubject.relationUpdates.push({\n                                relation: relation.inverseRelation,\n                                value: null\n                            }); // todo: implement same for one-to-one\n                        }\n\n                    }\n\n                });\n\n                await Promise.all(promises);\n            }\n        });\n\n        await Promise.all(promises);\n    }\n\n    /**\n     * Builds all junction insert and remove operations used to insert new bind data into junction tables,\n     * or remove old junction records.\n     * Options specifies which junction operations should be built - insert, remove or both.\n     */\n    private async buildJunctionOperations(options: { insert: boolean, remove: boolean }): Promise<void> {\n\n        const promises = this.operateSubjects.filter(subject => subject.hasEntity).map(subject => {\n            const promises = subject.metadata.manyToManyRelations.map(async relation => {\n\n                // if subject marked to be removed then all its junctions must be removed\n                if (subject.mustBeRemoved && options.remove) {\n\n                    // load from db all relation ids of inverse entities that are \"bind\" to the currently persisted entity\n                    // this way we gonna check which relation ids are missing and which are new (e.g. inserted or removed)\n                    const specificRepository = new SpecificRepository(this.connection, subject.metadata, this.queryRunnerProvider);\n                    const existInverseEntityRelationIds = await specificRepository\n                        .findRelationIds(relation, subject.databaseEntity);\n\n                    // finally create a new junction remove operation and push it to the array of such operations\n                    if (existInverseEntityRelationIds.length > 0) {\n                        subject.junctionRemoves.push({\n                            relation: relation,\n                            junctionRelationIds: existInverseEntityRelationIds\n                        });\n                    }\n\n                    return;\n                }\n\n                // if entity don't have entity then no need to find something that should be inserted or removed\n                if (!subject.hasEntity)\n                    return;\n\n                // else check changed junctions in the persisted entity\n                // extract entity value - we only need to proceed if value is defined and its an array\n                const relatedValue = relation.getEntityValue(subject.entity);\n                if (!(relatedValue instanceof Array))\n                    return;\n\n                // load from db all relation ids of inverse entities that are \"bind\" to the currently persisted entity\n                // this way we gonna check which relation ids are missing and which are new (e.g. inserted or removed)\n                // we could load this relation ids with entity using however this way it may be more efficient, because\n                // this way we load only relations that come, e.g. we don't load data for empty relations set with object.\n                // this is also useful when object is being saved partial.\n                let existInverseEntityRelationIds: any[] = [];\n\n                // if subject don't have database entity it means its new and we don't need to remove something that is not exist\n                if (subject.hasDatabaseEntity) {\n                    const specificRepository = new SpecificRepository(this.connection, subject.metadata, this.queryRunnerProvider);\n                    existInverseEntityRelationIds = await specificRepository\n                        .findRelationIds(relation, subject.databaseEntity);\n                }\n\n                // get all inverse entities relation ids that are \"bind\" to the currently persisted entity\n                const changedInverseEntityRelationIds = relatedValue\n                    .map(subRelationValue => {\n                        return relation.isManyToManyOwner\n                            ? subRelationValue[relation.joinTable.inverseReferencedColumn.propertyName]\n                            : subRelationValue[relation.inverseRelation.joinTable.referencedColumn.propertyName];\n                    })\n                    .filter(subRelationValue => subRelationValue !== undefined && subRelationValue !== null);\n\n                // now from all entities in the persisted entity find only those which aren't found in the db\n                const removedJunctionEntityIds = existInverseEntityRelationIds.filter(existRelationId => {\n                    return !changedInverseEntityRelationIds.find(changedRelationId => {\n                        return changedRelationId === existRelationId;\n                    });\n                });\n\n                // now from all entities in the persisted entity find only those which aren't found in the db\n                const newJunctionEntities = relatedValue.filter(subRelatedValue => {\n                    const relationValue = relation.isManyToManyOwner\n                        ? subRelatedValue[relation.joinTable.inverseReferencedColumn.propertyName]\n                        : subRelatedValue[relation.inverseRelation.joinTable.referencedColumn.propertyName];\n                    return !existInverseEntityRelationIds.find(relationId => relationValue === relationId);\n                });\n\n                // finally create a new junction insert operation and push it to the array of such operations\n                if (newJunctionEntities.length > 0 && options.insert) {\n                    subject.junctionInserts.push({\n                        relation: relation,\n                        junctionEntities: newJunctionEntities\n                    });\n                }\n\n                // finally create a new junction remove operation and push it to the array of such operations\n                if (removedJunctionEntityIds.length > 0 && options.remove) {\n                    subject.junctionRemoves.push({\n                        relation: relation,\n                        junctionRelationIds: removedJunctionEntityIds\n                    });\n                }\n            });\n\n            return Promise.all(promises);\n        });\n\n        await Promise.all(promises);\n    }\n\n    /**\n     * Finds subject where entity like given subject's entity.\n     * Comparision made by entity id.\n     */\n    protected findByEntityLike(entityTarget: Function|string, entity: ObjectLiteral): Subject|undefined {\n        return this.operateSubjects.find(subject => {\n            if (!subject.hasEntity)\n                return false;\n\n            if (subject.entity === entity)\n                return true;\n\n            return subject.entityTarget === entityTarget && subject.metadata.compareEntities(subject.entity, entity);\n        });\n    }\n\n    /**\n     * Finds subject where entity like given subject's database entity.\n     * Comparision made by entity id.\n     */\n    protected findByDatabaseEntityLike(entityTarget: Function|string, entity: ObjectLiteral): Subject|undefined {\n        return this.operateSubjects.find(subject => {\n            if (!subject.hasDatabaseEntity)\n                return false;\n\n            return subject.entityTarget === entityTarget && subject.metadata.compareEntities(subject.databaseEntity, entity);\n        });\n    }\n\n    /**\n     * Groups given Subject objects into groups separated by entity targets.\n     */\n    protected groupByEntityTargets(): { target: Function|string, subjects: Subject[] }[] {\n        return this.operateSubjects.reduce((groups, operatedEntity) => {\n            let group = groups.find(group => group.target === operatedEntity.entityTarget);\n            if (!group) {\n                group = { target: operatedEntity.entityTarget, subjects: [] };\n                groups.push(group);\n            }\n            group.subjects.push(operatedEntity);\n            return groups;\n        }, [] as { target: Function|string, subjects: Subject[] }[]);\n    }\n\n}"],"sourceRoot":".."}