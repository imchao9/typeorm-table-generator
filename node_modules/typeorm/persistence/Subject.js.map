{"version":3,"sources":["../../src/persistence/Subject.ts"],"names":[],"mappings":";;AAIA,6DAA0D;AAC1D,2EAAwE;AAkDxE;;;;;;;;;GASG;AACH;IA8FI,4EAA4E;IAC5E,cAAc;IACd,4EAA4E;IAE5E,iBAAY,QAAwB,EAAE,MAAsB,EAAE,cAA8B;QAzE5F;;WAEG;QACM,SAAI,GAAS,IAAI,IAAI,EAAE,CAAC;QAEjC,4EAA4E;QAC5E,oBAAoB;QACpB,4EAA4E;QAE5E;;;WAGG;QACH,kBAAa,GAAY,KAAK,CAAC;QAE/B;;;WAGG;QACH,iBAAY,GAAY,KAAK,CAAC;QAE9B;;;WAGG;QACH,kBAAa,GAAY,KAAK,CAAC;QAE/B;;WAEG;QACH,gBAAW,GAAqB,EAAE,CAAC;QAEnC;;WAEG;QACH,kBAAa,GAAuB,EAAE,CAAC;QAEvC;;;WAGG;QACH,oBAAe,GAAqB,EAAE,CAAC;QAEvC;;WAEG;QACH,oBAAe,GAAqB,EAAE,CAAC;QAEvC;;WAEG;QACH,oBAAe,GAAqB,EAAE,CAAC;QAuBnC,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;QACzB,IAAI,CAAC,cAAc,GAAG,MAAM,CAAC;QAC7B,IAAI,CAAC,eAAe,GAAG,cAAc,CAAC;IAC1C,CAAC;IAUD,sBAAI,2BAAM;QARV,4EAA4E;QAC5E,YAAY;QACZ,4EAA4E;QAE5E;;;WAGG;aACH;YACI,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,cAAc,CAAC;gBACrB,MAAM,IAAI,KAAK,CAAC,sDAAsD,CAAC,CAAC;YAE5E,MAAM,CAAC,IAAI,CAAC,cAAc,CAAC;QAC/B,CAAC;;;OAAA;IAKD,sBAAI,8BAAS;QAHb;;WAEG;aACH;YACI,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC,cAAc,CAAC;QACjC,CAAC;;;OAAA;IAMD,sBAAI,mCAAc;QAJlB;;;WAGG;aACH;YACI,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,eAAe,CAAC;gBACtB,MAAM,IAAI,KAAK,CAAC,mDAAmD,CAAC,CAAC;YAEzE,MAAM,CAAC,IAAI,CAAC,eAAe,CAAC;QAChC,CAAC;QASD;;;;WAIG;aACH,UAAmB,cAA6B;YAC5C,IAAI,CAAC,eAAe,GAAG,cAAc,CAAC;YACtC,IAAI,CAAC,SAAS,EAAE,CAAC;QACrB,CAAC;;;OAjBA;IAKD,sBAAI,sCAAiB;QAHrB;;WAEG;aACH;YACI,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC,eAAe,CAAC;QAClC,CAAC;;;OAAA;IAeD,sBAAI,iCAAY;QAHhB;;WAEG;aACH;YACI,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC;QAChC,CAAC;;;OAAA;IAOD,sBAAI,mCAAc;QALlB;;;;WAIG;aACH;YACI,MAAM,CAAC,IAAI,CAAC,aAAa,IAAI,CAAC,IAAI,CAAC,iBAAiB,CAAC;QACzD,CAAC;;;OAAA;IAOD,sBAAI,kCAAa;QALjB;;;;WAIG;aACH;YACI,MAAM,CAAC,IAAI,CAAC,YAAY,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,MAAM,GAAG,CAAC,IAAI,IAAI,CAAC,aAAa,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;QAC/F,CAAC;;;OAAA;IAKD,sBAAI,uCAAkB;QAHtB;;WAEG;aACH;YACI,MAAM,CAAC,IAAI,CAAC,eAAe,CAAC,MAAM,GAAG,CAAC,CAAC;QAC3C,CAAC;;;OAAA;IAED;;;;;;;;;;;;;;;;;;OAkBG;IAEH,4EAA4E;IAC5E,iBAAiB;IACjB,4EAA4E;IAE5E;;;OAGG;IACH,0BAAQ,GAAR;QAEI,EAAE,CAAC,CAAC,IAAI,CAAC,cAAc,IAAI,IAAI,CAAC,aAAa,CAAC;YAC1C,MAAM,IAAI,KAAK,CAAC,oBAAkB,IAAI,CAAC,QAAQ,CAAC,IAAI,wGAAqG,CAAC,CAAC;QAE/J,EAAE,CAAC,CAAC,IAAI,CAAC,aAAa,IAAI,IAAI,CAAC,aAAa,CAAC;YACzC,MAAM,IAAI,KAAK,CAAC,sBAAmB,IAAI,CAAC,QAAQ,CAAC,IAAI,gDAA4C;gBAC7F,6HAA6H,CAAC,CAAC;QAEvI,EAAE,CAAC,CAAC,IAAI,CAAC,cAAc,IAAI,IAAI,CAAC,aAAa,CAAC;YAC1C,MAAM,IAAI,KAAK,CAAC,qBAAmB,IAAI,CAAC,QAAQ,CAAC,IAAI,yGAAsG,CAAC,CAAC;IAErK,CAAC;IAED;;OAEG;IACH,2BAAS,GAAT;QACI,EAAE,CAAC,CAAC,IAAI,CAAC,SAAS,IAAI,IAAI,CAAC,eAAe,CAAC,CAAC,CAAC;YACzC,IAAI,CAAC,kBAAkB,EAAE,CAAC;YAC1B,IAAI,CAAC,4BAA4B,EAAE,CAAC;QACxC,CAAC;IACL,CAAC;IAED,4EAA4E;IAC5E,oBAAoB;IACpB,4EAA4E;IAE5E;;OAEG;IACO,oCAAkB,GAA5B;QAAA,iBA8DC;QA7DG,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,MAAM,CAAC,UAAA,MAAM;YAErD,8DAA8D;YAC9D,IAAI,WAAW,GAAG,MAAM,CAAC,cAAc,CAAC,KAAI,CAAC,MAAM,CAAC,CAAC;YACrD,IAAI,aAAa,GAAG,MAAM,CAAC,cAAc,CAAC,KAAI,CAAC,cAAc,CAAC,CAAC;YAE/D,sDAAsD;YACtD,EAAE,CAAC,CAAC,WAAW,KAAK,IAAI,IAAI,WAAW,KAAK,SAAS,CAAC,CAAC,CAAC;gBACpD,EAAE,CAAC,CAAC,MAAM,CAAC,IAAI,KAAK,yBAAW,CAAC,IAAI,CAAC,CAAC,CAAC;oBACnC,WAAW,GAAG,iDAAuB,CAAC,qBAAqB,CAAC,WAAW,CAAC,CAAC;gBAE7E,CAAC;gBAAC,IAAI,CAAC,EAAE,CAAC,CAAC,MAAM,CAAC,IAAI,KAAK,yBAAW,CAAC,IAAI,CAAC,CAAC,CAAC;oBAC1C,WAAW,GAAG,iDAAuB,CAAC,qBAAqB,CAAC,WAAW,CAAC,CAAC;gBAE7E,CAAC;gBAAC,IAAI,CAAC,EAAE,CAAC,CAAC,MAAM,CAAC,IAAI,KAAK,yBAAW,CAAC,QAAQ,CAAC,CAAC,CAAC;oBAC9C,oCAAoC;oBACpC,oFAAoF;oBACpF,wFAAwF;oBACxF,WAAW;oBACP,WAAW,GAAG,iDAAuB,CAAC,4BAA4B,CAAC,WAAW,CAAC,CAAC;oBAChF,aAAa,GAAG,iDAAuB,CAAC,4BAA4B,CAAC,aAAa,CAAC,CAAC;oBACxF,IAAI;gBAER,CAAC;gBAAC,IAAI,CAAC,EAAE,CAAC,CAAC,MAAM,CAAC,IAAI,KAAK,yBAAW,CAAC,IAAI,CAAC,CAAC,CAAC;oBAC1C,WAAW,GAAG,IAAI,CAAC,SAAS,CAAC,WAAW,CAAC,CAAC;oBAC1C,EAAE,CAAC,CAAC,aAAa,KAAK,IAAI,IAAI,aAAa,KAAK,SAAS,CAAC;wBACtD,aAAa,GAAG,IAAI,CAAC,SAAS,CAAC,aAAa,CAAC,CAAC;gBAEtD,CAAC;gBAAC,IAAI,CAAC,EAAE,CAAC,CAAC,MAAM,CAAC,IAAI,KAAK,yBAAW,CAAC,YAAY,CAAC,CAAC,CAAC;oBAClD,WAAW,GAAG,iDAAuB,CAAC,mBAAmB,CAAC,WAAW,CAAC,CAAC;oBACvE,aAAa,GAAG,iDAAuB,CAAC,mBAAmB,CAAC,aAAa,CAAC,CAAC;gBAC/E,CAAC;YACL,CAAC;YAED,oDAAoD;YACpD,EAAE,CAAC,CAAC,CAAC,MAAM,CAAC,YAAY,IAAI,KAAI,CAAC,MAAM,CAAC,MAAM,CAAC,YAAY,CAAC,KAAK,SAAS,CAAC;gBACvE,MAAM,CAAC,KAAK,CAAC;YAEjB,uEAAuE;YACvE,EAAE,CAAC,CAAC,MAAM,CAAC,YAAY,IAAI,CAAC,KAAI,CAAC,MAAM,CAAC,MAAM,CAAC,gBAAgB,CAAC,KAAK,SAAS,IAAI,KAAI,CAAC,MAAM,CAAC,MAAM,CAAC,gBAAgB,CAAC,CAAC,MAAM,CAAC,YAAY,CAAC,KAAK,SAAS,CAAC,CAAC;gBACvJ,MAAM,CAAC,KAAK,CAAC;YAEjB,oEAAoE;YACpE,EAAE,CAAC,CAAC,MAAM,CAAC,SAAS;gBAChB,MAAM,CAAC,UAAU;gBACjB,MAAM,CAAC,eAAe;gBACtB,MAAM,CAAC,YAAY;gBACnB,MAAM,CAAC,SAAS;gBAChB,MAAM,CAAC,YAAY;gBACnB,WAAW,KAAK,aAAa,CAAC;gBAC9B,MAAM,CAAC,KAAK,CAAC;YAEjB,2FAA2F;YAC3F,EAAE,CAAC,CAAC,CAAC,MAAM,CAAC,YAAY,IAAI,KAAI,CAAC,QAAQ,CAAC,qBAAqB,CAAC,MAAM,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC;gBACnF,IAAM,QAAQ,GAAG,KAAI,CAAC,QAAQ,CAAC,sBAAsB,CAAC,MAAM,CAAC,YAAY,CAAC,CAAC,CAAC,0BAA0B;gBACtG,EAAE,CAAC,CAAC,KAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,YAAY,CAAC,KAAK,IAAI,IAAI,KAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,YAAY,CAAC,KAAK,SAAS,CAAC;oBAChG,MAAM,CAAC,KAAK,CAAC;YACrB,CAAC;YAED,MAAM,CAAC,IAAI,CAAC;QAChB,CAAC,CAAC,CAAC;IACP,CAAC;IAED;;OAEG;IACO,8CAA4B,GAAtC;QAAA,iBAsCC;QArCG,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC,QAAQ,CAAC,YAAY,CAAC,MAAM,CAAC,UAAA,QAAQ;YAC3D,EAAE,CAAC,CAAC,CAAC,QAAQ,CAAC,WAAW,IAAI,CAAC,CAAC,QAAQ,CAAC,UAAU,IAAI,QAAQ,CAAC,QAAQ,CAAC,CAAC;gBACrE,MAAM,CAAC,KAAK,CAAC;YAEjB,+BAA+B;YAC/B,+DAA+D;YAC/D,4EAA4E;YAC5E,2EAA2E;YAC3E,IAAM,uBAAuB,GACzB,KAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,YAAY,CAAC,YAAY,MAAM;gBAChD,QAAQ,CAAC,qBAAqB,CAAC,mBAAmB,CAAC,KAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,YAAY,CAAC,CAAC;kBACpF,KAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,YAAY,CAAC,CAAC;YAG7C,wGAAwG;YACxG,6CAA6C;YAC7C,wFAAwF;YACxF,iHAAiH;YACjH,+EAA+E;YAC/E,IAAM,kBAAkB,GAAG,KAAI,CAAC,cAAc,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;YAE9D,2HAA2H;YAC3H,6HAA6H;YAC7H,0BAA0B;YAE1B,uDAAuD;YACvD,EAAE,CAAC,CAAC,uBAAuB,KAAK,SAAS,CAAC;gBACtC,MAAM,CAAC,KAAK,CAAC;YAEjB,mDAAmD;YACnD,EAAE,CAAC,CAAC,CAAC,uBAAuB,KAAK,SAAS,IAAI,uBAAuB,KAAK,IAAI,CAAC;gBAC3E,CAAC,kBAAkB,KAAK,SAAS,IAAI,kBAAkB,KAAK,IAAI,CAAC,CAAC;gBAClE,MAAM,CAAC,KAAK,CAAC;YAEjB,2DAA2D;YAC3D,MAAM,CAAC,uBAAuB,KAAK,kBAAkB,CAAC;QAC1D,CAAC,CAAC,CAAC;IACP,CAAC;IAEL,cAAC;AAAD,CAhWA,AAgWC,IAAA;AAhWY,0BAAO","file":"Subject.js","sourcesContent":["import {ObjectLiteral} from \"../common/ObjectLiteral\";\nimport {EntityMetadata} from \"../metadata/EntityMetadata\";\nimport {ColumnMetadata} from \"../metadata/ColumnMetadata\";\nimport {RelationMetadata} from \"../metadata/RelationMetadata\";\nimport {ColumnTypes} from \"../metadata/types/ColumnTypes\";\nimport {DataTransformationUtils} from \"../util/DataTransformationUtils\";\n\n/**\n * Holds information about insert operation into junction table.\n */\nexport interface JunctionInsert {\n\n    /**\n     * Relation of the junction table.\n     */\n    relation: RelationMetadata;\n\n    /**\n     * Entities that needs to be \"bind\" to the subject.\n     */\n    junctionEntities: ObjectLiteral[];\n}\n\n/**\n * Holds information about remove operation from the junction table.\n */\nexport interface JunctionRemove {\n\n    /**\n     * Relation of the junction table.\n     */\n    relation: RelationMetadata;\n\n    /**\n     * Entity ids that needs to be removed from the junction table.\n     */\n    junctionRelationIds: any[];\n}\n\n/**\n * Holds information about relation update in some subject.\n */\nexport interface RelationUpdate {\n\n    /**\n     * Relation that needs to be updated.\n     */\n    relation: RelationMetadata;\n\n    /**\n     * New value that needs to be set into into new relation.\n     */\n    value: any;\n}\n\n/**\n * Subject is a subject of persistence.\n * It holds information about each entity that needs to be persisted:\n * - what entity should be persisted\n * - what is database representation of the persisted entity\n * - what entity metadata of the persisted entity\n * - what is allowed to with persisted entity (insert/update/remove)\n *\n * Having this collection of subjects we can perform database queries.\n */\nexport class Subject {\n\n    // -------------------------------------------------------------------------\n    // Private Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Persist entity (changed entity).\n     */\n    private _persistEntity?: ObjectLiteral;\n\n    /**\n     * Database entity.\n     */\n    private _databaseEntity?: ObjectLiteral;\n\n    // -------------------------------------------------------------------------\n    // Public Readonly Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Entity metadata of the subject entity.\n     */\n    readonly metadata: EntityMetadata;\n\n    /**\n     * Date when this entity is persisted.\n     */\n    readonly date: Date = new Date();\n\n    // -------------------------------------------------------------------------\n    // Public Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Indicates if this subject can be inserted into the database.\n     * This means that this subject either is newly persisted, either can be inserted by cascades.\n     */\n    canBeInserted: boolean = false;\n\n    /**\n     * Indicates if this subject can be updated in the database.\n     * This means that this subject either was persisted, either can be updated by cascades.\n     */\n    canBeUpdated: boolean = false;\n\n    /**\n     * Indicates if this subject MUST be removed from the database.\n     * This means that this subject either was removed, either was removed by cascades.\n     */\n    mustBeRemoved: boolean = false;\n\n    /**\n     * Differentiated columns between persisted and database entities.\n     */\n    diffColumns: ColumnMetadata[] = [];\n\n    /**\n     * Differentiated relations between persisted and database entities.\n     */\n    diffRelations: RelationMetadata[] = [];\n\n    /**\n     * List of relations which need to be unset.\n     * This is used to update relation from inverse side.\n     */\n    relationUpdates: RelationUpdate[] = [];\n\n    /**\n     * Records that needs to be inserted into the junction tables of this subject.\n     */\n    junctionInserts: JunctionInsert[] = [];\n\n    /**\n     * Records that needs to be removed from the junction tables of this subject.\n     */\n    junctionRemoves: JunctionRemove[] = [];\n\n    /**\n     * When subject is newly persisted it may have a generated entity id.\n     * In this case it should be written here.\n     */\n    newlyGeneratedId?: any;\n\n    /**\n     * Generated id of the parent entity. Used in the class-table-inheritance.\n     */\n    parentGeneratedId?: any;\n\n    /**\n     * Used in newly persisted entities which are tree tables.\n     */\n    treeLevel?: number;\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(metadata: EntityMetadata, entity?: ObjectLiteral, databaseEntity?: ObjectLiteral) {\n        this.metadata = metadata;\n        this._persistEntity = entity;\n        this._databaseEntity = databaseEntity;\n    }\n\n    // -------------------------------------------------------------------------\n    // Accessors\n    // -------------------------------------------------------------------------\n\n    /**\n     * Gets entity sent to the persistence (e.g. changed entity).\n     * Throws error if persisted entity was not set.\n     */\n    get entity(): ObjectLiteral {\n        if (!this._persistEntity)\n            throw new Error(`Persistence entity is not set for the given subject.`);\n\n        return this._persistEntity;\n    }\n\n    /**\n     * Checks if subject has a persisted entity.\n     */\n    get hasEntity(): boolean {\n        return !!this._persistEntity;\n    }\n\n    /**\n     * Gets entity from the database (e.g. original entity).\n     * Throws error if database entity was not set.\n     */\n    get databaseEntity(): ObjectLiteral {\n        if (!this._databaseEntity)\n            throw new Error(`Database entity is not set for the given subject.`);\n\n        return this._databaseEntity;\n    }\n\n    /**\n     * Checks if subject has a database entity.\n     */\n    get hasDatabaseEntity(): boolean {\n        return !!this._databaseEntity;\n    }\n\n    /**\n     * Sets entity from the database (e.g. original entity).\n     * Once database entity set it calculates differentiated columns and relations\n     * between persistent entity and database entity.\n     */\n    set databaseEntity(databaseEntity: ObjectLiteral) {\n        this._databaseEntity = databaseEntity;\n        this.recompute();\n    }\n\n    /**\n     * Gets entity target from the entity metadata of this subject.\n     */\n    get entityTarget(): Function|string {\n        return this.metadata.target;\n    }\n\n    /**\n     * Checks if this subject must be inserted into the database.\n     * Subject can be inserted into the database if it is allowed to be inserted (explicitly persisted or by cascades)\n     * and if it does not have database entity set.\n     */\n    get mustBeInserted() {\n        return this.canBeInserted && !this.hasDatabaseEntity;\n    }\n\n    /**\n     * Checks if this subject must be updated into the database.\n     * Subject can be updated in the database if it is allowed to be updated (explicitly persisted or by cascades)\n     * and if it does have differentiated columns or relations.\n     */\n    get mustBeUpdated() {\n        return this.canBeUpdated && (this.diffColumns.length > 0 || this.diffRelations.length > 0);\n    }\n\n    /**\n     * Checks if this subject has relations to be updated.\n     */\n    get hasRelationUpdates(): boolean {\n        return this.relationUpdates.length > 0;\n    }\n\n    /**\n     * Gets id of the persisted entity.\n     * If entity is not set then it returns undefined.\n     * If entity itself has an id then it simply returns it.\n     * If entity does not have an id then it returns newly generated id.\n\n    get getPersistedEntityIdMap(): any|undefined {\n        if (!this.hasEntity)\n            return undefined;\n\n        const entityIdMap = this.metadata.getDatabaseEntityIdMap(this.entity);\n        if (entityIdMap)\n            return entityIdMap;\n\n        if (this.newlyGeneratedId)\n            return this.metadata.createSimpleDatabaseIdMap(this.newlyGeneratedId);\n\n        return undefined;\n    }*/\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Validates this subject for errors.\n     * Subject cannot be at the same time inserted and updated, removed and inserted, removed and updated.\n     */\n    validate() {\n\n        if (this.mustBeInserted && this.mustBeRemoved)\n            throw new Error(`Removed entity ${this.metadata.name} is also scheduled for insert operation. This looks like ORM problem. Please report a github issue.`);\n\n        if (this.mustBeUpdated && this.mustBeRemoved)\n            throw new Error(`Removed entity \"${this.metadata.name}\" is also scheduled for update operation. ` +\n                `Make sure you are not updating and removing same object (note that update or remove may be executed by cascade operations).`);\n\n        if (this.mustBeInserted && this.mustBeUpdated)\n            throw new Error(`Inserted entity ${this.metadata.name} is also scheduled for updated operation. This looks like ORM problem. Please report a github issue.`);\n\n    }\n\n    /**\n     * Performs entity re-computations.\n     */\n    recompute() {\n        if (this.hasEntity && this._databaseEntity) {\n            this.computeDiffColumns();\n            this.computeDiffRelationalColumns();\n        }\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Differentiate columns from the updated entity and entity stored in the database.\n     */\n    protected computeDiffColumns(): void {\n        this.diffColumns = this.metadata.allColumns.filter(column => {\n\n            // prepare both entity and database values to make comparision\n            let entityValue = column.getEntityValue(this.entity);\n            let databaseValue = column.getEntityValue(this.databaseEntity);\n\n            // normalize special values to make proper comparision\n            if (entityValue !== null && entityValue !== undefined) {\n                if (column.type === ColumnTypes.DATE) {\n                    entityValue = DataTransformationUtils.mixedDateToDateString(entityValue);\n\n                } else if (column.type === ColumnTypes.TIME) {\n                    entityValue = DataTransformationUtils.mixedDateToTimeString(entityValue);\n\n                } else if (column.type === ColumnTypes.DATETIME) {\n                    // if (column.loadInLocalTimezone) {\n                    //     entityValue = DataTransformationUtils.mixedDateToDatetimeString(entityValue);\n                    //     databaseValue = DataTransformationUtils.mixedDateToDatetimeString(databaseValue);\n                    // } else {\n                        entityValue = DataTransformationUtils.mixedDateToUtcDatetimeString(entityValue);\n                        databaseValue = DataTransformationUtils.mixedDateToUtcDatetimeString(databaseValue);\n                    // }\n\n                } else if (column.type === ColumnTypes.JSON) {\n                    entityValue = JSON.stringify(entityValue);\n                    if (databaseValue !== null && databaseValue !== undefined)\n                        databaseValue = JSON.stringify(databaseValue);\n\n                } else if (column.type === ColumnTypes.SIMPLE_ARRAY) {\n                    entityValue = DataTransformationUtils.simpleArrayToString(entityValue);\n                    databaseValue = DataTransformationUtils.simpleArrayToString(databaseValue);\n                }\n            }\n\n            // if value is not defined then no need to update it\n            if (!column.isInEmbedded && this.entity[column.propertyName] === undefined)\n                return false;\n\n            // if value is in embedded and is not defined then no need to update it\n            if (column.isInEmbedded && (this.entity[column.embeddedProperty] === undefined || this.entity[column.embeddedProperty][column.propertyName] === undefined))\n                return false;\n\n            // if its a special column or value is not changed - then do nothing\n            if (column.isVirtual ||\n                column.isParentId ||\n                column.isDiscriminator ||\n                column.isUpdateDate ||\n                column.isVersion ||\n                column.isCreateDate ||\n                entityValue === databaseValue)\n                return false;\n\n            // filter out \"relational columns\" only in the case if there is a relation object in entity\n            if (!column.isInEmbedded && this.metadata.hasRelationWithDbName(column.propertyName)) {\n                const relation = this.metadata.findRelationWithDbName(column.propertyName); // todo: why with dbName ?\n                if (this.entity[relation.propertyName] !== null && this.entity[relation.propertyName] !== undefined)\n                    return false;\n            }\n\n            return true;\n        });\n    }\n\n    /**\n     * Difference columns of the owning one-to-one and many-to-one columns.\n     */\n    protected computeDiffRelationalColumns(/*todo: updatesByRelations: UpdateByRelationOperation[], */): void {\n        this.diffRelations = this.metadata.allRelations.filter(relation => {\n            if (!relation.isManyToOne && !(relation.isOneToOne && relation.isOwning))\n                return false;\n\n            // here we cover two scenarios:\n            // 1. related entity can be another entity which is natural way\n            // 2. related entity can be entity id which is hacked way of updating entity\n            // todo: what to do if there is a column with relationId? (cover this too?)\n            const updatedEntityRelationId: any =\n                this.entity[relation.propertyName] instanceof Object ?\n                    relation.inverseEntityMetadata.getEntityIdMixedMap(this.entity[relation.propertyName])\n                    : this.entity[relation.propertyName];\n\n\n            // here because we have enabled RELATION_ID_VALUES option in the QueryBuilder when we loaded db entities\n            // we have in the dbSubject only relationIds.\n            // this allows us to compare relation id in the updated subject with id in the database.\n            // note that we used relation.name instead of relation.propertyName because query builder with RELATION_ID_VALUES\n            // returns values in the relation.name column, not relation.propertyName column\n            const dbEntityRelationId = this.databaseEntity[relation.name];\n\n            // todo: try to find if there is update by relation operation - we dont need to generate update relation operation for this\n            // todo: if (updatesByRelations.find(operation => operation.targetEntity === this && operation.updatedRelation === relation))\n            // todo:     return false;\n\n            // we don't perform operation over undefined properties\n            if (updatedEntityRelationId === undefined)\n                return false;\n\n            // if both are empty totally no need to do anything\n            if ((updatedEntityRelationId === undefined || updatedEntityRelationId === null) &&\n                (dbEntityRelationId === undefined || dbEntityRelationId === null))\n                return false;\n\n            // if relation ids aren't equal then we need to update them\n            return updatedEntityRelationId !== dbEntityRelationId;\n        });\n    }\n\n}"],"sourceRoot":".."}