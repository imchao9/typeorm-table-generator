{"version":3,"sources":["../../src/metadata/RelationMetadata.ts"],"names":[],"mappings":"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","file":"RelationMetadata.js","sourcesContent":["import {RelationTypes, RelationType} from \"./types/RelationTypes\";\nimport {EntityMetadata} from \"./EntityMetadata\";\nimport {OnDeleteType} from \"./ForeignKeyMetadata\";\nimport {JoinTableMetadata} from \"./JoinTableMetadata\";\nimport {JoinColumnMetadata} from \"./JoinColumnMetadata\";\nimport {RelationMetadataArgs} from \"../metadata-args/RelationMetadataArgs\";\nimport {ColumnMetadata} from \"./ColumnMetadata\";\nimport {ObjectLiteral} from \"../common/ObjectLiteral\";\n\n/**\n * Function that returns a type of the field. Returned value must be a class used on the relation.\n */\nexport type RelationTypeInFunction = ((type?: any) => Function)|Function|string; // todo: |string ?\n\n\n/**\n * Contains the name of the property of the object, or the function that returns this name.\n */\nexport type PropertyTypeInFunction<T> = string|((t: T) => string|any);\n\n\n/**\n * Contains all information about some entity's relation.\n */\nexport class RelationMetadata {\n\n    // ---------------------------------------------------------------------\n    // Public Properties\n    // ---------------------------------------------------------------------\n\n    /**\n     * Its own entity metadata.\n     */\n    entityMetadata: EntityMetadata;\n\n    /**\n     * Related entity metadata.\n     */\n    inverseEntityMetadata: EntityMetadata;\n\n    /**\n     * Junction entity metadata.\n     */\n    junctionEntityMetadata: EntityMetadata;\n\n    /**\n     * Join table metadata.\n     */\n    joinTable: JoinTableMetadata;\n\n    /**\n     * Join column metadata.\n     */\n    joinColumn: JoinColumnMetadata;\n\n    /**\n     * The name of the field that will contain id or ids of this relation. This is used in the case if user\n     * wants to save relation without having to load related object, or in the cases if user wants to have id\n     * of the object it relates with, but don't want to load that object because of it. Also its used in the\n     * cases when user wants to add / remove / load in the many-to-many junction tables.\n     */\n    idField: string|undefined;\n\n    /**\n     * The name of the field that will contain count of the rows of the relation.\n     */\n    countField: string|undefined;\n\n    // ---------------------------------------------------------------------\n    // Readonly Properties\n    // ---------------------------------------------------------------------\n\n    /**\n     * Target class to which metadata is applied.\n     */\n    readonly target: Function|string;\n\n    /**\n     * Target's property name to which this metadata is applied.\n     */\n    readonly propertyName: string;\n\n    /**\n     * Indicates if this is a parent (can be only many-to-one relation) relation in the tree tables.\n     */\n    readonly isTreeParent: boolean = false;\n\n    /**\n     * Indicates if this is a children (can be only one-to-many relation) relation in the tree tables.\n     */\n    readonly isTreeChildren: boolean = false;\n\n    /**\n     * Relation type.\n     */\n    readonly relationType: RelationType;\n\n    /**\n     * Indicates if this relation will be a primary key.\n     * Can be used only for many-to-one and owner one-to-one relations.\n     */\n    readonly isPrimary: boolean;\n\n    /**\n     * Indicates if this relation will be lazily loaded.\n     */\n    readonly isLazy: boolean;\n\n    /**\n     * If set to true then it means that related object can be allowed to be inserted to the db.\n     */\n    readonly isCascadeInsert: boolean;\n\n    /**\n     * If set to true then it means that related object can be allowed to be updated in the db.\n     */\n    readonly isCascadeUpdate: boolean;\n\n    /**\n     * If set to true then it means that related object can be allowed to be remove from the db.\n     */\n    readonly isCascadeRemove: boolean;\n\n    /**\n     * Indicates if relation column value can be nullable or not.\n     */\n    readonly isNullable: boolean = true;\n\n    /**\n     * What to do with a relation on deletion of the row containing a foreign key.\n     */\n    readonly onDelete: OnDeleteType;\n\n    /**\n     * The real reflected property type.\n     */\n    // readonly propertyType: any;\n\n    // ---------------------------------------------------------------------\n    // Private Properties\n    // ---------------------------------------------------------------------\n\n    /**\n     * The type of the field.\n     */\n    private _type: RelationTypeInFunction;\n\n    /**\n     * Inverse side of the relation.\n     */\n    private _inverseSideProperty: PropertyTypeInFunction<any>;\n\n    // ---------------------------------------------------------------------\n    // Constructor\n    // ---------------------------------------------------------------------\n\n    constructor(args: RelationMetadataArgs) {\n        this.target = args.target;\n        this.propertyName = args.propertyName;\n        this.relationType = args.relationType;\n\n        if (args.inverseSideProperty)\n            this._inverseSideProperty = args.inverseSideProperty;\n        // if (args.propertyType)\n        //     this.propertyType = args.propertyType;\n        if (args.isLazy !== undefined)\n            this.isLazy = args.isLazy;\n        if (args.options.cascadeInsert || args.options.cascadeAll)\n            this.isCascadeInsert = true;\n        if (args.options.cascadeUpdate || args.options.cascadeAll)\n            this.isCascadeUpdate = true;\n        if (args.options.cascadeRemove || args.options.cascadeAll)\n            this.isCascadeRemove = true;\n        if (args.options.nullable !== undefined)\n            this.isNullable = args.options.nullable;\n        if (args.options.onDelete)\n            this.onDelete = args.options.onDelete;\n        if (args.options.primary !== undefined)\n            this.isPrimary = args.options.primary;\n        if (args.isTreeParent)\n            this.isTreeParent = true;\n        if (args.isTreeChildren)\n            this.isTreeChildren = true;\n\n        if (!this._type)\n            this._type = args.type;\n    }\n\n    // ---------------------------------------------------------------------\n    // Accessors\n    // ---------------------------------------------------------------------\n\n    /**\n     * Gets relation's entity target.\n     * Original target returns target of the class where relation is.\n     * This class can be an abstract class, but relation even is from that class,\n     * but its more related to a specific entity. That's why we need this field.\n     */\n    get entityTarget(): Function|string {\n        return this.entityMetadata.target;\n    }\n\n    /**\n     * Gets the name of column in the database.\n     * //Cannot be used with many-to-many relations since they don't have a column in the database.\n     * //Also only owning sides of the relations have this property.\n     */\n    get name(): string {\n        // if (!this.isOwning || this.isManyToMany)\n\n        if (this.isOwning) {\n            if (this.joinTable) {\n                return this.joinTable.joinColumnName;\n            } else if (this.joinColumn) {\n                return this.joinColumn.name;\n            }\n\n        } else if (this.hasInverseSide) {\n            if (this.inverseRelation.joinTable) {\n                return this.inverseRelation.joinTable.inverseJoinColumnName;\n            } else if (this.inverseRelation.joinColumn && this.inverseRelation.joinColumn.referencedColumn) {\n                return this.inverseRelation.joinColumn.referencedColumn.name;\n            }\n        }\n\n        throw new Error(`Relation name cannot be retrieved.`);\n    }\n\n    /**\n     * Gets the name of column to which this relation is referenced.\n     * //Cannot be used with many-to-many relations since all referenced are in the junction table.\n     * //Also only owning sides of the relations have this property.\n     */\n    get referencedColumnName(): string {\n        // if (!this.isOwning)\n        //     throw new Error(`Only owning side of the relations can have information about referenced column names.`);\n\n        // for many-to-one and owner one-to-one relations we get referenced column from join column\n        /*if (this.joinColumn && this.joinColumn.referencedColumn && this.joinColumn.referencedColumn.name)\n            return this.joinColumn.referencedColumn.name;\n\n        // for many-to-many relation we give referenced column depend of owner side\n        if (this.joinTable) { // need to check if this algorithm works correctly\n            if (this.isOwning) {\n                return this.joinTable.referencedColumn.name;\n            } else {\n                return this.joinTable.inverseReferencedColumn.name;\n            }\n        }*/\n\n        if (this.isOwning) {\n            if (this.joinTable) {\n                return this.joinTable.referencedColumn.name;\n\n            } else if (this.joinColumn) {\n                return this.joinColumn.referencedColumn.name;\n            }\n\n        } else if (this.hasInverseSide) {\n            if (this.inverseRelation.joinTable) {\n                return this.inverseRelation.joinTable.inverseReferencedColumn.name;\n            } else if (this.inverseRelation.joinColumn) {\n                return this.inverseRelation.joinColumn.name; // todo: didn't get this logic here\n            }\n        }\n\n        // this should not be possible, but anyway throw error\n        throw new Error(`Cannot get referenced column name of the relation ${this.entityMetadata.name}#${this.name}`);\n    }\n\n    /**\n     * Gets the column to which this relation is referenced.\n     */\n    get referencedColumn(): ColumnMetadata {\n        if (this.isOwning) {\n            if (this.joinTable) {\n                return this.joinTable.referencedColumn;\n\n            } else if (this.joinColumn) {\n                return this.joinColumn.referencedColumn;\n            }\n\n        } else if (this.hasInverseSide) {\n            if (this.inverseRelation.joinTable) {\n                return this.inverseRelation.joinTable.inverseReferencedColumn;\n            } else if (this.inverseRelation.joinColumn) {\n                return this.inverseRelation.joinColumn.referencedColumn;\n            }\n        }\n\n        // this should not be possible, but anyway throw error\n        throw new Error(`Cannot get referenced column of the relation ${this.entityMetadata.name}#${this.name}`);\n    }\n\n    /**\n     * Gets the property's type to which this relation is applied.\n     */\n    get type(): Function|string { // todo: when this can be a string?\n        return this._type instanceof Function ? (this._type as () => any)() : this._type;\n    }\n\n    /**\n     * Indicates if this side is an owner of this relation.\n     */\n    get isOwning() {\n        return  !!(this.isManyToOne ||\n                (this.isManyToMany && this.joinTable) ||\n                (this.isOneToOne && this.joinColumn));\n    }\n\n    /**\n     * Checks if this relation's type is \"one-to-one\".\n     */\n    get isOneToOne(): boolean {\n        return this.relationType === RelationTypes.ONE_TO_ONE;\n    }\n\n    /**\n     * Checks if this relation is owner side of the \"one-to-one\" relation.\n     * Owner side means this side of relation has a join column in the table.\n     */\n    get isOneToOneOwner(): boolean {\n        return this.isOneToOne && this.isOwning;\n    }\n\n    /**\n     * Checks if this relation is NOT owner side of the \"one-to-one\" relation.\n     * NOT owner side means this side of relation does not have a join column in the table.\n     */\n    get isOneToOneNotOwner(): boolean {\n        return this.isOneToOne && !this.isOwning;\n    }\n\n    /**\n     * Checks if this relation's type is \"one-to-many\".\n     */\n    get isOneToMany(): boolean {\n        return this.relationType === RelationTypes.ONE_TO_MANY;\n    }\n\n    /**\n     * Checks if this relation's type is \"many-to-one\".\n     */\n    get isManyToOne(): boolean {\n        return this.relationType === RelationTypes.MANY_TO_ONE;\n    }\n\n    /**\n     * Checks if this relation's type is \"many-to-many\".\n     */\n    get isManyToMany(): boolean {\n        return this.relationType === RelationTypes.MANY_TO_MANY;\n    }\n\n    /**\n     * Checks if this relation's type is \"many-to-many\", and is owner side of the relationship.\n     * Owner side means this side of relation has a join table.\n     */\n    get isManyToManyOwner(): boolean {\n        return this.isManyToMany && this.isOwning;\n    }\n\n    /**\n     * Checks if this relation's type is \"many-to-many\", and is NOT owner side of the relationship.\n     * Not owner side means this side of relation does not have a join table.\n     */\n    get isManyToManyNotOwner(): boolean {\n        return this.isManyToMany && !this.isOwning;\n    }\n\n    /**\n     * Checks if inverse side is specified by a relation.\n     */\n    get hasInverseSide(): boolean {\n        return this.inverseEntityMetadata && this.inverseEntityMetadata.hasRelationWithPropertyName(this.inverseSideProperty);\n    }\n\n    /**\n     * Gets the property name of the inverse side of the relation.\n     */\n    get inverseSideProperty(): string { // todo: should be called inverseSidePropertyName ?\n\n        if (this._inverseSideProperty) {\n            return this.computeInverseSide(this._inverseSideProperty);\n\n        } else if (this.isTreeParent && this.entityMetadata.hasTreeChildrenRelation) {\n            return this.entityMetadata.treeChildrenRelation.propertyName;\n\n        } else if (this.isTreeChildren && this.entityMetadata.hasTreeParentRelation) {\n            return this.entityMetadata.treeParentRelation.propertyName;\n\n        }\n\n        return \"\";\n    }\n\n    /**\n     * Gets the relation metadata of the inverse side of this relation.\n     */\n    get inverseRelation(): RelationMetadata {\n        const relation = this.inverseEntityMetadata.findRelationWithPropertyName(this.inverseSideProperty);\n        if (!relation)\n            throw new Error(`Inverse side was not found in the relation ${this.entityMetadata.name}#${this.inverseSideProperty}`);\n\n        return relation;\n    }\n\n    // ---------------------------------------------------------------------\n    // Public Methods\n    // ---------------------------------------------------------------------\n\n    /**\n     * Gets given entity's relation's value.\n     * Using of this method helps to access value of the lazy loaded relation.\n     */\n    getEntityValue(entity: ObjectLiteral): any {\n        return this.isLazy ? entity[\"__\" + this.propertyName + \"__\"] : entity[this.propertyName];\n    }\n\n    /**\n     * Checks if given entity has a value in a relation.\n     */\n    hasEntityValue(entity: ObjectLiteral): boolean {\n        return this.isLazy ? entity[\"__\" + this.propertyName + \"__\"] : entity[this.propertyName];\n    }\n\n    /**\n     * todo: lazy relations are not supported here? implement logic?\n     *\n     * examples:\n     *\n     * - isOneToOneNotOwner or isOneToMany:\n     *  Post has a Category.\n     *  Post is owner side.\n     *  Category is inverse side.\n     *  Post.category is mapped to Category.id\n     *\n     *  if from Post relation we are passing Category here,\n     *  it should return a post.category\n     */\n    getOwnEntityRelationId(ownEntity: ObjectLiteral): any {\n        if (this.isManyToManyOwner) {\n            return ownEntity[this.joinTable.referencedColumn.propertyName];\n\n        } else if (this.isManyToManyNotOwner) {\n            return ownEntity[this.inverseRelation.joinTable.inverseReferencedColumn.propertyName];\n\n        } else if (this.isOneToOneOwner || this.isManyToOne) {\n            return ownEntity[this.joinColumn.propertyName];\n\n        } else if (this.isOneToOneNotOwner || this.isOneToMany) {\n            return ownEntity[this.inverseRelation.joinColumn.referencedColumn.propertyName];\n        }\n    }\n\n    /**\n     *\n     * examples:\n     *\n     * - isOneToOneNotOwner or isOneToMany:\n     *  Post has a Category.\n     *  Post is owner side.\n     *  Category is inverse side.\n     *  Post.category is mapped to Category.id\n     *\n     *  if from Post relation we are passing Category here,\n     *  it should return a category.id\n     *\n     *  @deprecated Looks like this method does not make sence and does same as getOwnEntityRelationId ?\n     */\n    getInverseEntityRelationId(inverseEntity: ObjectLiteral): any {\n        if (this.isManyToManyOwner) {\n            return inverseEntity[this.joinTable.inverseReferencedColumn.propertyName];\n\n        } else if (this.isManyToManyNotOwner) {\n            return inverseEntity[this.inverseRelation.joinTable.referencedColumn.propertyName];\n\n        } else if (this.isOneToOneOwner || this.isManyToOne) {\n            return inverseEntity[this.joinColumn.referencedColumn.propertyName];\n\n        } else if (this.isOneToOneNotOwner || this.isOneToMany) {\n            return inverseEntity[this.inverseRelation.joinColumn.propertyName];\n        }\n    }\n\n    // ---------------------------------------------------------------------\n    // Private Methods\n    // ---------------------------------------------------------------------\n\n    /**\n     * Inverse side set in the relation can be either string - property name of the column on inverse side,\n     * either can be a function that accepts a map of properties with the object and returns one of them.\n     * Second approach is used to achieve type-safety.\n     */\n    private computeInverseSide(inverseSide: PropertyTypeInFunction<any>): string {\n        const ownerEntityPropertiesMap = this.inverseEntityMetadata.createPropertiesMap();\n        if (typeof inverseSide === \"function\")\n            return (<Function> inverseSide)(ownerEntityPropertiesMap);\n        if (typeof inverseSide === \"string\")\n            return <string> inverseSide;\n\n        // throw new Error(\"Cannot compute inverse side of the relation\");\n        return \"\";\n    }\n}"],"sourceRoot":".."}