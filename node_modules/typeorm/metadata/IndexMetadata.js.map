{"version":3,"sources":["../../src/metadata/IndexMetadata.ts"],"names":[],"mappings":";;AAGA;;GAEG;AACH;IAuCI,wEAAwE;IACxE,cAAc;IACd,wEAAwE;IAExE,uBAAY,IAAuB;QAC/B,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC;QAC1B,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,OAAO,CAAC;QAC7B,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,IAAI,CAAC;QACvB,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,MAAM,CAAC;IAChC,CAAC;IASD,sBAAI,+BAAI;QAPR,wEAAwE;QACxE,YAAY;QACZ,wEAAwE;QAExE;;WAEG;aACH;YACI,MAAM,CAAC,IAAI,CAAC,cAAc,CAAC,cAAc,CAAC,SAAS,CAAC,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,cAAc,CAAC,KAAK,CAAC,IAAI,EAAE,IAAI,CAAC,OAAO,CAAC,CAAC;QAClH,CAAC;;;OAAA;IAKD,sBAAI,oCAAS;QAHb;;WAEG;aACH;YACI,MAAM,CAAC,IAAI,CAAC,cAAc,CAAC,KAAK,CAAC,IAAI,CAAC;QAC1C,CAAC;;;OAAA;IAKD,sBAAI,kCAAO;QAHX;;WAEG;aACH;YAAA,iBAoBC;YAlBG,8DAA8D;YAC9D,IAAI,mBAAmB,GAAa,EAAE,CAAC;YACvC,EAAE,CAAC,CAAC,IAAI,CAAC,QAAQ,YAAY,KAAK,CAAC,CAAC,CAAC;gBACjC,mBAAmB,GAAG,IAAI,CAAC,QAAQ,CAAC;YACxC,CAAC;YAAC,IAAI,CAAC,CAAC;gBACJ,2GAA2G;gBAC3G,IAAM,aAAa,GAAG,IAAI,CAAC,cAAc,CAAC,mBAAmB,EAAE,CAAC;gBAChE,mBAAmB,GAAG,IAAI,CAAC,QAAQ,CAAC,aAAa,CAAC,CAAC,GAAG,CAAC,UAAC,CAAM,IAAK,OAAA,MAAM,CAAC,CAAC,CAAC,EAAT,CAAS,CAAC,CAAC;YAClF,CAAC;YAED,IAAM,OAAO,GAAG,IAAI,CAAC,cAAc,CAAC,OAAO,CAAC,MAAM,CAAC,UAAA,MAAM,IAAI,OAAA,mBAAmB,CAAC,OAAO,CAAC,MAAM,CAAC,YAAY,CAAC,KAAK,CAAC,CAAC,EAAvD,CAAuD,CAAC,CAAC;YACtH,IAAM,kBAAkB,GAAG,mBAAmB,CAAC,MAAM,CAAC,UAAA,kBAAkB,IAAI,OAAA,CAAC,KAAI,CAAC,cAAc,CAAC,OAAO,CAAC,IAAI,CAAC,UAAA,MAAM,IAAI,OAAA,MAAM,CAAC,YAAY,KAAK,kBAAkB,EAA1C,CAA0C,CAAC,EAAvF,CAAuF,CAAC,CAAC;YACrK,EAAE,CAAC,CAAC,kBAAkB,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;gBAChC,4CAA4C;gBAC5C,MAAM,IAAI,KAAK,CAAC,YAAS,IAAI,CAAC,KAAK,GAAG,IAAI,GAAG,IAAI,CAAC,KAAK,GAAG,KAAK,GAAG,EAAE,uDAAmD,GAAG,kBAAkB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;YAC7J,CAAC;YAED,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,UAAA,MAAM,IAAI,OAAA,MAAM,CAAC,IAAI,EAAX,CAAW,CAAC,CAAC;QAC9C,CAAC;;;OAAA;IAEL,oBAAC;AAAD,CA7FA,AA6FC,IAAA;AA7FY,sCAAa","file":"IndexMetadata.js","sourcesContent":["import {EntityMetadata} from \"./EntityMetadata\";\nimport {IndexMetadataArgs} from \"../metadata-args/IndexMetadataArgs\";\n\n/**\n * Index metadata contains all information about table's index.\n */\nexport class IndexMetadata {\n\n    // ---------------------------------------------------------------------\n    // Public Properties\n    // ---------------------------------------------------------------------\n\n    /**\n     * Entity metadata of the class to which this index is applied.\n     */\n    entityMetadata: EntityMetadata;\n\n    // ---------------------------------------------------------------------\n    // Readonly Properties\n    // ---------------------------------------------------------------------\n\n    /**\n     * Indicates if this index must be unique.\n     */\n    readonly isUnique: boolean;\n\n    /**\n     * Target class to which metadata is applied.\n     */\n    readonly target?: Function|string;\n\n    // ---------------------------------------------------------------------\n    // Private Properties\n    // ---------------------------------------------------------------------\n\n    /**\n     * Composite index name.\n     */\n    private readonly _name: string|undefined;\n\n    /**\n     * Columns combination to be used as index.\n     */\n    private readonly _columns: ((object: any) => any[])|string[];\n\n    // ---------------------------------------------------------------------\n    // Constructor\n    // ---------------------------------------------------------------------\n\n    constructor(args: IndexMetadataArgs) {\n        this.target = args.target;\n        this._columns = args.columns;\n        this._name = args.name;\n        this.isUnique = args.unique;\n    }\n\n    // ---------------------------------------------------------------------\n    // Accessors\n    // ---------------------------------------------------------------------\n\n    /**\n     * Gets index's name.\n     */\n    get name() {\n        return this.entityMetadata.namingStrategy.indexName(this._name, this.entityMetadata.table.name, this.columns);\n    }\n\n    /**\n     * Gets the table name on which index is applied.\n     */\n    get tableName() {\n        return this.entityMetadata.table.name;\n    }\n\n    /**\n     * Gets the column names which are in this index.\n     */\n    get columns(): string[] {\n\n        // if columns already an array of string then simply return it\n        let columnPropertyNames: string[] = [];\n        if (this._columns instanceof Array) {\n            columnPropertyNames = this._columns;\n        } else {\n            // if columns is a function that returns array of field names then execute it and get columns names from it\n            const propertiesMap = this.entityMetadata.createPropertiesMap();\n            columnPropertyNames = this._columns(propertiesMap).map((i: any) => String(i));\n        }\n\n        const columns = this.entityMetadata.columns.filter(column => columnPropertyNames.indexOf(column.propertyName) !== -1);\n        const missingColumnNames = columnPropertyNames.filter(columnPropertyName => !this.entityMetadata.columns.find(column => column.propertyName === columnPropertyName));\n        if (missingColumnNames.length > 0) {\n            // console.log(this.entityMetadata.columns);\n            throw new Error(`Index ${this._name ? \"\\\"\" + this._name + \"\\\" \" : \"\"}contains columns that are missing in the entity: ` + missingColumnNames.join(\", \"));\n        }\n\n        return columns.map(column => column.name);\n    }\n\n}"],"sourceRoot":".."}