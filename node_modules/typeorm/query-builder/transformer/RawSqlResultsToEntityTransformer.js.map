{"version":3,"sources":["../../src/query-builder/transformer/RawSqlResultsToEntityTransformer.ts"],"names":[],"mappings":"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","file":"RawSqlResultsToEntityTransformer.js","sourcesContent":["import {AliasMap} from \"../alias/AliasMap\";\nimport {Alias} from \"../alias/Alias\";\nimport {EntityMetadata} from \"../../metadata/EntityMetadata\";\nimport {OrmUtils} from \"../../util/OrmUtils\";\nimport {Driver} from \"../../driver/Driver\";\nimport {JoinMapping, RelationCountMeta} from \"../QueryBuilder\";\n\n/**\n * Transforms raw sql results returned from the database into entity object.\n * Entity is constructed based on its entity metadata.\n */\nexport class RawSqlResultsToEntityTransformer {\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(private driver: Driver,\n                private aliasMap: AliasMap,\n                private joinMappings: JoinMapping[],\n                private relationCountMetas: RelationCountMeta[],\n                private enableRelationIdValues: boolean) {\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    transform(rawSqlResults: any[]): any[] {\n        // console.log(\"rawSqlResults: \", rawSqlResults);\n        return this.groupAndTransform(rawSqlResults, this.aliasMap.mainAlias);\n    }\n\n    // -------------------------------------------------------------------------\n    // Private Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Since db returns a duplicated rows of the data where accuracies of the same object can be duplicated\n     * we need to group our result and we must have some unique id (primary key in our case)\n     */\n    private groupAndTransform(rawSqlResults: any[], alias: Alias) {\n\n        const metadata = this.aliasMap.getEntityMetadataByAlias(alias);\n        if (!metadata)\n            throw new Error(\"Cannot get entity metadata for the given alias \" + alias.name);\n\n        const groupedResults = OrmUtils.groupBy(rawSqlResults, result => {\n            if (!metadata) return;\n            return metadata.primaryColumnsWithParentIdColumns.map(column => result[alias.name + \"_\" + column.name]).join(\"_\"); // todo: check it\n        });\n        // console.log(\"groupedResults: \", groupedResults);\n        return groupedResults\n            .map(group => {\n                if (!metadata) return;\n                return this.transformIntoSingleResult(group.items, alias, metadata);\n            })\n            .filter(res => !!res);\n    }\n\n\n    /**\n     * Transforms set of data results into single entity.\n     */\n    private transformIntoSingleResult(rawSqlResults: any[], alias: Alias, metadata: EntityMetadata) {\n        const entity: any = metadata.create();\n        let hasData = false;\n\n        // console.log(rawSqlResults);\n\n        // add special columns that contains relation ids\n        if (this.enableRelationIdValues) {\n            metadata.columns\n                .filter(column => !!column.relationMetadata)\n                .forEach(column => {\n                    const valueInObject = rawSqlResults[0][alias.name + \"_\" + column.name]; // we use zero index since its grouped data\n                    if (valueInObject !== undefined && valueInObject !== null && column.propertyName) {\n                        const value = this.driver.prepareHydratedValue(valueInObject, column);\n                        entity[column.propertyName] = value;\n                        hasData = true;\n                    }\n                });\n        } // */\n\n        this.joinMappings\n            .filter(joinMapping => joinMapping.parentName === alias.name && !joinMapping.alias.parentAliasName && joinMapping.alias.target)\n            .map(joinMapping => {\n                const relatedEntities = this.groupAndTransform(rawSqlResults, joinMapping.alias);\n                const isResultArray = joinMapping.isMany;\n                const result = !isResultArray ? relatedEntities[0] : relatedEntities;\n\n                if (result && (!isResultArray || result.length > 0)) {\n                    entity[joinMapping.propertyName] = result;\n                    hasData = true;\n                }\n            });\n\n        // get value from columns selections and put them into object\n        metadata.columns.forEach(column => {\n            const columnName = column.name;\n            const valueInObject = rawSqlResults[0][alias.name + \"_\" + columnName]; // we use zero index since its grouped data\n            if (valueInObject !== undefined && valueInObject !== null && column.propertyName && !column.isVirtual && !column.isParentId && !column.isDiscriminator) {\n                const value = this.driver.prepareHydratedValue(valueInObject, column);\n\n                if (column.isInEmbedded) {\n                    if (!entity[column.embeddedProperty])\n                        entity[column.embeddedProperty] = column.embeddedMetadata.create();\n\n                    entity[column.embeddedProperty][column.propertyName] = value;\n                } else {\n                    entity[column.propertyName] = value;\n                }\n                hasData = true;\n            }\n        });\n\n        // add parent tables metadata\n        // console.log(rawSqlResults);\n        if (metadata.parentEntityMetadata) {\n            metadata.parentEntityMetadata.columns.forEach(column => {\n                const columnName = column.name;\n                const valueInObject = rawSqlResults[0][\"parentIdColumn_\" + metadata.parentEntityMetadata.table.name + \"_\" + columnName]; // we use zero index since its grouped data\n                if (valueInObject !== undefined && valueInObject !== null && column.propertyName && !column.isVirtual && !column.isParentId && !column.isDiscriminator) {\n                    const value = this.driver.prepareHydratedValue(valueInObject, column);\n\n                    if (column.isInEmbedded) {\n                        if (!entity[column.embeddedProperty])\n                            entity[column.embeddedProperty] = column.embeddedMetadata.create();\n\n                        entity[column.embeddedProperty][column.propertyName] = value;\n                    } else {\n                        entity[column.propertyName] = value;\n                    }\n                    hasData = true;\n                }\n            });\n        }\n\n        // if relation is loaded then go into it recursively and transform its values too\n        metadata.relations.forEach(relation => {\n            const relationAlias = this.aliasMap.findAliasByParent(alias.name, relation.propertyName);\n            if (relationAlias) {\n                const joinMapping = this.joinMappings.find(joinMapping => joinMapping.type === \"join\" && joinMapping.alias === relationAlias);\n                const relatedEntities = this.groupAndTransform(rawSqlResults, relationAlias);\n                const isResultArray = relation.isManyToMany || relation.isOneToMany;\n                const result = !isResultArray ? relatedEntities[0] : relatedEntities;\n\n                if (result) {\n                    let propertyName = relation.propertyName;\n                    if (joinMapping) {\n                        propertyName = joinMapping.propertyName;\n                    }\n\n                    if (relation.isLazy) {\n                        entity[\"__\" + propertyName + \"__\"] = result;\n                    } else {\n                        entity[propertyName] = result;\n                    }\n\n                    if (!isResultArray || result.length > 0)\n                        hasData = true;\n                }\n            }\n\n            // if relation has id field then relation id/ids to that field.\n            if (relation.isManyToMany) {\n                if (relationAlias) {\n                    const ids: any[] = [];\n                    const joinMapping = this.joinMappings.find(joinMapping => joinMapping.type === \"relationId\" && joinMapping.alias === relationAlias);\n\n                    if (relation.idField || joinMapping) {\n                        const propertyName = joinMapping ? joinMapping.propertyName : relation.idField as string;\n                        const junctionMetadata = relation.junctionEntityMetadata;\n                        const columnName = relation.isOwning ? junctionMetadata.columns[1].name : junctionMetadata.columns[0].name;\n\n                        rawSqlResults.forEach(results => {\n                            if (relationAlias) {\n                                const resultsKey = relationAlias.name + \"_\" + columnName;\n                                const value = this.driver.prepareHydratedValue(results[resultsKey], relation.referencedColumn);\n                                if (value !== undefined && value !== null)\n                                    ids.push(value);\n                            }\n                        });\n\n                        if (ids && ids.length)\n                            entity[propertyName] = ids;\n                    }\n                }\n            } else if (relation.idField) {\n                const relationName = relation.name;\n                entity[relation.idField] = this.driver.prepareHydratedValue(rawSqlResults[0][alias.name + \"_\" + relationName], relation.referencedColumn);\n            }\n\n            // if relation counter\n            this.relationCountMetas.forEach(joinMeta => {\n                if (joinMeta.alias === relationAlias) {\n                    // console.log(\"relation count was found for relation: \", relation);\n                    // joinMeta.entity = entity;\n                    joinMeta.entities.push({ entity: entity, metadata: metadata });\n                    // console.log(joinMeta);\n                    // console.log(\"---------------------\");\n                }\n            });\n        });\n\n        return hasData ? entity : null;\n    }\n\n}"],"sourceRoot":"../.."}