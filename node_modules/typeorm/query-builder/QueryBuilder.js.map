{"version":3,"sources":["../../src/query-builder/QueryBuilder.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,uCAAoC;AACpC,6CAA0C;AAC1C,mGAAgG;AAIhG,uEAAoE;AAIpE,2EAAwE;AA0CxE;;GAEG;AACH;IAgCI,4EAA4E;IAC5E,cAAc;IACd,4EAA4E;IAE5E,sBAAsB,UAAsB,EACtB,mBAAyC;QADzC,eAAU,GAAV,UAAU,CAAY;QACtB,wBAAmB,GAAnB,mBAAmB,CAAsB;QA9BrD,SAAI,GAA+B,QAAQ,CAAC;QAC5C,YAAO,GAAa,EAAE,CAAC;QAKvB,UAAK,GAAW,EAAE,CAAC;QACnB,oBAAe,GAAqB,EAAE,CAAC;QACvC,uBAAkB,GAAwB,EAAE,CAAC;QAC7C,aAAQ,GAAa,EAAE,CAAC;QACxB,WAAM,GAAuD,EAAE,CAAC;QAChE,YAAO,GAAuD,EAAE,CAAC;QACjE,aAAQ,GAAqB,EAAE,CAAC;QAChC,eAAU,GAAkB,EAAE,CAAC;QAK/B,4BAAuB,GAAY,KAAK,CAAC;QAEnD;;WAEG;QACO,2BAAsB,GAAY,KAAK,CAAC;QAQ9C,IAAI,CAAC,QAAQ,GAAG,IAAI,mBAAQ,CAAC,UAAU,CAAC,CAAC;IAC7C,CAAC;IASD,sBAAI,+BAAK;QAPT,4EAA4E;QAC5E,YAAY;QACZ,4EAA4E;QAE5E;;WAEG;aACH;YACI,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,IAAI,CAAC;QACxC,CAAC;;;OAAA;IAED,4EAA4E;IAC5E,iBAAiB;IACjB,4EAA4E;IAE5E;;OAEG;IACH,6BAAM,GAAN;QACI,IAAI,CAAC,IAAI,GAAG,QAAQ,CAAC;QACrB,MAAM,CAAC,IAAI,CAAC;IAChB,CAAC;IAiBD;;OAEG;IACH,6BAAM,GAAN,UAAO,4BAA4D,EAAE,cAA8B;QAC/F,IAAM,SAAS,GAAG,cAAc,GAAG,cAAc,GAAmB,4BAA4B,CAAC;QAEjG,EAAE,CAAC,CAAC,4BAA4B,YAAY,QAAQ,CAAC,CAAC,CAAC;YACnD,IAAM,SAAS,GAAU,4BAA6B,CAAC,IAAI,CAAC;YAC5D,IAAM,QAAQ,GAAG,IAAI,aAAK,CAAC,SAAS,CAAC,CAAC;YACtC,QAAQ,CAAC,MAAM,GAAc,4BAA4B,CAAC;YAC1D,IAAI,CAAC,QAAQ,CAAC,YAAY,CAAC,QAAQ,CAAC,CAAC;YACrC,IAAI,CAAC,UAAU,GAAG,EAAE,KAAK,EAAE,QAAQ,EAAE,CAAC;QAE1C,CAAC;QAAC,IAAI,CAAC,EAAE,CAAC,CAAC,OAAO,4BAA4B,KAAK,QAAQ,CAAC,CAAC,CAAC;YAC1D,IAAI,CAAC,aAAa,GAAY,4BAA4B,CAAC;QAC/D,CAAC;QAED,IAAI,CAAC,IAAI,GAAG,QAAQ,CAAC;QACrB,IAAI,CAAC,cAAc,GAAG,SAAS,CAAC;QAChC,MAAM,CAAC,IAAI,CAAC;IAChB,CAAC;IA0BD;;;OAGG;IACH,6BAAM,GAAN,UAAO,SAA2B;QAC9B,IAAI,CAAC,IAAI,GAAG,QAAQ,CAAC;QACrB,EAAE,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC;YACZ,EAAE,CAAC,CAAC,SAAS,YAAY,KAAK,CAAC,CAAC,CAAC;gBAC7B,IAAI,CAAC,OAAO,GAAG,SAAS,CAAC;YAC7B,CAAC;YAAC,IAAI,CAAC,CAAC;gBACJ,IAAI,CAAC,OAAO,GAAG,CAAC,SAAS,CAAC,CAAC;YAC/B,CAAC;QACL,CAAC;QACD,MAAM,CAAC,IAAI,CAAC;IAChB,CAAC;IAiBD;;OAEG;IACH,gCAAS,GAAT,UAAU,SAA0B;QAChC,EAAE,CAAC,CAAC,SAAS,YAAY,KAAK,CAAC;YAC3B,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC;QAClD,IAAI;YACA,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;QAEjC,MAAM,CAAC,IAAI,CAAC;IAChB,CAAC;IAED;;;OAGG;IACH,2BAAI,GAAJ,UAAK,YAA6B,EAAE,KAAa;QAC7C,IAAM,QAAQ,GAAG,IAAI,aAAK,CAAC,KAAK,CAAC,CAAC;QAClC,QAAQ,CAAC,MAAM,GAAG,YAAY,CAAC;QAC/B,IAAI,CAAC,QAAQ,CAAC,YAAY,CAAC,QAAQ,CAAC,CAAC;QACrC,IAAI,CAAC,UAAU,GAAG,EAAC,KAAK,EAAE,QAAQ,EAAC,CAAC;QACpC,MAAM,CAAC,IAAI,CAAC;IAChB,CAAC;IAED;;;OAGG;IACH,gCAAS,GAAT,UAAU,SAAiB,EAAE,KAAa;QACtC,IAAI,CAAC,aAAa,GAAY,SAAS,CAAC;QACxC,IAAI,CAAC,cAAc,GAAG,KAAK,CAAC;QAC5B,MAAM,CAAC,IAAI,CAAC;IAChB,CAAC;IAwBD;;;;OAIG;IACH,gCAAS,GAAT,UAAU,gBAAiC,EAAE,KAAa,EAAE,SAAsB,EAAE,OAAqB;QAA7C,0BAAA,EAAA,cAAsB;QAC9E,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,gBAAgB,EAAE,KAAK,EAAE,SAAS,EAAE,OAAO,CAAC,CAAC;IAC3E,CAAC;IAwBD;;;;OAIG;IACH,+BAAQ,GAAR,UAAS,gBAAiC,EAAE,KAAa,EAAE,SAAsB,EAAE,OAAqB;QAA7C,0BAAA,EAAA,cAAsB;QAC7E,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE,gBAAgB,EAAE,KAAK,EAAE,SAAS,EAAE,OAAO,CAAC,CAAC;IAC1E,CAAC;IAwBD;;;;OAIG;IACH,yCAAkB,GAAlB,UAAmB,gBAAiC,EAAE,KAAa,EAAE,SAAsB,EAAE,OAAqB;QAA7C,0BAAA,EAAA,cAAsB;QACvF,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;QACtB,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,gBAAgB,EAAE,KAAK,EAAE,SAAS,EAAE,OAAO,CAAC,CAAC;IAC3E,CAAC;IAwBD;;;;OAIG;IACH,wCAAiB,GAAjB,UAAkB,gBAAiC,EAAE,KAAa,EAAE,SAAsB,EAAE,OAAqB;QAA7C,0BAAA,EAAA,cAAsB;QACtF,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;QACtB,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE,gBAAgB,EAAE,KAAK,EAAE,SAAS,EAAE,OAAO,CAAC,CAAC;IAC1E,CAAC;IA8BD;;;;;;OAMG;IACH,0CAAmB,GAAnB,UAAoB,aAAqB,EAAE,gBAAiC,EAAE,KAAa,EAAE,SAAsB,EAAE,OAAqB;QAA7C,0BAAA,EAAA,cAAsB;QAC/G,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;QACtB,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,gBAAgB,EAAE,KAAK,EAAE,SAAS,EAAE,OAAO,EAAE,aAAa,EAAE,IAAI,CAAC,CAAC;IAChG,CAAC;IA8BD;;;;;;OAMG;IACH,yCAAkB,GAAlB,UAAmB,aAAqB,EAAE,gBAAiC,EAAE,KAAa,EAAE,SAAsB,EAAE,OAAqB;QAA7C,0BAAA,EAAA,cAAsB;QAC9G,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;QACtB,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,gBAAgB,EAAE,KAAK,EAAE,SAAS,EAAE,OAAO,EAAE,aAAa,EAAE,KAAK,CAAC,CAAC;IACjG,CAAC;IA8BD;;;;;;OAMG;IACH,yCAAkB,GAAlB,UAAmB,aAAqB,EAAE,gBAAiC,EAAE,KAAa,EAAE,SAAsB,EAAE,OAAqB;QAA7C,0BAAA,EAAA,cAAsB;QAC9G,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;QACtB,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE,gBAAgB,EAAE,KAAK,EAAE,SAAS,EAAE,OAAO,EAAE,aAAa,EAAE,IAAI,CAAC,CAAC;IAC/F,CAAC;IA8BD;;;;;;OAMG;IACH,wCAAiB,GAAjB,UAAkB,aAAqB,EAAE,gBAAiC,EAAE,KAAa,EAAE,SAAsB,EAAE,OAAqB;QAA7C,0BAAA,EAAA,cAAsB;QAC7G,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;QACtB,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE,gBAAgB,EAAE,KAAK,EAAE,SAAS,EAAE,OAAO,EAAE,aAAa,EAAE,KAAK,CAAC,CAAC;IAChG,CAAC;IAED;;;;;OAKG;IACH,yCAAkB,GAAlB,UAAmB,QAAgB,EAAE,SAAkB;QACnD,MAAM,CAAC,IAAI,CAAC,cAAc,CAAC,MAAM,EAAE,SAAS,EAAE,QAAQ,EAAE,SAAS,CAAC,CAAC;IACvE,CAAC;IAED;;;;;OAKG;IACH,0CAAmB,GAAnB,UAAoB,QAAgB,EAAE,SAAkB;QACpD,MAAM,CAAC,IAAI,CAAC,cAAc,CAAC,OAAO,EAAE,SAAS,EAAE,QAAQ,EAAE,SAAS,CAAC,CAAC;IACxE,CAAC;IAED;;;;;OAKG;IACH,+CAAwB,GAAxB,UAAyB,aAAqB,EAAE,QAAgB,EAAE,SAAsB;QAAtB,0BAAA,EAAA,cAAsB;QACpF,MAAM,CAAC,IAAI,CAAC,cAAc,CAAC,OAAO,EAAE,aAAa,EAAE,QAAQ,EAAE,SAAS,CAAC,CAAC;IAC5E,CAAC;IAED;;;;;OAKG;IACH,gDAAyB,GAAzB,UAA0B,aAAqB,EAAE,QAAgB,EAAE,SAAsB;QAAtB,0BAAA,EAAA,cAAsB;QACrF,MAAM,CAAC,IAAI,CAAC,cAAc,CAAC,OAAO,EAAE,aAAa,EAAE,QAAQ,EAAE,SAAS,CAAC,CAAC;IAC5E,CAAC;IAED;;;;;OAKG;IACH,oCAAa,GAAb,UAAc,QAAgB,EAAE,SAAsB;QAAtB,0BAAA,EAAA,cAAsB;QAE5C,IAAA,wBAA2D,EAA1D,uBAAe,EAAE,0BAAkB,CAAwB;QAClE,IAAM,KAAK,GAAG,eAAe,GAAG,GAAG,GAAG,kBAAkB,GAAG,iBAAiB,CAAC;QAE7E,IAAM,QAAQ,GAAG,IAAI,aAAK,CAAC,KAAK,CAAC,CAAC;QAClC,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC;QACjC,QAAQ,CAAC,eAAe,GAAG,eAAe,CAAC;QAC3C,QAAQ,CAAC,kBAAkB,GAAG,kBAAkB,CAAC;QAEjD,IAAM,iBAAiB,GAAsB;YACzC,SAAS,EAAE,SAAS;YACpB,KAAK,EAAE,QAAQ;YACf,QAAQ,EAAE,EAAE;SACf,CAAC;QACF,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,iBAAiB,CAAC,CAAC;QAChD,MAAM,CAAC,IAAI,CAAC;IAChB,CAAC;IAED;;;;;OAKG;IACH,0CAAmB,GAAnB,UAAoB,WAAmB,EAAE,QAAgB,EAAE,SAAsB;QAAtB,0BAAA,EAAA,cAAsB;QAEvE,IAAA,wBAA2D,EAA1D,uBAAe,EAAE,0BAAkB,CAAwB;QAClE,IAAM,KAAK,GAAG,eAAe,GAAG,GAAG,GAAG,kBAAkB,GAAG,iBAAiB,CAAC;QAC7E,IAAM,QAAQ,GAAG,IAAI,aAAK,CAAC,KAAK,CAAC,CAAC;QAClC,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC;QACjC,QAAQ,CAAC,eAAe,GAAG,eAAe,CAAC;QAC3C,QAAQ,CAAC,kBAAkB,GAAG,kBAAkB,CAAC;QAEjD,IAAM,iBAAiB,GAAsB;YACzC,aAAa,EAAE,WAAW;YAC1B,SAAS,EAAE,SAAS;YACpB,KAAK,EAAE,QAAQ;YACf,QAAQ,EAAE,EAAE;SACf,CAAC;QACF,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,iBAAiB,CAAC,CAAC;QAChD,MAAM,CAAC,IAAI,CAAC;IAChB,CAAC;IAED;;;;;OAKG;IACH,4BAAK,GAAL,UAAM,KAAa,EAAE,UAA0B;QAC3C,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE,IAAI,EAAE,QAAQ,EAAE,SAAS,EAAE,KAAK,EAAE,CAAC,CAAC;QACvD,EAAE,CAAC,CAAC,UAAU,CAAC;YAAC,IAAI,CAAC,aAAa,CAAC,UAAU,CAAC,CAAC;QAC/C,MAAM,CAAC,IAAI,CAAC;IAChB,CAAC;IAED;;;OAGG;IACH,+BAAQ,GAAR,UAAS,KAAa,EAAE,UAA0B;QAC9C,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE,IAAI,EAAE,KAAK,EAAE,SAAS,EAAE,KAAK,EAAE,CAAC,CAAC;QACpD,EAAE,CAAC,CAAC,UAAU,CAAC;YAAC,IAAI,CAAC,aAAa,CAAC,UAAU,CAAC,CAAC;QAC/C,MAAM,CAAC,IAAI,CAAC;IAChB,CAAC;IAED;;;;OAIG;IACH,oCAAa,GAAb,UAAc,GAAU;QACd,IAAA,uCAAkE,EAAjE,uBAAe,EAAE,kBAAU,CAAuC;QACzE,IAAI,CAAC,QAAQ,CAAC,eAAe,EAAE,UAAU,CAAC,CAAC;QAC3C,MAAM,CAAC,IAAI,CAAC;IAChB,CAAC;IAED;;;OAGG;IACH,8BAAO,GAAP,UAAQ,KAAa,EAAE,UAA0B;QAC7C,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE,IAAI,EAAE,IAAI,EAAE,SAAS,EAAE,KAAK,EAAE,CAAC,CAAC;QACnD,EAAE,CAAC,CAAC,UAAU,CAAC;YAAC,IAAI,CAAC,aAAa,CAAC,UAAU,CAAC,CAAC;QAC/C,MAAM,CAAC,IAAI,CAAC;IAChB,CAAC;IAED;;;;OAIG;IACH,mCAAY,GAAZ,UAAa,GAAU;QACb,IAAA,uCAAkE,EAAjE,uBAAe,EAAE,kBAAU,CAAuC;QACzE,IAAI,CAAC,OAAO,CAAC,eAAe,EAAE,UAAU,CAAC,CAAC;QAC1C,MAAM,CAAC,IAAI,CAAC;IAChB,CAAC;IAED;;;;;OAKG;IACH,6BAAM,GAAN,UAAO,MAAc,EAAE,UAA0B;QAC7C,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE,IAAI,EAAE,QAAQ,EAAE,SAAS,EAAE,MAAM,EAAE,CAAC,CAAC;QACzD,EAAE,CAAC,CAAC,UAAU,CAAC;YAAC,IAAI,CAAC,aAAa,CAAC,UAAU,CAAC,CAAC;QAC/C,MAAM,CAAC,IAAI,CAAC;IAChB,CAAC;IAED;;;OAGG;IACH,gCAAS,GAAT,UAAU,MAAc,EAAE,UAA0B;QAChD,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE,IAAI,EAAE,KAAK,EAAE,SAAS,EAAE,MAAM,EAAE,CAAC,CAAC;QACtD,EAAE,CAAC,CAAC,UAAU,CAAC;YAAC,IAAI,CAAC,aAAa,CAAC,UAAU,CAAC,CAAC;QAC/C,MAAM,CAAC,IAAI,CAAC;IAChB,CAAC;IAED;;;OAGG;IACH,+BAAQ,GAAR,UAAS,MAAc,EAAE,UAA0B;QAC/C,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE,IAAI,EAAE,IAAI,EAAE,SAAS,EAAE,MAAM,EAAE,CAAC,CAAC;QACrD,EAAE,CAAC,CAAC,UAAU,CAAC;YAAC,IAAI,CAAC,aAAa,CAAC,UAAU,CAAC,CAAC;QAC/C,MAAM,CAAC,IAAI,CAAC;IAChB,CAAC;IAED;;;;OAIG;IACH,8BAAO,GAAP,UAAQ,OAAe;QACnB,IAAI,CAAC,QAAQ,GAAG,CAAC,OAAO,CAAC,CAAC;QAC1B,MAAM,CAAC,IAAI,CAAC;IAChB,CAAC;IAED;;OAEG;IACH,iCAAU,GAAV,UAAW,OAAe;QACtB,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;QAC5B,MAAM,CAAC,IAAI,CAAC;IAChB,CAAC;IAED;;;;OAIG;IACH,8BAAO,GAAP,UAAQ,IAAY,EAAE,KAA2B;QAA3B,sBAAA,EAAA,aAA2B;QAC7C,IAAI,CAAC,QAAQ,aAAK,GAAC,IAAI,IAAG,KAAK,KAAE,CAAC;QAClC,MAAM,CAAC,IAAI,CAAC;;IAChB,CAAC;IAED;;OAEG;IACH,iCAAU,GAAV,UAAW,IAAY,EAAE,KAA2B;QAA3B,sBAAA,EAAA,aAA2B;QAChD,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,GAAG,KAAK,CAAC;QAC5B,MAAM,CAAC,IAAI,CAAC;IAChB,CAAC;IAED;;;;;OAKG;IACH,+BAAQ,GAAR,UAAS,KAAa;QAClB,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;QACnB,MAAM,CAAC,IAAI,CAAC;IAChB,CAAC;IAED;;;;;OAKG;IACH,gCAAS,GAAT,UAAU,MAAc;QACpB,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;QACrB,MAAM,CAAC,IAAI,CAAC;IAChB,CAAC;IAED;;OAEG;IACH,oCAAa,GAAb,UAAc,UAAkB;QAC5B,IAAI,CAAC,UAAU,GAAG,UAAU,CAAC;QAC7B,MAAM,CAAC,IAAI,CAAC;IAChB,CAAC;IAED;;OAEG;IACH,qCAAc,GAAd,UAAe,WAAmB;QAC9B,IAAI,CAAC,WAAW,GAAG,WAAW,CAAC;QAC/B,MAAM,CAAC,IAAI,CAAC;IAChB,CAAC;IAED;;OAEG;IACH,mCAAY,GAAZ,UAAa,GAAW,EAAE,KAAU;QAChC,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,GAAG,KAAK,CAAC;QAC7B,MAAM,CAAC,IAAI,CAAC;IAChB,CAAC;IAED;;;OAGG;IACH,oCAAa,GAAb,UAAc,UAAyB;QAAvC,iBAKC;QAJG,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC,OAAO,CAAC,UAAA,GAAG;YAC/B,KAAI,CAAC,UAAU,CAAC,GAAG,CAAC,GAAG,UAAU,CAAC,GAAG,CAAC,CAAC;QAC3C,CAAC,CAAC,CAAC;QACH,MAAM,CAAC,IAAI,CAAC;IAChB,CAAC;IAED;;;;;OAKG;IACH,oCAAa,GAAb,UAAc,UAAyB;QAAvC,iBAKC;QAJG,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC,OAAO,CAAC,UAAA,GAAG;YAC/B,KAAI,CAAC,UAAU,CAAC,GAAG,CAAC,GAAG,UAAU,CAAC,GAAG,CAAC,CAAC;QAC3C,CAAC,CAAC,CAAC;QACH,MAAM,CAAC,IAAI,CAAC;IAChB,CAAC;IAED;;OAEG;IACH,oCAAa,GAAb;QACI,IAAM,UAAU,GAAkB,MAAM,CAAC,MAAM,CAAC,EAAE,EAAE,IAAI,CAAC,UAAU,CAAC,CAAC;QAErE,iDAAiD;QACjD,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC,CAAC;YACtB,IAAM,YAAY,GAAG,IAAI,CAAC,UAAU,CAAC,WAAW,CAAC,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC;YACjF,EAAE,CAAC,CAAC,YAAY,CAAC,sBAAsB,CAAC;gBACpC,UAAU,CAAC,0BAA0B,CAAC,GAAG,YAAY,CAAC,kBAAkB,CAAC;QACjF,CAAC;QAED,MAAM,CAAC,UAAU,CAAC;IACtB,CAAC;IAED;;;OAGG;IACH,6BAAM,GAAN;QACI,IAAI,GAAG,GAAG,IAAI,CAAC,sBAAsB,EAAE,CAAC;QACxC,GAAG,IAAI,IAAI,CAAC,oBAAoB,EAAE,CAAC;QACnC,GAAG,IAAI,IAAI,CAAC,+BAA+B,EAAE,CAAC;QAC9C,GAAG,IAAI,IAAI,CAAC,qBAAqB,EAAE,CAAC;QACpC,GAAG,IAAI,IAAI,CAAC,uBAAuB,EAAE,CAAC;QACtC,GAAG,IAAI,IAAI,CAAC,sBAAsB,EAAE,CAAC;QACrC,GAAG,IAAI,IAAI,CAAC,uBAAuB,EAAE,CAAC;QACtC,GAAG,IAAI,IAAI,CAAC,qBAAqB,EAAE,CAAC;QACpC,GAAG,IAAI,IAAI,CAAC,sBAAsB,EAAE,CAAC;QACpC,+EAAG,CAA2E;QAC/E,MAAM,CAAC,GAAG,CAAC;IACf,CAAC;IAED;;;;OAIG;IACH,wCAAiB,GAAjB;QACI,IAAI,GAAG,GAAG,IAAI,CAAC,sBAAsB,EAAE,CAAC;QACxC,GAAG,IAAI,IAAI,CAAC,oBAAoB,EAAE,CAAC;QACnC,GAAG,IAAI,IAAI,CAAC,+BAA+B,EAAE,CAAC;QAC9C,GAAG,IAAI,IAAI,CAAC,qBAAqB,EAAE,CAAC;QACpC,GAAG,IAAI,IAAI,CAAC,uBAAuB,EAAE,CAAC;QACtC,GAAG,IAAI,IAAI,CAAC,sBAAsB,EAAE,CAAC;QACrC,GAAG,IAAI,IAAI,CAAC,uBAAuB,EAAE,CAAC;QACtC,GAAG,IAAI,IAAI,CAAC,qBAAqB,EAAE,CAAC;QACpC,GAAG,IAAI,IAAI,CAAC,sBAAsB,EAAE,CAAC;QACrC,MAAM,CAAC,GAAG,CAAC;IACf,CAAC;IAED;;;;OAIG;IACH,2CAAoB,GAApB,UAAqB,OAAmC;QACpD,IAAI,GAAG,GAAG,IAAI,CAAC,sBAAsB,EAAE,CAAC;QACxC,GAAG,IAAI,IAAI,CAAC,oBAAoB,EAAE,CAAC;QACnC,GAAG,IAAI,IAAI,CAAC,+BAA+B,EAAE,CAAC;QAC9C,GAAG,IAAI,IAAI,CAAC,qBAAqB,EAAE,CAAC;QACpC,GAAG,IAAI,IAAI,CAAC,uBAAuB,EAAE,CAAC;QACtC,GAAG,IAAI,IAAI,CAAC,sBAAsB,EAAE,CAAC;QACrC,EAAE,CAAC,CAAC,CAAC,OAAO,IAAI,CAAC,OAAO,CAAC,WAAW,CAAC;YACjC,GAAG,IAAI,IAAI,CAAC,uBAAuB,EAAE,CAAC;QAC1C,GAAG,IAAI,IAAI,CAAC,qBAAqB,EAAE,CAAC;QACpC,GAAG,IAAI,IAAI,CAAC,sBAAsB,EAAE,CAAC;QACrC,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,yBAAyB,CAAC,GAAG,EAAE,IAAI,CAAC,aAAa,EAAE,CAAC,CAAC;IACvF,CAAC;IAED;;OAEG;IACG,8BAAO,GAAb;;iCAEW,GAAG,EAAE,UAAU;;;4BADF,qBAAM,IAAI,CAAC,cAAc,EAAE,EAAA;;sCAA3B,SAA2B;6BACrB,IAAI,CAAC,oBAAoB,EAAE;;;;wBAE1C,qBAAM,WAAW,CAAC,KAAK,CAAC,GAAG,EAAE,UAAU,CAAC,EAAA;4BAA/C,sBAAO,SAAwC,EAAC,CAAE,oDAAoD;;6BAGlG,IAAI,CAAC,iBAAiB,EAAE,EAAxB,wBAAwB;wBACxB,qBAAM,WAAW,CAAC,OAAO,EAAE,EAAA;;wBAA3B,SAA2B,CAAC;;;;;;;KAEvC;IAED;;OAEG;IACG,+CAAwB,GAA9B;;;6BAMU,aAAa,EACf,UAAU,MAIH,GAAG,EAAE,UAAU,MACf,OAAO,EAAE,QAAQ,EAElB,eAAa,EACb,UAAQ,EACV,QAAQ,MAkGL,GAAG,EAAE,UAAU;;;;wBAjH1B,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,YAAY,CAAC;4BAC5B,MAAM,IAAI,KAAK,CAAC,uGAAuG,CAAC,CAAC;wBAEzG,qBAAM,IAAI,CAAC,cAAc,EAAE,EAAA;;sCAA3B,SAA2B;wCAEzB,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,IAAI;6BAExF,CAAA,IAAI,CAAC,WAAW,IAAI,IAAI,CAAC,UAAU,CAAA,EAAnC,wBAAmC;6BAGT,IAAI,CAAC,oBAAoB,CAAC,EAAE,WAAW,EAAE,IAAI,EAAE,CAAC;6BAC9C,IAAI,CAAC,yCAAyC,CAAC,eAAe,CAAC;0CAErE,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,eAAe,CAAC,eAAe,CAAC;qCAC5D,IAAI,CAAC,UAAU,CAAC,WAAW,CAAC,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,MAAM,CAAC;mCAC3D,SAAS;wBACxB,QAAQ,IAAI,UAAQ,CAAC,cAAc,CAAC,GAAG,CAAC,UAAC,aAAa,EAAE,KAAK;4BACzD,IAAM,YAAY,GAAG,KAAI,CAAC,UAAU,CAAC,MAAM,CAAC,eAAe,CAAC,aAAa,GAAG,GAAG,GAAG,aAAa,CAAC,IAAI,CAAC,CAAC;4BACtG,EAAE,CAAC,CAAC,KAAK,KAAK,CAAC,CAAC,CAAC,CAAC;gCACd,MAAM,CAAC,cAAY,eAAa,SAAI,YAAY,iBAAY,aAAa,CAAC,IAAM,CAAC;4BACrF,CAAC;4BAAC,IAAI,CAAC,CAAC;gCACJ,MAAM,CAAI,eAAa,SAAI,YAAY,iBAAY,aAAa,CAAC,IAAM,CAAC;4BAC5E,CAAC;wBACL,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;wBACd,EAAE,CAAC,CAAC,OAAO,CAAC,MAAM,GAAG,CAAC,CAAC;4BACnB,QAAQ,IAAI,IAAI,GAAG,OAAO,CAAC;wBAE/B,QAAQ,IAAI,YAAU,GAAG,UAAK,eAAe,CAAC,CAAC,uDAAuD;wBAEtG,EAAE,CAAC,CAAC,QAAQ,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;4BACtB,QAAQ,IAAI,YAAY,GAAG,QAAQ,CAAC;wBACxC,CAAC;wBAAC,IAAI,CAAC,CAAC;4BACJ,QAAQ,IAAI,qBAAkB,UAAQ,CAAC,kBAAkB,CAAC,IAAI,OAAG,CAAC,CAAC,8FAA8F;wBACrK,CAAC;wBAED,EAAE,CAAC,CAAC,IAAI,CAAC,UAAU,CAAC,MAAM,YAAY,iCAAe,CAAC,CAAC,CAAC;4BAEpD,EAAE,CAAC,CAAC,IAAI,CAAC,WAAW,IAAI,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC;gCACtC,QAAQ,IAAI,cAAW,IAAI,CAAC,WAAW,IAAI,CAAC,WAAO,CAAC;gCACpD,EAAE,CAAC,CAAC,IAAI,CAAC,UAAU,CAAC;oCAChB,QAAQ,IAAI,cAAc,GAAG,IAAI,CAAC,UAAU,GAAG,YAAY,CAAC;4BACpE,CAAC;wBACL,CAAC;wBAAC,IAAI,CAAC,CAAC;4BAEJ,EAAE,CAAC,CAAC,IAAI,CAAC,UAAU,CAAC;gCAChB,QAAQ,IAAI,SAAS,GAAG,IAAI,CAAC,UAAU,CAAC;4BAC5C,EAAE,CAAC,CAAC,IAAI,CAAC,WAAW,CAAC;gCACjB,QAAQ,IAAI,UAAU,GAAG,IAAI,CAAC,WAAW,CAAC;wBAClD,CAAC;;;;wBAGU,qBAAM,WAAW,CAAC,KAAK,CAAC,QAAQ,EAAE,UAAU,CAAC;iCAC/C,IAAI,CAAC,UAAC,OAAc;gCACjB,UAAU,GAAG,OAAO,CAAC;gCACrB,EAAE,CAAC,CAAC,OAAO,CAAC,MAAM,KAAK,CAAC,CAAC;oCACrB,MAAM,CAAC,EAAE,CAAC;gCAEd,IAAI,SAAS,GAAG,EAAE,CAAC;gCACnB,IAAM,UAAU,GAAkB,EAAE,CAAC;gCACrC,EAAE,CAAC,CAAC,UAAQ,CAAC,sBAAsB,CAAC,CAAC,CAAC;oCAClC,SAAS,GAAG,OAAO,CAAC,GAAG,CAAC,UAAA,MAAM;wCAC1B,MAAM,CAAC,UAAQ,CAAC,cAAc,CAAC,GAAG,CAAC,UAAA,aAAa;4CAC5C,UAAU,CAAC,MAAM,GAAG,aAAa,CAAC,YAAY,CAAC,GAAG,MAAM,CAAC,MAAM,GAAG,aAAa,CAAC,YAAY,CAAC,CAAC;4CAC9F,MAAM,CAAC,aAAa,GAAG,GAAG,GAAG,aAAa,CAAC,YAAY,GAAG,QAAQ,GAAG,aAAa,CAAC,YAAY,CAAC;wCACpG,CAAC,CAAC,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;oCACrB,CAAC,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;gCACpB,CAAC;gCAAC,IAAI,CAAC,CAAC;oCACJ,IAAM,GAAG,GAAG,OAAO,CAAC,GAAG,CAAC,UAAA,MAAM,IAAI,OAAA,MAAM,CAAC,MAAM,GAAG,UAAQ,CAAC,kBAAkB,CAAC,YAAY,CAAC,EAAzD,CAAyD,CAAC,CAAC;oCAC7F,IAAM,aAAa,GAAG,GAAG,CAAC,GAAG,CAAC,UAAC,EAAO,IAAK,OAAA,OAAO,EAAE,KAAK,QAAQ,EAAtB,CAAsB,CAAC,CAAC;oCACnE,EAAE,CAAC,CAAC,aAAa,CAAC,CAAC,CAAC;wCAChB,8EAA8E;wCAC9E,SAAS,GAAM,aAAa,SAAI,UAAQ,CAAC,kBAAkB,CAAC,YAAY,aAAQ,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,MAAG,CAAC;oCACtG,CAAC;oCAAC,IAAI,CAAC,CAAC;wCACJ,UAAU,CAAC,KAAK,CAAC,GAAG,GAAG,CAAC;wCACxB,SAAS,GAAG,aAAa,GAAG,GAAG,GAAG,UAAQ,CAAC,kBAAkB,CAAC,YAAY,GAAG,YAAY,CAAC;oCAC9F,CAAC;gCACL,CAAC;gCACK,IAAA;;2DAEqB,EAFpB,uBAAe,EAAE,8BAAsB,CAElB;gCAC5B,MAAM,CAAE,WAA2B,CAAC,KAAK,CAAC,eAAe,EAAE,sBAAsB,CAAC,CAAC;4BACvF,CAAC,CAAC;iCACD,IAAI,CAAC,UAAA,OAAO;gCACT,MAAM,CAAC,KAAI,CAAC,oBAAoB,CAAC,OAAO,CAAC,CAAC;4BAC9C,CAAC,CAAC;iCACD,IAAI,CAAC,UAAA,OAAO;gCAET,MAAM,CAAC,KAAI,CAAC,kBAAkB,CAAC,WAA0B,EAAE,OAAO,CAAC;qCAC9D,IAAI,CAAC,UAAA,MAAM;oCACR,mCAAmC;oCACnC,MAAM,CAAC,OAAO,CAAC;gCACnB,CAAC,CAAC,CAAC;4BACX,CAAC,CAAC;iCACD,IAAI,CAAC,UAAA,OAAO;gCACT,EAAE,CAAC,CAAC,CAAC,KAAI,CAAC,aAAa,CAAC;oCACpB,MAAM,CAAC,KAAI,CAAC,UAAU,CAAC,WAAW,CAAC,yBAAyB,CAAC,KAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC,IAAI,CAAC,cAAM,OAAA,OAAO,EAAP,CAAO,CAAC,CAAC;gCAE9H,MAAM,CAAC,OAAO,CAAC;4BACnB,CAAC,CAAC;iCACD,IAAI,CAAC,UAAA,OAAO;gCACT,MAAM,CAAC;oCACH,QAAQ,EAAE,OAAO;oCACjB,UAAU,EAAE,UAAU;iCACzB,CAAC;4BACN,CAAC,CAAC,EAAA;4BArDN,sBAAO,SAqDD,EAAC;;6BAGH,IAAI,CAAC,iBAAiB,EAAE,EAAxB,wBAAwB;wBACxB,qBAAM,WAAW,CAAC,OAAO,EAAE,EAAA;;wBAA3B,SAA2B,CAAC;;;;;6BAKV,IAAI,CAAC,oBAAoB,EAAE;;;;wBAI1C,qBAAM,WAAW,CAAC,KAAK,CAAC,GAAG,EAAE,UAAU,CAAC;iCAC1C,IAAI,CAAC,UAAA,OAAO;gCACT,UAAU,GAAG,OAAO,CAAC;gCACrB,MAAM,CAAC,KAAI,CAAC,oBAAoB,CAAC,OAAO,CAAC,CAAC;4BAC9C,CAAC,CAAC;iCACD,IAAI,CAAC,UAAA,OAAO;gCAET,MAAM,CAAC,KAAI,CAAC,kBAAkB,CAAC,WAA0B,EAAE,OAAO,CAAC;qCAC9D,IAAI,CAAC,UAAA,MAAM;oCACR,mCAAmC;oCACnC,MAAM,CAAC,OAAO,CAAC;gCACnB,CAAC,CAAC,CAAC;4BACX,CAAC,CAAC;iCACD,IAAI,CAAC,UAAA,OAAO;gCACT,EAAE,CAAC,CAAC,CAAC,KAAI,CAAC,aAAa,CAAC,CAAC,CAAC;oCACtB,MAAM,CAAC,KAAI,CAAC,UAAU,CAAC,WAAW;yCAC7B,yBAAyB,CAAC,KAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,MAAM,EAAE,OAAO,CAAC;yCAClE,IAAI,CAAC,cAAM,OAAA,OAAO,EAAP,CAAO,CAAC,CAAC;gCAC7B,CAAC;gCACD,MAAM,CAAC,OAAO,CAAC;4BACnB,CAAC,CAAC;iCACD,IAAI,CAAC,UAAA,OAAO;gCACT,MAAM,CAAC;oCACH,QAAQ,EAAE,OAAO;oCACjB,UAAU,EAAE,UAAU;iCACzB,CAAC;4BACN,CAAC,CAAC,EAAA;;oBA3BN,oBAAoB;oBACpB,sBAAO,SA0BD,EAAC;;6BAGH,IAAI,CAAC,iBAAiB,EAAE,EAAxB,yBAAwB;wBACxB,qBAAM,WAAW,CAAC,OAAO,EAAE,EAAA;;wBAA3B,SAA2B,CAAC;;;;;;;KAG3C;IAED;;;OAGG;IACG,+BAAQ,GAAd;;;6BAIU,SAAS,EACT,QAAQ,EAER,aAAa,EACf,QAAQ,EASN,UAAU,MAUT,aAAa,EAAE,oBAAoB;;;4BAzBtB,qBAAM,IAAI,CAAC,cAAc,EAAE,EAAA;;sCAA3B,SAA2B;oCAE7B,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,IAAI;mCACvE,IAAI,CAAC,UAAU,CAAC,WAAW,CAAC,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,MAAM,CAAC;wCAEpD,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,eAAe,CAAC,SAAS,CAAC;mCACxD,QAAQ,GAAG,QAAQ,CAAC,iCAAiC,CAAC,GAAG,CAAC,UAAC,aAAa,EAAE,KAAK;4BACtF,IAAM,YAAY,GAAG,KAAI,CAAC,UAAU,CAAC,MAAM,CAAC,gBAAgB,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC;4BACjF,EAAE,CAAC,CAAC,KAAK,KAAK,CAAC,CAAC,CAAC,CAAC;gCACd,MAAM,CAAC,cAAY,aAAa,SAAI,YAAY,MAAG,CAAC;4BACxD,CAAC;4BAAC,IAAI,CAAC,CAAC;gCACJ,MAAM,CAAI,aAAa,SAAI,YAAY,MAAG,CAAC;4BAC/C,CAAC;wBACL,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,UAAU;qCAEX,IAAI;6BAClB,KAAK,CAAC;4BACH,mBAAmB,EAAE,IAAI,CAAC,mBAAmB;4BAC7C,YAAY,EAAE,IAAI;4BAClB,uBAAuB,EAAE,IAAI;4BAC7B,SAAS,EAAE,IAAI;4BACf,UAAU,EAAE,IAAI;yBACnB,CAAC;6BACD,MAAM,CAAC,QAAQ,CAAC;6BAEyB,UAAU,CAAC,oBAAoB,EAAE;;;;wBAG3D,qBAAM,WAAW,CAAC,KAAK,CAAC,aAAa,EAAE,oBAAoB,CAAC,EAAA;;kCAA5D,SAA4D;wBAC5E,EAAE,CAAC,CAAC,CAAC,OAAO,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC;4BAC9C,MAAM,gBAAC,CAAC,EAAC;wBAEb,sBAAO,QAAQ,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,EAAC;;6BAG/B,IAAI,CAAC,iBAAiB,EAAE,EAAxB,wBAAwB;wBACxB,qBAAM,WAAW,CAAC,OAAO,EAAE,EAAA;;wBAA3B,SAA2B,CAAC;;;;;;;KAEvC;IAED;;OAEG;IACH,iCAAU,GAAV;QACI,MAAM,CAAC,IAAI,CAAC,OAAO,EAAE,CAAC;IAC1B,CAAC;IAED;;OAEG;IACH,gCAAS,GAAT;QACI,MAAM,CAAC,IAAI,CAAC,UAAU,EAAE,CAAC,IAAI,CAAC,UAAA,OAAO,IAAI,OAAA,OAAO,CAAC,CAAC,CAAC,EAAV,CAAU,CAAC,CAAC;IAEzD,CAAC;IAED;;OAEG;IACH,sCAAe,GAAf;QACI,8CAA8C;QAC9C,MAAM,CAAC,OAAO,CAAC,GAAG,CAAM;YACpB,IAAI,CAAC,OAAO,EAAE;YACd,IAAI,CAAC,QAAQ,EAAE;SAClB,CAAC,CAAC;IACP,CAAC;IAED;;OAEG;IACH,8BAAO,GAAP;QACI,MAAM,CAAC,IAAI,CAAC,wBAAwB,EAAE,CAAC,IAAI,CAAC,UAAA,OAAO;YAC/C,MAAM,CAAC,OAAO,CAAC,QAAQ,CAAC;QAC5B,CAAC,CAAC,CAAC;IACP,CAAC;IAED;;OAEG;IACH,6BAAM,GAAN;QACI,MAAM,CAAC,IAAI,CAAC,OAAO,EAAE,CAAC,IAAI,CAAC,UAAA,QAAQ,IAAI,OAAA,QAAQ,CAAC,CAAC,CAAC,EAAX,CAAW,CAAC,CAAC;IACxD,CAAC;IAED;;OAEG;IACH,4BAAK,GAAL,UAAM,OAA6J;QAAnK,iBA0EC;QAzEG,IAAM,EAAE,GAAG,IAAI,YAAY,CAAC,IAAI,CAAC,UAAU,EAAE,OAAO,GAAG,OAAO,CAAC,mBAAmB,GAAG,SAAS,CAAC,CAAC;QAChG,EAAE,CAAC,CAAC,OAAO,IAAI,OAAO,CAAC,uBAAuB,CAAC;YAC3C,EAAE,CAAC,uBAAuB,GAAG,OAAO,CAAC,uBAAuB,CAAC;QAEjE,MAAM,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;YAChB,KAAK,QAAQ;gBACT,EAAE,CAAC,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;gBACxB,KAAK,CAAC;YACV,KAAK,QAAQ;gBACT,EAAE,CAAC,MAAM,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC;gBAC/B,KAAK,CAAC;YACV,KAAK,QAAQ;gBACT,EAAE,CAAC,MAAM,EAAE,CAAC;gBACZ,KAAK,CAAC;QACd,CAAC;QAED,EAAE,CAAC,CAAC,IAAI,CAAC,UAAU,IAAI,IAAI,CAAC,UAAU,CAAC,KAAK,IAAI,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC;YAC3E,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,MAAM,EAAE,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;QAEtE,CAAC;QAAC,IAAI,CAAC,EAAE,CAAC,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC,CAAC;YAC5B,EAAE,CAAC,SAAS,CAAC,IAAI,CAAC,aAAa,EAAE,IAAI,CAAC,cAAc,CAAC,CAAC;QAC1D,CAAC;QAED,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,UAAA,IAAI;YACnB,IAAM,QAAQ,GAAG,IAAI,CAAC,SAAS,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,eAAe,GAAG,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,kBAAkB,CAAC,CAAC;YAC3H,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE,QAAQ,EAAE,IAAI,CAAC,KAAK,CAAC,IAAI,EAAE,IAAI,CAAC,SAAS,IAAI,EAAE,EAAE,SAAS,EAAE,IAAI,CAAC,aAAa,EAAE,IAAI,CAAC,aAAa,CAAC,CAAC;QAC3H,CAAC,CAAC,CAAC;QAEH,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,UAAA,OAAO,IAAI,OAAA,EAAE,CAAC,UAAU,CAAC,OAAO,CAAC,EAAtB,CAAsB,CAAC,CAAC;QAEzD,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,UAAA,KAAK;YACrB,MAAM,CAAC,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC;gBACjB,KAAK,QAAQ;oBACT,EAAE,CAAC,KAAK,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;oBAC1B,KAAK,CAAC;gBACV,KAAK,KAAK;oBACN,EAAE,CAAC,QAAQ,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;oBAC7B,KAAK,CAAC;gBACV,KAAK,IAAI;oBACL,EAAE,CAAC,OAAO,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;oBAC5B,KAAK,CAAC;YACd,CAAC;QACL,CAAC,CAAC,CAAC;QAEH,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,UAAA,MAAM;YACvB,MAAM,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC;gBAClB,KAAK,QAAQ;oBACT,EAAE,CAAC,MAAM,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC;oBAC5B,KAAK,CAAC;gBACV,KAAK,KAAK;oBACN,EAAE,CAAC,SAAS,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC;oBAC/B,KAAK,CAAC;gBACV,KAAK,IAAI;oBACL,EAAE,CAAC,QAAQ,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC;oBAC9B,KAAK,CAAC;YACd,CAAC;QACL,CAAC,CAAC,CAAC;QAEH,EAAE,CAAC,CAAC,CAAC,OAAO,IAAI,CAAC,OAAO,CAAC,YAAY,CAAC;YAClC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,OAAO,CAAC,UAAA,UAAU,IAAI,OAAA,EAAE,CAAC,UAAU,CAAC,UAAU,EAAE,KAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC,EAApD,CAAoD,CAAC,CAAC;QAE3G,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC,OAAO,CAAC,UAAA,GAAG,IAAI,OAAA,EAAE,CAAC,YAAY,CAAC,GAAG,EAAE,KAAI,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,EAA1C,CAA0C,CAAC,CAAC;QAExF,EAAE,CAAC,CAAC,CAAC,OAAO,IAAI,CAAC,OAAO,CAAC,SAAS,CAAC;YAC/B,EAAE,CAAC,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QAE5B,EAAE,CAAC,CAAC,CAAC,OAAO,IAAI,CAAC,OAAO,CAAC,UAAU,CAAC;YAChC,EAAE,CAAC,SAAS,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;QAE9B,EAAE,CAAC,cAAc,CAAC,IAAI,CAAC,WAAW,CAAC;aAC9B,aAAa,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;QAEpC,MAAM,CAAC,EAAE,CAAC;IACd,CAAC;IAED;;OAEG;IACH,mCAAY,GAAZ,UAAa,MAA4B;QACrC,MAAM,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC;YACb,KAAK,oBAAoB;gBACrB,IAAI,CAAC,sBAAsB,GAAG,IAAI,CAAC;QAC3C,CAAC;QAED,MAAM,CAAC,IAAI,CAAC;IAChB,CAAC;IAED,4EAA4E;IAC5E,oBAAoB;IACpB,4EAA4E;IAElE,yCAAkB,GAA5B,UAA6B,WAAwB,EAAE,OAAiB;QAAxE,iBAoGC;QAlGG,IAAM,QAAQ,GAAG,IAAI,CAAC,kBAAkB,CAAC,GAAG,CAAC,UAAA,iBAAiB;YAC1D,IAAM,WAAW,GAAG,iBAAiB,CAAC,KAAK,CAAC,eAAe,CAAC;YAC5D,IAAM,UAAU,GAAG,KAAI,CAAC,QAAQ,CAAC,eAAe,CAAC,WAAW,CAAC,CAAC;YAC9D,EAAE,CAAC,CAAC,CAAC,UAAU,CAAC;gBACZ,MAAM,IAAI,KAAK,CAAC,aAAU,WAAW,qBAAiB,CAAC,CAAC;YAE5D,IAAM,cAAc,GAAG,KAAI,CAAC,QAAQ,CAAC,wBAAwB,CAAC,UAAU,CAAC,CAAC;YAC1E,EAAE,CAAC,CAAC,CAAC,cAAc,CAAC;gBAChB,MAAM,IAAI,KAAK,CAAC,iDAAiD,GAAG,UAAU,CAAC,IAAI,CAAC,CAAC;YAEzF,IAAM,QAAQ,GAAG,cAAc,CAAC,4BAA4B,CAAC,iBAAiB,CAAC,KAAK,CAAC,kBAAkB,CAAC,CAAC;YAEzG,IAAM,YAAY,GAAG,IAAI,YAAY,CAAC,KAAI,CAAC,UAAU,EAAE,KAAI,CAAC,mBAAmB,CAAC,CAAC;YACjF,IAAI,SAAS,GAAG,EAAE,CAAC;YAEnB,IAAM,QAAQ,GAAG,KAAI,CAAC,QAAQ,CAAC,wBAAwB,CAAC,iBAAiB,CAAC,KAAK,CAAC,CAAC;YACjF,EAAE,CAAC,CAAC,CAAC,QAAQ,CAAC;gBACV,MAAM,IAAI,KAAK,CAAC,iDAAiD,GAAG,iBAAiB,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;YAEtG,IAAI,aAAa,GAAW,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAC;YAEhD,IAAM,gBAAgB,GAAG,QAAQ,CAAC,sBAAsB,CAAC;YACzD,IAAM,iBAAiB,GAAG,iBAAiB,CAAC,SAAS,GAAG,OAAO,GAAG,KAAI,CAAC,oBAAoB,CAAC,iBAAiB,CAAC,SAAS,CAAC,GAAG,EAAE,CAAC;YAE9H;;;;;;;;;;;;;;;;;;;;;;;;;;;gBA2BI;YAEJ,mCAAmC;YACnC,gDAAgD;YAChD,kCAAkC;YAClC,iCAAiC;YAEjC,IAAM,GAAG,GAAG,iBAAiB,CAAC,QAAQ;iBACjC,GAAG,CAAC,UAAA,kBAAkB,IAAI,OAAA,kBAAkB,CAAC,QAAQ,CAAC,cAAc,CAAC,kBAAkB,CAAC,MAAM,CAAC,EAArE,CAAqE,CAAC;iBAChG,MAAM,CAAC,UAAA,KAAK,IAAI,OAAA,KAAK,KAAK,SAAS,EAAnB,CAAmB,CAAC;iBACpC,GAAG,CAAC,UAAA,KAAK,IAAI,OAAA,KAAM,CAAC,cAAc,CAAC,aAAa,CAAC,YAAY,CAAC,EAAjD,CAAiD,CAAC,CAAC;YACrE,EAAE,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC;gBACpB,MAAM,CAAC,OAAO,CAAC,OAAO,EAAE,CAAC,CAAC,+DAA+D;YAE7F,MAAM,CAAC,YAAY;iBACd,MAAM,CAAI,cAAc,CAAC,IAAI,GAAG,GAAG,GAAG,cAAc,CAAC,aAAa,CAAC,YAAY,WAAQ,CAAC;iBACxF,SAAS,CAAC,YAAU,KAAI,CAAC,UAAU,CAAC,MAAM,CAAC,eAAe,CAAC,QAAQ,CAAC,YAAY,CAAC,GAAG,GAAG,GAAG,KAAI,CAAC,UAAU,CAAC,MAAM,CAAC,gBAAgB,CAAC,QAAQ,CAAC,qBAAqB,CAAC,aAAa,CAAC,IAAI,CAAC,cAAW,CAAC;iBAChM,IAAI,CAAC,cAAc,CAAC,MAAM,EAAE,cAAc,CAAC,IAAI,CAAC;iBAChD,QAAQ,CAAC,cAAc,CAAC,IAAI,GAAG,GAAG,GAAG,QAAQ,CAAC,YAAY,EAAE,QAAQ,CAAC,YAAY,EAAE,iBAAiB,CAAC,SAAS,CAAC;iBAC/G,aAAa,CAAC,KAAI,CAAC,UAAU,CAAC;iBAC9B,KAAK,CAAI,cAAc,CAAC,IAAI,GAAG,GAAG,GAAG,cAAc,CAAC,aAAa,CAAC,YAAY,4BAAyB,EAAE,EAAC,gBAAgB,EAAE,GAAG,EAAC,CAAC;iBACjI,OAAO,CAAC,cAAc,CAAC,IAAI,GAAG,GAAG,GAAG,cAAc,CAAC,aAAa,CAAC,YAAY,CAAC;iBAC9E,UAAU,EAAE;iBACZ,IAAI,CAAC,UAAC,OAAgC;gBACnC,2CAA2C;gBAC3C,iBAAiB,CAAC,QAAQ,CAAC,OAAO,CAAC,UAAA,kBAAkB;oBACjD,IAAM,QAAQ,GAAG,kBAAkB,CAAC,MAAM,CAAC,kBAAkB,CAAC,QAAQ,CAAC,aAAa,CAAC,YAAY,CAAC,CAAC;oBACnG,IAAM,YAAY,GAAG,OAAO,CAAC,IAAI,CAAC,UAAA,MAAM;wBACpC,MAAM,CAAC,QAAQ,KAAK,KAAI,CAAC,UAAU,CAAC,MAAM,CAAC,oBAAoB,CAAC,MAAM,CAAC,EAAE,EAAE,kBAAkB,CAAC,QAAQ,CAAC,aAAa,CAAC,CAAC;oBAC1H,CAAC,CAAC,CAAC;oBACH,EAAE,CAAC,CAAC,YAAY,CAAC,CAAC,CAAC;wBAEf,EAAE,CAAC,CAAC,iBAAiB,CAAC,aAAa,CAAC,CAAC,CAAC;4BAC5B,IAAA,+CAAmF,EAAlF,kBAAU,EAAE,oBAAY,CAA2D;4BAC1F,oFAAoF;4BACpF,uEAAuE;4BACvE,kBAAkB,CAAC,MAAM,CAAC,YAAY,CAAC,GAAG,QAAQ,CAAC,YAAY,CAAC,GAAG,CAAC,CAAC;wBAEzE,CAAC;wBAAC,IAAI,CAAC,EAAE,CAAC,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC,CAAC;4BAC7B,kBAAkB,CAAC,MAAM,CAAC,QAAQ,CAAC,UAAU,CAAC,GAAG,QAAQ,CAAC,YAAY,CAAC,GAAG,CAAC,CAAC;wBAChF,CAAC;oBACL,CAAC;gBACL,CAAC,CAAC,CAAC;YACP,CAAC,CAAC,CAAC;QACX,CAAC,CAAC,CAAC;QAEH,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;IACjC,CAAC;IAES,2CAAoB,GAA9B,UAA+B,OAAc;QACzC,IAAM,WAAW,GAAG,IAAI,mEAAgC,CAAC,IAAI,CAAC,UAAU,CAAC,MAAM,EAAE,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,mBAAmB,EAAE,EAAE,IAAI,CAAC,kBAAkB,EAAE,IAAI,CAAC,sBAAsB,CAAC,CAAC;QAClL,MAAM,CAAC,WAAW,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC;IAC1C,CAAC;IAES,6CAAsB,GAAhC;QACI,qDAAqD;QADzD,iBA2HC;QAxHG,IAAI,KAAK,GAAW,EAAE,EAAE,SAAiB,CAAC;QAC1C,IAAM,UAAU,GAAa,EAAE,CAAC;QAEhC,EAAE,CAAC,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC,CAAC;YACrB,SAAS,GAAG,IAAI,CAAC,aAAa,CAAC;YAC/B,KAAK,GAAG,IAAI,CAAC,cAAc,CAAC;YAC5B,kCAAkC;QAEtC,CAAC;QAAC,IAAI,CAAC,EAAE,CAAC,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC;YACzB,IAAM,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC,wBAAwB,CAAC,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC;YAC/E,EAAE,CAAC,CAAC,CAAC,QAAQ,CAAC;gBACV,MAAM,IAAI,KAAK,CAAC,iDAAiD,GAAG,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;YACpG,SAAS,GAAG,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAC;YAChC,KAAK,GAAG,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,IAAI,CAAC;YACnC,kDAAkD;YAClD,kCAAkC;YAElC,iCAAiC;YACjC,EAAE,CAAC,CAAC,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;gBACrC,QAAQ,CAAC,OAAO,CAAC,OAAO,CAAC,UAAA,MAAM;oBAC3B,UAAU,CAAC,IAAI,CAAC,KAAI,CAAC,UAAU,CAAC,MAAM,CAAC,eAAe,CAAC,KAAK,CAAC,GAAG,GAAG,GAAG,KAAI,CAAC,UAAU,CAAC,MAAM,CAAC,gBAAgB,CAAC,MAAM,CAAC,IAAI,CAAC,GAAG,MAAM,GAAG,KAAI,CAAC,UAAU,CAAC,MAAM,CAAC,eAAe,CAAC,KAAK,GAAG,GAAG,GAAG,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC;gBAC7M,CAAC,CAAC,CAAC;YACP,CAAC;QAEL,CAAC;QAAC,IAAI,CAAC,CAAC;YACJ,MAAM,IAAI,KAAK,CAAC,eAAe,CAAC,CAAC;QACrC,CAAC;QAED,yBAAyB;QACzB,IAAI,CAAC,KAAK;aACL,MAAM,CAAC,UAAA,IAAI,IAAI,OAAA,KAAI,CAAC,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,EAA5C,CAA4C,CAAC;aAC5D,OAAO,CAAC,UAAA,IAAI;YACT,IAAM,YAAY,GAAG,KAAI,CAAC,QAAQ,CAAC,wBAAwB,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;YACxE,EAAE,CAAC,CAAC,YAAY,CAAC,CAAC,CAAC;gBACf,YAAY,CAAC,OAAO,CAAC,OAAO,CAAC,UAAA,MAAM;oBAC/B,UAAU,CAAC,IAAI,CAAC,KAAI,CAAC,UAAU,CAAC,MAAM,CAAC,eAAe,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,GAAG,GAAG,KAAI,CAAC,UAAU,CAAC,MAAM,CAAC,gBAAgB,CAAC,MAAM,CAAC,IAAI,CAAC,GAAG,MAAM,GAAG,KAAI,CAAC,UAAU,CAAC,MAAM,CAAC,eAAe,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,GAAG,GAAG,GAAG,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC;gBACjO,CAAC,CAAC,CAAC;YACP,CAAC;YAAC,IAAI,CAAC,CAAC;gBACJ,UAAU,CAAC,IAAI,CAAC,KAAI,CAAC,UAAU,CAAC,MAAM,CAAC,eAAe,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC;YAC7E,CAAC;QACL,CAAC,CAAC,CAAC;QAEP,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,uBAAuB,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC,CAAC;YACvD,IAAM,QAAQ,GAAG,IAAI,CAAC,UAAU,CAAC,WAAW,CAAC,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC;YAC7E,EAAE,CAAC,CAAC,QAAQ,CAAC,oBAAoB,IAAI,QAAQ,CAAC,eAAe,CAAC,CAAC,CAAC;gBAC5D,IAAM,OAAK,GAAG,iBAAiB,GAAG,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,eAAe,CAAC,QAAQ,CAAC,oBAAoB,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;gBACnH,QAAQ,CAAC,oBAAoB,CAAC,OAAO,CAAC,OAAO,CAAC,UAAA,MAAM;oBAChD,UAAU,CAAC,IAAI,CAAC,OAAK,GAAG,GAAG,GAAG,KAAI,CAAC,UAAU,CAAC,MAAM,CAAC,gBAAgB,CAAC,MAAM,CAAC,IAAI,CAAC,GAAG,MAAM,GAAG,OAAK,GAAG,GAAG,GAAG,KAAI,CAAC,UAAU,CAAC,MAAM,CAAC,eAAe,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC;gBACrK,CAAC,CAAC,CAAC;YACP,CAAC;QACL,CAAC;QAED,qCAAqC;QACrC,IAAI,CAAC,eAAe,CAAC,OAAO,CAAC,UAAA,IAAI;YAC7B,2EAA2E;YAE3E,IAAM,WAAW,GAAG,IAAI,CAAC,KAAK,CAAC,eAAe,CAAC;YAC/C,IAAM,UAAU,GAAG,KAAI,CAAC,QAAQ,CAAC,eAAe,CAAC,WAAW,CAAC,CAAC;YAC9D,EAAE,CAAC,CAAC,CAAC,UAAU,CAAC;gBACZ,MAAM,IAAI,KAAK,CAAC,aAAU,WAAW,qBAAiB,CAAC,CAAC;YAE5D,IAAM,cAAc,GAAG,KAAI,CAAC,QAAQ,CAAC,wBAAwB,CAAC,UAAU,CAAC,CAAC;YAC1E,EAAE,CAAC,CAAC,CAAC,cAAc,CAAC;gBAChB,MAAM,IAAI,KAAK,CAAC,iDAAiD,GAAG,UAAU,CAAC,IAAI,CAAC,CAAC;YACzF,IAAM,QAAQ,GAAG,cAAc,CAAC,4BAA4B,CAAC,IAAI,CAAC,KAAK,CAAC,kBAAkB,CAAC,CAAC;YAC5F,IAAM,gBAAgB,GAAG,QAAQ,CAAC,sBAAsB,CAAC;YACzD,qDAAqD;YAErD,gBAAgB,CAAC,OAAO,CAAC,OAAO,CAAC,UAAA,MAAM;gBACnC,UAAU,CAAC,IAAI,CAAC,KAAI,CAAC,UAAU,CAAC,MAAM,CAAC,eAAe,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,GAAG,GAAG,KAAI,CAAC,UAAU,CAAC,MAAM,CAAC,gBAAgB,CAAC,MAAM,CAAC,IAAI,CAAC,GAAG,MAAM,GAAG,KAAI,CAAC,UAAU,CAAC,MAAM,CAAC,eAAe,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,GAAG,GAAG,GAAG,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC;YACjO,CAAC,CAAC,CAAC;QACP,CAAC,CAAC,CAAC;QAEH,EAAE;QACF;;;;;;;;;;;;;;;;WAgBG;QAEH,wBAAwB;QACxB,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,UAAA,MAAM;YACtB,MAAM,CAAC,MAAM,KAAK,KAAK,IAAI,CAAC,KAAI,CAAC,KAAK,CAAC,IAAI,CAAC,UAAA,IAAI,IAAI,OAAA,IAAI,CAAC,KAAK,CAAC,IAAI,KAAK,MAAM,EAA1B,CAA0B,CAAC,CAAC;QACpF,CAAC,CAAC,CAAC,OAAO,CAAC,UAAA,MAAM,IAAI,OAAA,UAAU,CAAC,IAAI,CAAC,KAAI,CAAC,oBAAoB,CAAC,MAAM,CAAC,CAAC,EAAlD,CAAkD,CAAC,CAAC;QAEzE,6DAA6D;QAC7D,EAAE,CAAC,CAAC,UAAU,CAAC,MAAM,KAAK,CAAC,CAAC;YACxB,UAAU,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;QAEzB,2BAA2B;QAC3B,MAAM,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;YAChB,KAAK,QAAQ;gBACT,MAAM,CAAC,SAAS,GAAG,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,QAAQ,GAAG,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,eAAe,CAAC,SAAS,CAAC,GAAG,GAAG,GAAG,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,eAAe,CAAC,KAAK,CAAC,CAAC;YAClK,KAAK,QAAQ;gBACT,MAAM,CAAC,cAAc,GAAG,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,eAAe,CAAC,SAAS,CAAC,CAAC;YAC1E,yYAAyY;YAC7Y,KAAK,QAAQ;gBACT,IAAM,SAAS,GAAG,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC,GAAG,CAAC,UAAA,GAAG,IAAI,OAAA,GAAG,GAAG,mBAAmB,GAAG,GAAG,EAA/B,CAA+B,CAAC,CAAC;gBAC/F,IAAM,MAAM,GAAG,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC,MAAM,CAAC,UAAC,MAAM,EAAE,GAAG;oBAC/D,qCAAqC;oBAC9B,MAAO,CAAC,iBAAiB,GAAG,GAAG,CAAC,GAAU,KAAI,CAAC,cAAe,CAAC,GAAG,CAAC,CAAC;oBAC3E,MAAM,CAAC,MAAM,CAAC;gBAClB,CAAC,EAAE,EAAE,CAAC,CAAC;gBACP,IAAI,CAAC,aAAa,CAAC,MAAM,CAAC,CAAC;gBAC3B,MAAM,CAAC,SAAS,GAAG,SAAS,GAAG,GAAG,GAAG,CAAC,KAAK,GAAG,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,eAAe,CAAC,KAAK,CAAC,GAAG,EAAE,CAAC,GAAG,OAAO,GAAG,SAAS,CAAC;QAChI,CAAC;QAED,MAAM,IAAI,KAAK,CAAC,qCAAqC,CAAC,CAAC;IAC3D,CAAC;IAES,4CAAqB,GAA/B;QAAA,iBAsBC;QApBG,IAAM,UAAU,GAAG,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,UAAC,KAAK,EAAE,KAAK;YAC5C,MAAM,CAAC,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC;gBACjB,KAAK,KAAK;oBACN,MAAM,CAAC,CAAC,KAAK,GAAG,CAAC,GAAG,MAAM,GAAG,EAAE,CAAC,GAAG,KAAI,CAAC,oBAAoB,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;gBAClF,KAAK,IAAI;oBACL,MAAM,CAAC,CAAC,KAAK,GAAG,CAAC,GAAG,KAAK,GAAG,EAAE,CAAC,GAAG,KAAI,CAAC,oBAAoB,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;gBACjF;oBACI,MAAM,CAAC,KAAI,CAAC,oBAAoB,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;YAC1D,CAAC;QACL,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;QAEb,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC,CAAC;YACtB,IAAM,YAAY,GAAG,IAAI,CAAC,UAAU,CAAC,WAAW,CAAC,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC;YACjF,EAAE,CAAC,CAAC,YAAY,CAAC,sBAAsB,CAAC;gBACpC,MAAM,CAAC,aAAW,UAAU,CAAC,MAAM,GAAG,GAAG,GAAG,UAAU,GAAG,OAAO,GAAG,EAAE,UAAK,YAAY,CAAC,mBAAmB,CAAC,IAAI,+BAA4B,CAAC;QAEpJ,CAAC;QAED,EAAE,CAAC,CAAC,CAAC,UAAU,CAAC,MAAM,CAAC;YAAC,MAAM,CAAC,EAAE,CAAC;QAClC,MAAM,CAAC,SAAS,GAAG,UAAU,CAAC;IAClC,CAAC;IAED;;OAEG;IACK,2CAAoB,GAA5B,UAA6B,SAAiB;QAA9C,iBAqBC;QApBG,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,OAAO,CAAC,UAAA,KAAK;YAC/B,IAAM,QAAQ,GAAG,KAAI,CAAC,QAAQ,CAAC,wBAAwB,CAAC,KAAK,CAAC,CAAC;YAC/D,EAAE,CAAC,CAAC,CAAC,QAAQ,CAAC;gBAAC,MAAM,CAAC;YACtB,QAAQ,CAAC,SAAS,CAAC,OAAO,CAAC,UAAA,QAAQ;gBAC/B,QAAQ,CAAC,OAAO,CAAC,OAAO,CAAC,UAAA,MAAM;oBAC3B,IAAM,UAAU,GAAG,KAAK,CAAC,IAAI,GAAG,KAAK,GAAG,QAAQ,CAAC,YAAY,GAAG,KAAK,GAAG,MAAM,CAAC,YAAY,GAAG,cAAc,CAAC;oBAC7G,SAAS,GAAG,SAAS,CAAC,OAAO,CAAC,IAAI,MAAM,CAAC,UAAU,EAAE,IAAI,CAAC,EAAE,KAAI,CAAC,UAAU,CAAC,MAAM,CAAC,eAAe,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,GAAG,GAAG,KAAI,CAAC,UAAU,CAAC,MAAM,CAAC,gBAAgB,CAAC,MAAM,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,CAAC;gBACxL,CAAC,CAAC,CAAC;gBACH,4CAA4C;YAChD,CAAC,CAAC,CAAC;YACH,QAAQ,CAAC,OAAO,CAAC,MAAM,CAAC,UAAA,MAAM,IAAI,OAAA,CAAC,MAAM,CAAC,YAAY,EAApB,CAAoB,CAAC,CAAC,OAAO,CAAC,UAAA,MAAM;gBAClE,IAAM,UAAU,GAAG,KAAK,CAAC,IAAI,GAAG,KAAK,GAAG,MAAM,CAAC,YAAY,GAAG,cAAc,CAAC;gBAC7E,SAAS,GAAG,SAAS,CAAC,OAAO,CAAC,IAAI,MAAM,CAAC,UAAU,EAAE,IAAI,CAAC,EAAE,KAAI,CAAC,UAAU,CAAC,MAAM,CAAC,eAAe,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,GAAG,GAAG,KAAI,CAAC,UAAU,CAAC,MAAM,CAAC,gBAAgB,CAAC,MAAM,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,CAAC;YACxL,CAAC,CAAC,CAAC;YACH,QAAQ,CAAC,wBAAwB,CAAA,+CAA+C,CAAC,OAAO,CAAC,UAAA,QAAQ;gBAC7F,IAAM,UAAU,GAAG,KAAK,CAAC,IAAI,GAAG,KAAK,GAAG,QAAQ,CAAC,YAAY,GAAG,cAAc,CAAC;gBAC/E,SAAS,GAAG,SAAS,CAAC,OAAO,CAAC,IAAI,MAAM,CAAC,UAAU,EAAE,IAAI,CAAC,EAAE,KAAI,CAAC,UAAU,CAAC,MAAM,CAAC,eAAe,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,GAAG,GAAG,KAAI,CAAC,UAAU,CAAC,MAAM,CAAC,gBAAgB,CAAC,QAAQ,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,CAAC;YAC1L,CAAC,CAAC,CAAC;QACP,CAAC,CAAC,CAAC;QACH,MAAM,CAAC,SAAS,CAAC;IACrB,CAAC;IAES,sDAA+B,GAAzC;QAAA,iBAgCC;QA/BG,MAAM,CAAC,IAAI,CAAC,eAAe,CAAC,GAAG,CAAC,UAAA,IAAI;YAChC,IAAM,WAAW,GAAG,IAAI,CAAC,KAAK,CAAC,eAAe,CAAC;YAC/C,IAAM,UAAU,GAAG,KAAI,CAAC,QAAQ,CAAC,eAAe,CAAC,WAAW,CAAC,CAAC;YAC9D,EAAE,CAAC,CAAC,CAAC,UAAU,CAAC;gBACZ,MAAM,IAAI,KAAK,CAAC,aAAU,WAAW,qBAAiB,CAAC,CAAC;YAE5D,IAAM,cAAc,GAAG,KAAI,CAAC,QAAQ,CAAC,wBAAwB,CAAC,UAAU,CAAC,CAAC;YAC1E,EAAE,CAAC,CAAC,CAAC,cAAc,CAAC;gBAChB,MAAM,IAAI,KAAK,CAAC,iDAAiD,GAAG,UAAU,CAAC,IAAI,CAAC,CAAC;YAEzF,IAAM,QAAQ,GAAG,cAAc,CAAC,4BAA4B,CAAC,IAAI,CAAC,KAAK,CAAC,kBAAkB,CAAC,CAAC;YAC5F,IAAM,gBAAgB,GAAG,QAAQ,CAAC,sBAAsB,CAAC;YACzD,IAAM,aAAa,GAAG,gBAAgB,CAAC,KAAK,CAAC,IAAI,CAAC;YAClD,IAAM,aAAa,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC;YACtC,IAAM,SAAS,GAAG,QAAQ,CAAC,QAAQ,GAAG,QAAQ,CAAC,SAAS,GAAG,QAAQ,CAAC,eAAe,CAAC,SAAS,CAAC,CAAC,8BAA8B;YAC7H,IAAM,eAAe,GAAG,SAAS,CAAC,gBAAgB,CAAC,IAAI,CAAC,CAAC,8BAA8B;YAEvF,IAAI,UAAU,GAAG,EAAE,CAAC;YACpB,EAAE,CAAC,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC,CAAC;gBACpB,UAAU,GAAG,KAAI,CAAC,UAAU,CAAC,MAAM,CAAC,eAAe,CAAC,aAAa,CAAC,GAAG,GAAG,GAAG,KAAI,CAAC,UAAU,CAAC,MAAM,CAAC,gBAAgB,CAAC,gBAAgB,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,GAAG,GAAG,KAAI,CAAC,UAAU,CAAC,MAAM,CAAC,eAAe,CAAC,WAAW,CAAC,GAAG,GAAG,GAAG,KAAI,CAAC,UAAU,CAAC,MAAM,CAAC,gBAAgB,CAAC,eAAe,CAAC,CAAC;gBAClR,uHAAuH;YAC3H,CAAC;YAAC,IAAI,CAAC,CAAC;gBACJ,UAAU,GAAG,KAAI,CAAC,UAAU,CAAC,MAAM,CAAC,eAAe,CAAC,aAAa,CAAC,GAAG,GAAG,GAAG,KAAI,CAAC,UAAU,CAAC,MAAM,CAAC,gBAAgB,CAAC,gBAAgB,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,GAAG,GAAG,KAAI,CAAC,UAAU,CAAC,MAAM,CAAC,eAAe,CAAC,WAAW,CAAC,GAAG,GAAG,GAAG,KAAI,CAAC,UAAU,CAAC,MAAM,CAAC,gBAAgB,CAAC,eAAe,CAAC,CAAC;gBAClR,uHAAuH;YAC3H,CAAC;YAED,MAAM,CAAC,GAAG,GAAG,IAAI,CAAC,IAAI,GAAG,QAAQ,GAAG,aAAa,GAAG,GAAG,GAAG,KAAI,CAAC,UAAU,CAAC,MAAM,CAAC,eAAe,CAAC,aAAa,CAAC,GAAG,MAAM,GAAG,UAAU,CAAC;YACtI,iIAAiI;YACjI,qBAAqB;YACrB,yJAAyJ;QAC7J,CAAC,CAAC,CAAC;IACP,CAAC;IAES,2CAAoB,GAA9B;QAAA,iBA4GC;QA3GG,IAAI,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,UAAA,IAAI;YAC3B,IAAM,QAAQ,GAAG,IAAI,CAAC,IAAI,CAAC,CAAC,kCAAkC;YAC9D,IAAI,aAAa,GAAW,IAAI,CAAC,SAAS,CAAC;YAC3C,EAAE,CAAC,CAAC,CAAC,aAAa,CAAC,CAAC,CAAC;gBACjB,IAAM,QAAQ,GAAG,KAAI,CAAC,QAAQ,CAAC,wBAAwB,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;gBACpE,EAAE,CAAC,CAAC,CAAC,QAAQ,CAAC;oBACV,MAAM,IAAI,KAAK,CAAC,iDAAiD,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;gBAEzF,aAAa,GAAG,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAC;YACxC,CAAC;YAED,IAAM,WAAW,GAAG,IAAI,CAAC,KAAK,CAAC,eAAe,CAAC;YAC/C,EAAE,CAAC,CAAC,CAAC,WAAW,CAAC,CAAC,CAAC;gBACf,MAAM,CAAC,GAAG,GAAG,QAAQ,GAAG,QAAQ,GAAG,KAAI,CAAC,UAAU,CAAC,MAAM,CAAC,eAAe,CAAC,aAAa,CAAC,GAAG,GAAG,GAAG,KAAI,CAAC,UAAU,CAAC,MAAM,CAAC,eAAe,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,GAAG,GAAG,CAAC,IAAI,CAAC,SAAS,GAAG,CAAE,KAAK,GAAG,KAAI,CAAC,oBAAoB,CAAC,IAAI,CAAC,SAAS,CAAC,CAAE,GAAG,EAAE,CAAC,CAAC;YACnP,CAAC;YAED,IAAM,UAAU,GAAG,KAAI,CAAC,QAAQ,CAAC,eAAe,CAAC,WAAW,CAAC,CAAC;YAC9D,EAAE,CAAC,CAAC,CAAC,UAAU,CAAC;gBACZ,MAAM,IAAI,KAAK,CAAC,aAAU,WAAW,qBAAiB,CAAC,CAAC;YAE5D,IAAM,cAAc,GAAG,KAAI,CAAC,QAAQ,CAAC,wBAAwB,CAAC,UAAU,CAAC,CAAC;YAC1E,EAAE,CAAC,CAAC,CAAC,cAAc,CAAC;gBAChB,MAAM,IAAI,KAAK,CAAC,iDAAiD,GAAG,UAAU,CAAC,IAAI,CAAC,CAAC;YAEzF,IAAM,QAAQ,GAAG,cAAc,CAAC,4BAA4B,CAAC,IAAI,CAAC,KAAK,CAAC,kBAAkB,CAAC,CAAC;YAC5F,IAAM,gBAAgB,GAAG,QAAQ,CAAC,sBAAsB,CAAC;YACzD,IAAM,iBAAiB,GAAG,IAAI,CAAC,SAAS,GAAG,OAAO,GAAG,KAAI,CAAC,oBAAoB,CAAC,IAAI,CAAC,SAAS,CAAC,GAAG,EAAE,CAAC;YAEpG,EAAE,CAAC,CAAC,QAAQ,CAAC,YAAY,CAAC,CAAC,CAAC;gBACxB,IAAM,aAAa,GAAG,gBAAgB,CAAC,KAAK,CAAC,IAAI,CAAC;gBAClD,IAAM,aAAa,GAAG,IAAI,CAAC,KAAK,CAAC,eAAe,GAAG,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC;gBACzE,IAAM,SAAS,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC;gBAClC,IAAM,SAAS,GAAG,QAAQ,CAAC,QAAQ,GAAG,QAAQ,CAAC,SAAS,GAAG,QAAQ,CAAC,eAAe,CAAC,SAAS,CAAC;gBAC9F,IAAM,eAAe,GAAG,QAAQ,CAAC,QAAQ,GAAG,SAAS,CAAC,gBAAgB,CAAC,IAAI,GAAG,SAAS,CAAC,uBAAuB,CAAC,IAAI,CAAC;gBACrH,IAAM,qBAAqB,GAAG,QAAQ,CAAC,QAAQ,GAAG,SAAS,CAAC,uBAAuB,CAAC,IAAI,GAAG,SAAS,CAAC,gBAAgB,CAAC,IAAI,CAAC;gBAE3H,IAAI,UAAU,GAAG,EAAE,EAAE,UAAU,GAAG,EAAE,CAAC;gBACrC,EAAE,CAAC,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC,CAAC;oBACpB,UAAU,GAAG,KAAI,CAAC,UAAU,CAAC,MAAM,CAAC,eAAe,CAAC,aAAa,CAAC,GAAG,GAAG,GAAG,KAAI,CAAC,UAAU,CAAC,MAAM,CAAC,gBAAgB,CAAC,gBAAgB,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,GAAG,GAAG,KAAI,CAAC,UAAU,CAAC,MAAM,CAAC,eAAe,CAAC,WAAW,CAAC,GAAG,GAAG,GAAG,KAAI,CAAC,UAAU,CAAC,MAAM,CAAC,gBAAgB,CAAC,eAAe,CAAC,CAAC;oBAClR,UAAU,GAAG,KAAI,CAAC,UAAU,CAAC,MAAM,CAAC,eAAe,CAAC,SAAS,CAAC,GAAG,GAAG,GAAG,KAAI,CAAC,UAAU,CAAC,MAAM,CAAC,gBAAgB,CAAC,qBAAqB,CAAC,GAAG,GAAG,GAAG,KAAI,CAAC,UAAU,CAAC,MAAM,CAAC,eAAe,CAAC,aAAa,CAAC,GAAG,GAAG,GAAG,KAAI,CAAC,UAAU,CAAC,MAAM,CAAC,gBAAgB,CAAC,gBAAgB,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC;gBAC1R,CAAC;gBAAC,IAAI,CAAC,CAAC;oBACJ,UAAU,GAAG,KAAI,CAAC,UAAU,CAAC,MAAM,CAAC,eAAe,CAAC,aAAa,CAAC,GAAG,GAAG,GAAG,KAAI,CAAC,UAAU,CAAC,MAAM,CAAC,gBAAgB,CAAC,gBAAgB,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,GAAG,GAAG,KAAI,CAAC,UAAU,CAAC,MAAM,CAAC,eAAe,CAAC,WAAW,CAAC,GAAG,GAAG,GAAG,KAAI,CAAC,UAAU,CAAC,MAAM,CAAC,gBAAgB,CAAC,eAAe,CAAC,CAAC;oBAClR,UAAU,GAAG,KAAI,CAAC,UAAU,CAAC,MAAM,CAAC,eAAe,CAAC,SAAS,CAAC,GAAG,GAAG,GAAG,KAAI,CAAC,UAAU,CAAC,MAAM,CAAC,gBAAgB,CAAC,qBAAqB,CAAC,GAAG,GAAG,GAAG,KAAI,CAAC,UAAU,CAAC,MAAM,CAAC,eAAe,CAAC,aAAa,CAAC,GAAG,GAAG,GAAG,KAAI,CAAC,UAAU,CAAC,MAAM,CAAC,gBAAgB,CAAC,gBAAgB,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC;gBAC1R,CAAC;gBAED,MAAM,CAAC,GAAG,GAAG,QAAQ,GAAG,QAAQ,GAAG,KAAI,CAAC,UAAU,CAAC,MAAM,CAAC,eAAe,CAAC,aAAa,CAAC,GAAG,GAAG,GAAG,KAAI,CAAC,UAAU,CAAC,MAAM,CAAC,eAAe,CAAC,aAAa,CAAC,GAAG,MAAM,GAAG,UAAU;oBACrK,GAAG,GAAG,QAAQ,GAAG,QAAQ,GAAG,KAAI,CAAC,UAAU,CAAC,MAAM,CAAC,eAAe,CAAC,aAAa,CAAC,GAAG,GAAG,GAAG,KAAI,CAAC,UAAU,CAAC,MAAM,CAAC,eAAe,CAAC,SAAS,CAAC,GAAG,MAAM,GAAG,UAAU,GAAG,iBAAiB,CAAC;YAEjM,CAAC;YAAC,IAAI,CAAC,EAAE,CAAC,CAAC,QAAQ,CAAC,WAAW,IAAI,CAAC,QAAQ,CAAC,UAAU,IAAI,QAAQ,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;gBAC5E,IAAM,eAAe,GAAG,QAAQ,CAAC,UAAU,CAAC,gBAAgB,CAAC,IAAI,CAAC;gBAClE,IAAM,SAAS,GAAG,KAAI,CAAC,UAAU,CAAC,MAAM,CAAC,eAAe,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,GAAG,GAAG,KAAI,CAAC,UAAU,CAAC,MAAM,CAAC,gBAAgB,CAAC,eAAe,CAAC,GAAG,GAAG,GAAG,KAAI,CAAC,UAAU,CAAC,MAAM,CAAC,eAAe,CAAC,WAAW,CAAC,GAAG,GAAG,GAAG,KAAI,CAAC,UAAU,CAAC,MAAM,CAAC,gBAAgB,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;gBACtQ,MAAM,CAAC,GAAG,GAAG,QAAQ,GAAG,QAAQ,GAAG,KAAI,CAAC,UAAU,CAAC,MAAM,CAAC,eAAe,CAAC,aAAa,CAAC,GAAG,GAAG,GAAG,KAAI,CAAC,UAAU,CAAC,MAAM,CAAC,eAAe,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,MAAM,GAAG,SAAS,GAAG,iBAAiB,CAAC;YAEtM,CAAC;YAAC,IAAI,CAAC,EAAE,CAAC,CAAC,QAAQ,CAAC,WAAW,IAAI,CAAC,QAAQ,CAAC,UAAU,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;gBAC7E,IAAM,eAAe,GAAG,QAAQ,CAAC,eAAe,CAAC,UAAU,CAAC,gBAAgB,CAAC,IAAI,CAAC;gBAClF,IAAM,SAAS,GAAG,KAAI,CAAC,UAAU,CAAC,MAAM,CAAC,eAAe,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,GAAG,GAAG,KAAI,CAAC,UAAU,CAAC,MAAM,CAAC,gBAAgB,CAAC,QAAQ,CAAC,eAAe,CAAC,IAAI,CAAC,GAAG,GAAG,GAAG,KAAI,CAAC,UAAU,CAAC,MAAM,CAAC,eAAe,CAAC,WAAW,CAAC,GAAG,GAAG,GAAG,KAAI,CAAC,UAAU,CAAC,MAAM,CAAC,gBAAgB,CAAC,eAAe,CAAC,CAAC;gBACtR,MAAM,CAAC,GAAG,GAAG,QAAQ,GAAG,QAAQ,GAAG,KAAI,CAAC,UAAU,CAAC,MAAM,CAAC,eAAe,CAAC,aAAa,CAAC,GAAG,GAAG,GAAG,KAAI,CAAC,UAAU,CAAC,MAAM,CAAC,eAAe,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,MAAM,GAAG,SAAS,GAAG,iBAAiB,CAAC;YAEtM,CAAC;YAAC,IAAI,CAAC,CAAC;gBACJ,MAAM,IAAI,KAAK,CAAC,0BAA0B,CAAC,CAAC,CAAC,8BAA8B;YAC/E,CAAC;QACL,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;QAEb,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,uBAAuB,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC,CAAC;YACvD,IAAM,QAAQ,GAAG,IAAI,CAAC,UAAU,CAAC,WAAW,CAAC,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC;YAC7E,EAAE,CAAC,CAAC,QAAQ,CAAC,oBAAoB,IAAI,QAAQ,CAAC,eAAe,CAAC,CAAC,CAAC;gBAC5D,IAAM,OAAK,GAAG,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,eAAe,CAAC,iBAAiB,GAAG,QAAQ,CAAC,oBAAoB,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;gBACnH,KAAK,IAAI,QAAQ,GAAG,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,eAAe,CAAC,QAAQ,CAAC,oBAAoB,CAAC,KAAK,CAAC,IAAI,CAAC;sBAC9F,GAAG,GAAG,OAAK,GAAG,MAAM,CAAC;gBAC3B,KAAK,IAAI,QAAQ,CAAC,eAAe,CAAC,GAAG,CAAC,UAAA,cAAc;oBAChD,MAAM,CAAC,KAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,IAAI,GAAG,GAAG,GAAG,cAAc,CAAC,IAAI,GAAG,GAAG,GAAG,OAAK,GAAG,GAAG,GAAG,cAAc,CAAC,YAAY,CAAC;gBACtH,CAAC,CAAC,CAAC;YACP,CAAC;QACL,CAAC;QAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;WA6BG;QAEH,MAAM,CAAC,KAAK,CAAC;IACjB,CAAC;IAES,8CAAuB,GAAjC;QACI,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,QAAQ,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC;YAAC,MAAM,CAAC,EAAE,CAAC;QACvD,MAAM,CAAC,YAAY,GAAG,IAAI,CAAC,oBAAoB,CAAC,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;IAC9E,CAAC;IAES,6CAAsB,GAAhC;QAAA,iBAYC;QAXG,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,OAAO,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC;YAAC,MAAM,CAAC,EAAE,CAAC;QACrD,MAAM,CAAC,UAAU,GAAG,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,UAAA,MAAM;YACnC,MAAM,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC;gBAClB,KAAK,KAAK;oBACN,MAAM,CAAC,OAAO,GAAG,KAAI,CAAC,oBAAoB,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC;gBACjE,KAAK,IAAI;oBACL,MAAM,CAAC,MAAM,GAAG,KAAI,CAAC,oBAAoB,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC;gBAChE;oBACI,MAAM,CAAC,GAAG,GAAG,KAAI,CAAC,oBAAoB,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC;YACjE,CAAC;QACL,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;IACrB,CAAC;IAES,gEAAyC,GAAnD,UAAoD,WAAmB;QAAvE,iBAwBC;QAtBG,6CAA6C;QAC7C,IAAI,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC;QAC7B,EAAE,CAAC,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,MAAM,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC,CAAC;YACvD,IAAM,QAAQ,GAAG,IAAI,CAAC,UAAU,CAAC,WAAW,CAAC,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC;YAC7E,QAAQ,GAAG,QAAQ,CAAC,KAAK,CAAC,OAAO,IAAI,EAAE,CAAC;QAC5C,CAAC;QAED,IAAM,YAAY,GAAG,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC;aACrC,GAAG,CAAC,UAAA,UAAU;YACL,IAAA,0BAA8D,EAA7D,aAAK,EAAE,cAAM,EAAE,gCAAqB,CAA0B;YACrE,MAAM,CAAC,KAAI,CAAC,UAAU,CAAC,MAAM,CAAC,eAAe,CAAC,WAAW,CAAC,GAAG,GAAG,GAAG,KAAI,CAAC,UAAU,CAAC,MAAM,CAAC,gBAAgB,CAAC,KAAK,GAAG,GAAG,GAAG,MAAM,GAAG,kBAAkB,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC;QACpK,CAAC,CAAC;aACD,IAAI,CAAC,IAAI,CAAC,CAAC;QAEhB,IAAM,aAAa,GAAG,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC;aACtC,GAAG,CAAC,UAAA,UAAU;YACL,IAAA,0BAA8D,EAA7D,aAAK,EAAE,cAAM,EAAE,gCAAqB,CAA0B;YACrE,MAAM,CAAC,KAAI,CAAC,UAAU,CAAC,MAAM,CAAC,eAAe,CAAC,WAAW,CAAC,GAAG,GAAG,GAAG,KAAI,CAAC,UAAU,CAAC,MAAM,CAAC,gBAAgB,CAAC,KAAK,GAAG,GAAG,GAAG,MAAM,GAAG,kBAAkB,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,GAAG,GAAG,GAAG,KAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC;QACtM,CAAC,CAAC;aACD,IAAI,CAAC,IAAI,CAAC,CAAC;QAEhB,MAAM,CAAC,CAAC,YAAY,EAAE,aAAa,CAAC,CAAC;IACzC,CAAC;IAES,8CAAuB,GAAjC;QAAA,iBAmBC;QAjBG,IAAI,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC;QAE7B,6CAA6C;QAC7C,EAAE,CAAC,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,MAAM,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC,CAAC;YACvD,IAAM,QAAQ,GAAG,IAAI,CAAC,UAAU,CAAC,WAAW,CAAC,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC;YAC7E,QAAQ,GAAG,QAAQ,CAAC,KAAK,CAAC,OAAO,IAAI,EAAE,CAAC;QAC5C,CAAC;QAED,iDAAiD;QACjD,EAAE,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,MAAM,GAAG,CAAC,CAAC;YACjC,MAAM,CAAC,YAAY,GAAG,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC;iBAClC,GAAG,CAAC,UAAA,UAAU;gBACX,MAAM,CAAC,KAAI,CAAC,oBAAoB,CAAC,UAAU,CAAC,GAAG,GAAG,GAAG,KAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC;YACnF,CAAC,CAAC;iBACD,IAAI,CAAC,IAAI,CAAC,CAAC;QAExB,MAAM,CAAC,EAAE,CAAC;IACd,CAAC;IAES,4CAAqB,GAA/B;QACI,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC;YAAC,MAAM,CAAC,EAAE,CAAC;QAC3B,MAAM,CAAC,SAAS,GAAG,IAAI,CAAC,KAAK,CAAC;IAClC,CAAC;IAES,6CAAsB,GAAhC;QACI,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC;YAAC,MAAM,CAAC,EAAE,CAAC;QAC5B,MAAM,CAAC,UAAU,GAAG,IAAI,CAAC,MAAM,CAAC;IACpC,CAAC;IAEO,0CAAmB,GAA3B;QACI,IAAM,QAAQ,GAAkB,EAAE,CAAC;QACnC,IAAI,CAAC,KAAK;aACL,MAAM,CAAC,UAAA,IAAI,IAAI,OAAA,CAAC,CAAC,IAAI,CAAC,aAAa,EAApB,CAAoB,CAAC;aACpC,OAAO,CAAC,UAAA,IAAI;YACH,IAAA,kCAAsE,EAArE,kBAAU,EAAE,oBAAY,CAA8C;YAC7E,QAAQ,CAAC,IAAI,CAAC;gBACV,IAAI,EAAE,MAAM;gBACZ,KAAK,EAAE,IAAI,CAAC,KAAK;gBACjB,UAAU,EAAE,UAAU;gBACtB,YAAY,EAAE,YAAY;gBAC1B,MAAM,EAAE,IAAI,CAAC,aAAa;aACd,CAAC,CAAC;QACtB,CAAC,CAAC,CAAC;QAEP,IAAI,CAAC,eAAe;aACf,MAAM,CAAC,UAAA,IAAI,IAAI,OAAA,CAAC,CAAC,IAAI,CAAC,aAAa,EAApB,CAAoB,CAAC;aACpC,OAAO,CAAC,UAAA,IAAI;YACH,IAAA,kCAAsE,EAArE,kBAAU,EAAE,oBAAY,CAA8C;YAC7E,QAAQ,CAAC,IAAI,CAAC;gBACV,IAAI,EAAE,YAAY;gBAClB,KAAK,EAAE,IAAI,CAAC,KAAK;gBACjB,UAAU,EAAE,UAAU;gBACtB,YAAY,EAAE,YAAY;gBAC1B,MAAM,EAAE,KAAK;aAChB,CAAC,CAAC;QACP,CAAC,CAAC,CAAC;QAEP,MAAM,CAAC,QAAQ,CAAC;IACpB,CAAC;IAKS,2BAAI,GAAd,UAAe,QAAwB,EAAE,gBAAiC,EAAE,KAAa,EAAE,SAAsB,EAAE,OAAqB,EAAE,aAAsB,EAAE,aAA8B;QAE5L,uEAAuE;QACvE,kFAAkF;QAHK,0BAAA,EAAA,cAAsB;QAAiD,8BAAA,EAAA,qBAA8B;QAK5L,IAAI,SAAS,GAAG,EAAE,CAAC;QACnB,IAAM,QAAQ,GAAG,IAAI,aAAK,CAAC,KAAK,CAAC,CAAC;QAClC,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC;QACjC,EAAE,CAAC,CAAC,gBAAgB,YAAY,QAAQ,CAAC,CAAC,CAAC;YACvC,QAAQ,CAAC,MAAM,GAAG,gBAAgB,CAAC;QAEvC,CAAC;QAAC,IAAI,CAAC,EAAE,CAAC,CAAC,IAAI,CAAC,eAAe,CAAC,gBAAgB,CAAC,CAAC,CAAC,CAAC;YAChD,gCAAqF,EAApF,gCAAwB,EAAE,mCAA2B,CAAgC;QAE1F,CAAC;QAAC,IAAI,CAAC,EAAE,CAAC,CAAC,OAAO,gBAAgB,KAAK,QAAQ,CAAC,CAAC,CAAC;YAC9C,SAAS,GAAG,gBAAgB,CAAC;YAC7B,EAAE,CAAC,CAAC,CAAC,aAAa,CAAC;gBACf,aAAa,GAAG,gBAAgB,CAAC;QACzC,CAAC;QAED,IAAM,IAAI,GAAS;YACf,IAAI,EAAE,QAAQ;YACd,KAAK,EAAE,QAAQ;YACf,SAAS,EAAE,SAAS;YACpB,SAAS,EAAE,SAAS;YACpB,OAAO,EAAE,OAAO;YAChB,aAAa,EAAE,aAAa;YAC5B,aAAa,EAAE,aAAa;SAC/B,CAAC;QACF,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QACtB,MAAM,CAAC,IAAI,CAAC;;IAChB,CAAC;IAES,qCAAc,GAAxB,UAAyB,QAAwB,EAAE,aAA+B,EAAE,QAAgB,EAAE,SAAkB;QAEpH,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,eAAe,CAAC,QAAQ,CAAC,CAAC;YAChC,MAAM,IAAI,KAAK,CAAC,uEAAuE,CAAC,CAAC,CAAC,wDAAwD;QAEhJ,IAAA,wBAA2D,EAA1D,uBAAe,EAAE,0BAAkB,CAAwB;QAClE,IAAM,KAAK,GAAG,eAAe,GAAG,GAAG,GAAG,kBAAkB,GAAG,cAAc,CAAC;QAE1E,IAAM,QAAQ,GAAG,IAAI,aAAK,CAAC,KAAK,CAAC,CAAC;QAClC,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC;QACjC,QAAQ,CAAC,eAAe,GAAG,eAAe,CAAC;QAC3C,QAAQ,CAAC,kBAAkB,GAAG,kBAAkB,CAAC;QAEjD,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC;YACtB,IAAI,EAAE,QAAQ;YACd,aAAa,EAAE,aAAa;YAC5B,KAAK,EAAE,QAAQ;YACf,SAAS,EAAE,SAAS;SACvB,CAAC,CAAC;QAEH,MAAM,CAAC,IAAI,CAAC;IAChB,CAAC;IAEO,0CAAmB,GAA3B,UAA4B,GAAQ;QAChC,MAAM,CAAC,kBAAkB,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;IACxC,CAAC;IAEO,sCAAe,GAAvB,UAAwB,GAAQ;QAC5B,EAAE,CAAC,CAAC,CAAC,CAAC,OAAO,GAAG,KAAK,QAAQ,CAAC,CAAC;YAC3B,MAAM,CAAC,KAAK,CAAC;QACjB,EAAE,CAAC,CAAC,GAAG,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC;YACxB,MAAM,CAAC,KAAK,CAAC;QAEjB,IAAM,SAAS,GAAG,GAAG,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;QACpC,IAAM,YAAY,GAAG,GAAG,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;QAEvC,EAAE,CAAC,CAAC,CAAC,SAAS,IAAI,CAAC,YAAY,CAAC;YAC5B,MAAM,CAAC,KAAK,CAAC;QAEjB,IAAM,eAAe,GAAG,kBAAkB,CAAC;QAC3C,IAAM,kBAAkB,GAAG,eAAe,CAAC;QAC3C,EAAE,CAAC,CAAC,CAAC,eAAe,CAAC,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;YAC3E,MAAM,CAAC,KAAK,CAAC;QAEjB,MAAM,CAAC,IAAI,CAAC;IAChB,CAAC;IAED;;OAEG;IACO,+CAAwB,GAAlC,UAAmC,GAAU;QAA7C,iBAmCC;QAlCG,IAAM,QAAQ,GAAG,IAAI,CAAC,UAAU,CAAC,WAAW,CAAC,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC;QAE7E,0CAA0C;QAC1C,IAAM,WAAW,GAAG,UAAC,KAAa,IAAK,OAAA,KAAI,CAAC,UAAU,CAAC,MAAM,CAAC,eAAe,CAAC,KAAK,CAAC,EAA7C,CAA6C,CAAC;QACrF,IAAM,YAAY,GAAG,UAAC,MAAc,IAAK,OAAA,KAAI,CAAC,UAAU,CAAC,MAAM,CAAC,gBAAgB,CAAC,MAAM,CAAC,EAA/C,CAA+C,CAAC;QAEzF,IAAM,KAAK,GAAG,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,IAAI,CAAC;QAC3C,IAAM,UAAU,GAAkB,EAAE,CAAC;QACrC,IAAM,YAAY,GAAG,GAAG,CAAC,GAAG,CAAC,UAAC,EAAE,EAAE,KAAK;YACnC,IAAM,eAAe,GAAa,EAAE,CAAC;YACrC,EAAE,CAAC,CAAC,QAAQ,CAAC,sBAAsB,CAAC,CAAC,CAAC;gBAClC,QAAQ,CAAC,cAAc,CAAC,OAAO,CAAC,UAAC,aAAa,EAAE,WAAW;oBACvD,eAAe,CAAC,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,GAAG,GAAG,GAAG,YAAY,CAAC,aAAa,CAAC,IAAI,CAAC,GAAG,OAAO,GAAG,KAAK,GAAG,GAAG,GAAG,WAAW,CAAC,CAAC;oBACxH,UAAU,CAAC,KAAK,GAAG,KAAK,GAAG,GAAG,GAAG,WAAW,CAAC,GAAG,EAAE,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC;gBAC3E,CAAC,CAAC,CAAC;gBACH,QAAQ,CAAC,eAAe,CAAC,OAAO,CAAC,UAAC,aAAa,EAAE,WAAW;oBACxD,eAAe,CAAC,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,GAAG,GAAG,GAAG,YAAY,CAAC,EAAE,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC,GAAG,aAAa,GAAG,KAAK,GAAG,GAAG,GAAG,WAAW,CAAC,CAAC;oBAClI,UAAU,CAAC,WAAW,GAAG,KAAK,GAAG,GAAG,GAAG,WAAW,CAAC,GAAG,EAAE,CAAC,aAAa,CAAC,YAAY,CAAC,CAAC;gBACzF,CAAC,CAAC,CAAC;YACP,CAAC;YAAC,IAAI,CAAC,CAAC;gBACJ,EAAE,CAAC,CAAC,QAAQ,CAAC,cAAc,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;oBACrC,eAAe,CAAC,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,GAAG,GAAG,GAAG,YAAY,CAAC,QAAQ,CAAC,kBAAkB,CAAC,IAAI,CAAC,GAAG,OAAO,GAAG,KAAK,CAAC,CAAC;oBAClH,UAAU,CAAC,KAAK,GAAG,KAAK,CAAC,GAAG,EAAE,CAAC;gBAEnC,CAAC;gBAAC,IAAI,CAAC,EAAE,CAAC,CAAC,QAAQ,CAAC,eAAe,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;oBAC7C,eAAe,CAAC,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,GAAG,GAAG,GAAG,YAAY,CAAC,QAAQ,CAAC,eAAe,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,aAAa,GAAG,KAAK,CAAC,CAAC;oBACxH,UAAU,CAAC,WAAW,GAAG,KAAK,CAAC,GAAG,EAAE,CAAC;gBACzC,CAAC;YACL,CAAC;YACD,MAAM,CAAC,eAAe,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;QACzC,CAAC,CAAC,CAAC;QAEH,IAAM,WAAW,GAAG,YAAY,CAAC,MAAM,GAAG,CAAC,GAAG,GAAG,GAAG,YAAY,CAAC,IAAI,CAAC,MAAM,CAAC,GAAG,GAAG,GAAG,YAAY,CAAC,CAAC,CAAC,CAAC;QACtG,MAAM,CAAC,CAAC,WAAW,EAAE,UAAU,CAAC,CAAC;IACrC,CAAC;IAEe,qCAAc,GAA9B;;;gBAEI,EAAE,CAAC,CAAC,IAAI,CAAC,mBAAmB,YAAY,yCAAmB,CAAC,CAAC,CAAC;oBAC1D,MAAM,gBAAC,IAAI,CAAC,mBAAmB,CAAC,OAAO,EAAE,EAAC;gBAE9C,CAAC;gBAAC,IAAI,CAAC,CAAC;oBACJ,MAAM,gBAAC,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,iBAAiB,EAAE,EAAC;gBACtD,CAAC;;;;KACJ;IAES,wCAAiB,GAA3B;QACI,MAAM,CAAC,CAAC,IAAI,CAAC,mBAAmB,CAAC;IACrC,CAAC;IAEL,mBAAC;AAAD,CA7zDA,AA6zDC,IAAA;AA7zDY,oCAAY","file":"QueryBuilder.js","sourcesContent":["import {Alias} from \"./alias/Alias\";\nimport {AliasMap} from \"./alias/AliasMap\";\nimport {RawSqlResultsToEntityTransformer} from \"./transformer/RawSqlResultsToEntityTransformer\";\nimport {EntityMetadata} from \"../metadata/EntityMetadata\";\nimport {ObjectLiteral} from \"../common/ObjectLiteral\";\nimport {QueryRunner} from \"../query-runner/QueryRunner\";\nimport {SqlServerDriver} from \"../driver/sqlserver/SqlServerDriver\";\nimport {OrderByCondition} from \"../find-options/OrderByCondition\";\nimport {Connection} from \"../connection/Connection\";\nimport {JoinOptions} from \"./JoinOptions\";\nimport {QueryRunnerProvider} from \"../query-runner/QueryRunnerProvider\";\n\n/**\n */\nexport interface Join {\n    alias: Alias;\n    type: \"LEFT\"|\"INNER\";\n    condition?: string;\n    tableName: string;\n    mapToProperty?: string;\n    isMappingMany: boolean;\n    options?: JoinOptions;\n}\n\nexport interface JoinRelationId {\n\n    alias: Alias;\n    type: \"LEFT\"|\"INNER\";\n    condition?: string;\n    mapToProperty?: string;\n}\n\nexport interface RelationCountMeta {\n\n    alias: Alias;\n    // property: string;\n    condition?: string;\n    mapToProperty?: string;\n    entities: { entity: any, metadata: EntityMetadata }[];\n    // entity?: any;\n}\n\n/**\n */\nexport interface JoinMapping {\n    type: \"join\"|\"relationId\";\n    alias: Alias;\n    parentName: string;\n    propertyName: string;\n    isMany: boolean;\n}\n\n/**\n * Allows to build complex sql queries in a fashion way and execute those queries.\n */\nexport class QueryBuilder<Entity> {\n\n    // -------------------------------------------------------------------------\n    // Protected properties\n    // -------------------------------------------------------------------------\n\n    protected aliasMap: AliasMap;\n    protected type: \"select\"|\"update\"|\"delete\" = \"select\";\n    protected selects: string[] = [];\n    protected fromEntity: { alias: Alias };\n    protected fromTableName: string;\n    protected fromTableAlias: string;\n    protected updateQuerySet: Object;\n    protected joins: Join[] = [];\n    protected joinRelationIds: JoinRelationId[] = [];\n    protected relationCountMetas: RelationCountMeta[] = [];\n    protected groupBys: string[] = [];\n    protected wheres: { type: \"simple\"|\"and\"|\"or\", condition: string }[] = [];\n    protected havings: { type: \"simple\"|\"and\"|\"or\", condition: string }[] = [];\n    protected orderBys: OrderByCondition = {};\n    protected parameters: ObjectLiteral = {};\n    protected limit: number;\n    protected offset: number;\n    protected firstResult: number;\n    protected maxResults: number;\n    protected ignoreParentTablesJoins: boolean = false;\n\n    /**\n     * Indicates if virtual columns should be included in entity result.\n     */\n    protected enableRelationIdValues: boolean = false;\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(protected connection: Connection,\n                protected queryRunnerProvider?: QueryRunnerProvider) {\n        this.aliasMap = new AliasMap(connection);\n    }\n\n    // -------------------------------------------------------------------------\n    // Accessors\n    // -------------------------------------------------------------------------\n\n    /**\n     * Gets the main alias string used in this query builder.\n     */\n    get alias(): string {\n        return this.aliasMap.mainAlias.name;\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Creates DELETE query.\n     */\n    delete(): this {\n        this.type = \"delete\";\n        return this;\n    }\n\n    /**\n     * Creates UPDATE query and applies given update values.\n     */\n    update(updateSet: ObjectLiteral): this;\n\n    /**\n     * Creates UPDATE query for the given entity and applies given update values.\n     */\n    update(entity: Function, updateSet: ObjectLiteral): this;\n\n    /**\n     * Creates UPDATE query for the given table name and applies given update values.\n     */\n    update(tableName: string, updateSet: ObjectLiteral): this;\n\n    /**\n     * Creates UPDATE query and applies given update values.\n     */\n    update(tableNameOrEntityOrUpdateSet?: string|Function|ObjectLiteral, maybeUpdateSet?: ObjectLiteral): this {\n        const updateSet = maybeUpdateSet ? maybeUpdateSet : <ObjectLiteral> tableNameOrEntityOrUpdateSet;\n\n        if (tableNameOrEntityOrUpdateSet instanceof Function) {\n            const aliasName = (<any> tableNameOrEntityOrUpdateSet).name;\n            const aliasObj = new Alias(aliasName);\n            aliasObj.target = <Function> tableNameOrEntityOrUpdateSet;\n            this.aliasMap.addMainAlias(aliasObj);\n            this.fromEntity = { alias: aliasObj };\n\n        } else if (typeof tableNameOrEntityOrUpdateSet === \"string\") {\n            this.fromTableName = <string> tableNameOrEntityOrUpdateSet;\n        }\n\n        this.type = \"update\";\n        this.updateQuerySet = updateSet;\n        return this;\n    }\n\n    /**\n     * Creates SELECT query.\n     * Replaces all old selections if they exist.\n     */\n    select(): this;\n\n    /**\n     * Creates SELECT query and selects given data.\n     * Replaces all old selections if they exist.\n     */\n    select(selection: string): this;\n\n    /**\n     * Creates SELECT query and selects given data.\n     * Replaces all old selections if they exist.\n     */\n    select(selection: string[]): this;\n\n    /**\n     * Creates SELECT query and selects given data.\n     * Replaces all old selections if they exist.\n     */\n    select(...selection: string[]): this;\n\n    /**\n     * Creates SELECT query and selects given data.\n     * Replaces all old selections if they exist.\n     */\n    select(selection?: string|string[]): this {\n        this.type = \"select\";\n        if (selection) {\n            if (selection instanceof Array) {\n                this.selects = selection;\n            } else {\n                this.selects = [selection];\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Adds new selection to the SELECT query.\n     */\n    addSelect(selection: string): this;\n\n    /**\n     * Adds new selection to the SELECT query.\n     */\n    addSelect(selection: string[]): this;\n\n    /**\n     * Adds new selection to the SELECT query.\n     */\n    addSelect(...selection: string[]): this;\n\n    /**\n     * Adds new selection to the SELECT query.\n     */\n    addSelect(selection: string|string[]): this {\n        if (selection instanceof Array)\n            this.selects = this.selects.concat(selection);\n        else\n            this.selects.push(selection);\n\n        return this;\n    }\n\n    /**\n     * Specifies FROM which entity's table select/update/delete will be executed.\n     * Also sets a main string alias of the selection data.\n     */\n    from(entityTarget: Function|string, alias: string): this {\n        const aliasObj = new Alias(alias);\n        aliasObj.target = entityTarget;\n        this.aliasMap.addMainAlias(aliasObj);\n        this.fromEntity = {alias: aliasObj};\n        return this;\n    }\n\n    /**\n     * Specifies FROM which table select/update/delete will be executed.\n     * Also sets a main string alias of the selection data.\n     */\n    fromTable(tableName: string, alias: string) {\n        this.fromTableName = <string> tableName;\n        this.fromTableAlias = alias;\n        return this;\n    }\n\n    /**\n     * INNER JOINs (without selection) entity's property.\n     * Given entity property should be a relation.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoin(property: string, alias: string, condition?: string, options?: JoinOptions): this;\n\n    /**\n     * INNER JOINs (without selection) given entity's table.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoin(entity: Function|string, alias: string, condition?: string, options?: JoinOptions): this;\n\n    /**\n     * INNER JOINs (without selection) given table.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoin(tableName: string, alias: string, condition?: string, options?: JoinOptions): this;\n\n    /**\n     * INNER JOINs (without selection).\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoin(entityOrProperty: Function|string, alias: string, condition: string = \"\", options?: JoinOptions): this {\n        return this.join(\"INNER\", entityOrProperty, alias, condition, options);\n    }\n\n    /**\n     * LEFT JOINs (without selection) entity's property.\n     * Given entity property should be a relation.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoin(property: string, alias: string, condition?: string, options?: JoinOptions): this;\n\n    /**\n     * LEFT JOINs (without selection) entity's table.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoin(entity: Function|string, alias: string, condition?: string, options?: JoinOptions): this;\n\n    /**\n     * LEFT JOINs (without selection) given table.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoin(tableName: string, alias: string, condition?: string, options?: JoinOptions): this;\n\n    /**\n     * LEFT JOINs (without selection).\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoin(entityOrProperty: Function|string, alias: string, condition: string = \"\", options?: JoinOptions): this {\n        return this.join(\"LEFT\", entityOrProperty, alias, condition, options);\n    }\n\n    /**\n     * INNER JOINs entity's property and adds all selection properties to SELECT.\n     * Given entity property should be a relation.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndSelect(property: string, alias: string, condition?: string, options?: JoinOptions): this;\n\n    /**\n     * INNER JOINs entity and adds all selection properties to SELECT.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndSelect(entity: Function|string, alias: string, condition?: string, options?: JoinOptions): this;\n\n    /**\n     * INNER JOINs table and adds all selection properties to SELECT.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndSelect(tableName: string, alias: string, condition?: string, options?: JoinOptions): this;\n\n    /**\n     * INNER JOINs and adds all selection properties to SELECT.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndSelect(entityOrProperty: Function|string, alias: string, condition: string = \"\", options?: JoinOptions): this {\n        this.addSelect(alias);\n        return this.join(\"INNER\", entityOrProperty, alias, condition, options);\n    }\n\n    /**\n     * LEFT JOINs entity's property and adds all selection properties to SELECT.\n     * Given entity property should be a relation.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndSelect(property: string, alias: string, condition?: string, options?: JoinOptions): this;\n\n    /**\n     * LEFT JOINs entity and adds all selection properties to SELECT.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndSelect(entity: Function|string, alias: string, condition?: string, options?: JoinOptions): this;\n\n    /**\n     * LEFT JOINs table and adds all selection properties to SELECT.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndSelect(tableName: string, alias: string, condition?: string, options?: JoinOptions): this;\n\n    /**\n     * LEFT JOINs and adds all selection properties to SELECT.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndSelect(entityOrProperty: Function|string, alias: string, condition: string = \"\", options?: JoinOptions): this {\n        this.addSelect(alias);\n        return this.join(\"LEFT\", entityOrProperty, alias, condition, options);\n    }\n\n    /**\n     * INNER JOINs entity's property, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\n     * Given entity property should be a relation.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndMapMany(mapToProperty: string, property: string, alias: string, condition?: string, options?: JoinOptions): this;\n\n    /**\n     * INNER JOINs entity's table, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndMapMany(mapToProperty: string, entity: Function|string, alias: string, condition?: string, options?: JoinOptions): this;\n\n    /**\n     * INNER JOINs table, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndMapMany(mapToProperty: string, tableName: string, alias: string, condition?: string, options?: JoinOptions): this;\n\n    /**\n     * INNER JOINs, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndMapMany(mapToProperty: string, entityOrProperty: Function|string, alias: string, condition: string = \"\", options?: JoinOptions): this {\n        this.addSelect(alias);\n        return this.join(\"INNER\", entityOrProperty, alias, condition, options, mapToProperty, true);\n    }\n\n    /**\n     * INNER JOINs entity's property, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\n     * Given entity property should be a relation.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndMapOne(mapToProperty: string, property: string, alias: string, condition?: string, options?: JoinOptions): this;\n\n    /**\n     * INNER JOINs entity's table, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndMapOne(mapToProperty: string, entity: Function|string, alias: string, condition?: string, options?: JoinOptions): this;\n\n    /**\n     * INNER JOINs table, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndMapOne(mapToProperty: string, tableName: string, alias: string, condition?: string, options?: JoinOptions): this;\n\n    /**\n     * INNER JOINs, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndMapOne(mapToProperty: string, entityOrProperty: Function|string, alias: string, condition: string = \"\", options?: JoinOptions): this {\n        this.addSelect(alias);\n        return this.join(\"INNER\", entityOrProperty, alias, condition, options, mapToProperty, false);\n    }\n\n    /**\n     * LEFT JOINs entity's property, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\n     * Given entity property should be a relation.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndMapMany(mapToProperty: string, property: string, alias: string, condition?: string, options?: JoinOptions): this;\n\n    /**\n     * LEFT JOINs entity's table, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndMapMany(mapToProperty: string, entity: Function|string, alias: string, condition?: string, options?: JoinOptions): this;\n\n    /**\n     * LEFT JOINs table, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndMapMany(mapToProperty: string, tableName: string, alias: string, condition?: string, options?: JoinOptions): this;\n\n    /**\n     * LEFT JOINs, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndMapMany(mapToProperty: string, entityOrProperty: Function|string, alias: string, condition: string = \"\", options?: JoinOptions): this {\n        this.addSelect(alias);\n        return this.join(\"LEFT\", entityOrProperty, alias, condition, options, mapToProperty, true);\n    }\n\n    /**\n     * LEFT JOINs entity's property, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\n     * Given entity property should be a relation.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndMapOne(mapToProperty: string, property: string, alias: string, condition?: string, options?: JoinOptions): this;\n\n    /**\n     * LEFT JOINs entity's table, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndMapOne(mapToProperty: string, entity: Function|string, alias: string, condition?: string, options?: JoinOptions): this;\n\n    /**\n     * LEFT JOINs table, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndMapOne(mapToProperty: string, tableName: string, alias: string, condition?: string, options?: JoinOptions): this;\n\n    /**\n     * LEFT JOINs, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndMapOne(mapToProperty: string, entityOrProperty: Function|string, alias: string, condition: string = \"\", options?: JoinOptions): this {\n        this.addSelect(alias);\n        return this.join(\"LEFT\", entityOrProperty, alias, condition, options, mapToProperty, false);\n    }\n\n    /**\n     * LEFT JOINs relation id.\n     * Optionally, you can add condition and parameters used in condition.\n     *\n     * @experimental\n     */\n    leftJoinRelationId(property: string, condition?: string): this {\n        return this.joinRelationId(\"LEFT\", undefined, property, condition);\n    }\n\n    /**\n     * INNER JOINs relation id.\n     * Optionally, you can add condition and parameters used in condition.\n     *\n     * @experimental\n     */\n    innerJoinRelationId(property: string, condition?: string): this {\n        return this.joinRelationId(\"INNER\", undefined, property, condition);\n    }\n\n    /**\n     * LEFT JOINs relation id and maps it into some entity's property.\n     * Optionally, you can add condition and parameters used in condition.\n     *\n     * @experimental\n     */\n    leftJoinRelationIdAndMap(mapToProperty: string, property: string, condition: string = \"\"): this {\n        return this.joinRelationId(\"INNER\", mapToProperty, property, condition);\n    }\n\n    /**\n     * INNER JOINs relation id and maps it into some entity's property.\n     * Optionally, you can add condition and parameters used in condition.\n     *\n     * @experimental\n     */\n    innerJoinRelationIdAndMap(mapToProperty: string, property: string, condition: string = \"\"): this {\n        return this.joinRelationId(\"INNER\", mapToProperty, property, condition);\n    }\n\n    /**\n     * Counts number of entities of entity's relation.\n     * Optionally, you can add condition and parameters used in condition.\n     *\n     * @experimental\n     */\n    countRelation(property: string, condition: string = \"\"): this {\n\n        const [parentAliasName, parentPropertyName] = property.split(\".\");\n        const alias = parentAliasName + \"_\" + parentPropertyName + \"_relation_count\";\n\n        const aliasObj = new Alias(alias);\n        this.aliasMap.addAlias(aliasObj);\n        aliasObj.parentAliasName = parentAliasName;\n        aliasObj.parentPropertyName = parentPropertyName;\n\n        const relationCountMeta: RelationCountMeta = {\n            condition: condition,\n            alias: aliasObj,\n            entities: []\n        };\n        this.relationCountMetas.push(relationCountMeta);\n        return this;\n    }\n\n    /**\n     * Counts number of entities of entity's relation and maps the value into some entity's property.\n     * Optionally, you can add condition and parameters used in condition.\n     *\n     * @experimental\n     */\n    countRelationAndMap(mapProperty: string, property: string, condition: string = \"\"): this {\n\n        const [parentAliasName, parentPropertyName] = property.split(\".\");\n        const alias = parentAliasName + \"_\" + parentPropertyName + \"_relation_count\";\n        const aliasObj = new Alias(alias);\n        this.aliasMap.addAlias(aliasObj);\n        aliasObj.parentAliasName = parentAliasName;\n        aliasObj.parentPropertyName = parentPropertyName;\n\n        const relationCountMeta: RelationCountMeta = {\n            mapToProperty: mapProperty,\n            condition: condition,\n            alias: aliasObj,\n            entities: []\n        };\n        this.relationCountMetas.push(relationCountMeta);\n        return this;\n    }\n\n    /**\n     * Sets WHERE condition in the query builder.\n     * If you had previously WHERE expression defined,\n     * calling this function will override previously set WHERE conditions.\n     * Additionally you can add parameters used in where expression.\n     */\n    where(where: string, parameters?: ObjectLiteral): this {\n        this.wheres.push({ type: \"simple\", condition: where });\n        if (parameters) this.setParameters(parameters);\n        return this;\n    }\n\n    /**\n     * Adds new AND WHERE condition in the query builder.\n     * Additionally you can add parameters used in where expression.\n     */\n    andWhere(where: string, parameters?: ObjectLiteral): this {\n        this.wheres.push({ type: \"and\", condition: where });\n        if (parameters) this.setParameters(parameters);\n        return this;\n    }\n\n    /**\n     * Adds new AND WHERE with conditions for the given ids.\n     *\n     * @experimental Maybe this method should be moved to repository?\n     */\n    andWhereInIds(ids: any[]): this {\n        const [whereExpression, parameters] = this.createWhereIdsExpression(ids);\n        this.andWhere(whereExpression, parameters);\n        return this;\n    }\n\n    /**\n     * Adds new OR WHERE condition in the query builder.\n     * Additionally you can add parameters used in where expression.\n     */\n    orWhere(where: string, parameters?: ObjectLiteral): this {\n        this.wheres.push({ type: \"or\", condition: where });\n        if (parameters) this.setParameters(parameters);\n        return this;\n    }\n\n    /**\n     * Adds new OR WHERE with conditions for the given ids.\n     *\n     * @experimental Maybe this method should be moved to repository?\n     */\n    orWhereInIds(ids: any[]): this {\n        const [whereExpression, parameters] = this.createWhereIdsExpression(ids);\n        this.orWhere(whereExpression, parameters);\n        return this;\n    }\n\n    /**\n     * Sets HAVING condition in the query builder.\n     * If you had previously HAVING expression defined,\n     * calling this function will override previously set HAVING conditions.\n     * Additionally you can add parameters used in where expression.\n     */\n    having(having: string, parameters?: ObjectLiteral): this {\n        this.havings.push({ type: \"simple\", condition: having });\n        if (parameters) this.setParameters(parameters);\n        return this;\n    }\n\n    /**\n     * Adds new AND HAVING condition in the query builder.\n     * Additionally you can add parameters used in where expression.\n     */\n    andHaving(having: string, parameters?: ObjectLiteral): this {\n        this.havings.push({ type: \"and\", condition: having });\n        if (parameters) this.setParameters(parameters);\n        return this;\n    }\n\n    /**\n     * Adds new OR HAVING condition in the query builder.\n     * Additionally you can add parameters used in where expression.\n     */\n    orHaving(having: string, parameters?: ObjectLiteral): this {\n        this.havings.push({ type: \"or\", condition: having });\n        if (parameters) this.setParameters(parameters);\n        return this;\n    }\n\n    /**\n     * Sets GROUP BY condition in the query builder.\n     * If you had previously GROUP BY expression defined,\n     * calling this function will override previously set GROUP BY conditions.\n     */\n    groupBy(groupBy: string): this {\n        this.groupBys = [groupBy];\n        return this;\n    }\n\n    /**\n     * Adds GROUP BY condition in the query builder.\n     */\n    addGroupBy(groupBy: string): this {\n        this.groupBys.push(groupBy);\n        return this;\n    }\n\n    /**\n     * Sets ORDER BY condition in the query builder.\n     * If you had previously ORDER BY expression defined,\n     * calling this function will override previously set ORDER BY conditions.\n     */\n    orderBy(sort: string, order: \"ASC\"|\"DESC\" = \"ASC\"): this {\n        this.orderBys = { [sort]: order };\n        return this;\n    }\n\n    /**\n     * Adds ORDER BY condition in the query builder.\n     */\n    addOrderBy(sort: string, order: \"ASC\"|\"DESC\" = \"ASC\"): this {\n        this.orderBys[sort] = order;\n        return this;\n    }\n\n    /**\n     * Set's LIMIT - maximum number of rows to be selected.\n     * NOTE that it may not work as you expect if you are using joins.\n     * If you want to implement pagination, and you are having join in your query,\n     * then use instead setMaxResults instead.\n     */\n    setLimit(limit: number): this {\n        this.limit = limit;\n        return this;\n    }\n\n    /**\n     * Set's OFFSET - selection offset.\n     * NOTE that it may not work as you expect if you are using joins.\n     * If you want to implement pagination, and you are having join in your query,\n     * then use instead setFirstResult instead.\n     */\n    setOffset(offset: number): this {\n        this.offset = offset;\n        return this;\n    }\n\n    /**\n     * Set's maximum number of entities to be selected.\n     */\n    setMaxResults(maxResults: number): this {\n        this.maxResults = maxResults;\n        return this;\n    }\n\n    /**\n     * Set's offset of entities to be selected.\n     */\n    setFirstResult(firstResult: number): this {\n        this.firstResult = firstResult;\n        return this;\n    }\n\n    /**\n     * Sets given parameter's value.\n     */\n    setParameter(key: string, value: any): this {\n        this.parameters[key] = value;\n        return this;\n    }\n\n    /**\n     * Adds all parameters from the given object.\n     * Unlike setParameters method it does not clear all previously set parameters.\n     */\n    setParameters(parameters: ObjectLiteral): this {\n        Object.keys(parameters).forEach(key => {\n            this.parameters[key] = parameters[key];\n        });\n        return this;\n    }\n\n    /**\n     * Adds all parameters from the given object.\n     * Unlike setParameters method it does not clear all previously set parameters.\n     *\n     * @deprecated use setParameters instead\n     */\n    addParameters(parameters: ObjectLiteral): this {\n        Object.keys(parameters).forEach(key => {\n            this.parameters[key] = parameters[key];\n        });\n        return this;\n    }\n\n    /**\n     * Gets all parameters.\n     */\n    getParameters(): ObjectLiteral {\n        const parameters: ObjectLiteral = Object.assign({}, this.parameters);\n\n        // add discriminator column parameter if it exist\n        if (!this.fromTableName) {\n            const mainMetadata = this.connection.getMetadata(this.aliasMap.mainAlias.target);\n            if (mainMetadata.hasDiscriminatorColumn)\n                parameters[\"discriminatorColumnValue\"] = mainMetadata.discriminatorValue;\n        }\n\n        return parameters;\n    }\n\n    /**\n     * Gets generated sql that will be executed.\n     * Parameters in the query are escaped for the currently used driver.\n     */\n    getSql(): string {\n        let sql = this.createSelectExpression();\n        sql += this.createJoinExpression();\n        sql += this.createJoinRelationIdsExpression();\n        sql += this.createWhereExpression();\n        sql += this.createGroupByExpression();\n        sql += this.createHavingExpression();\n        sql += this.createOrderByExpression();\n        sql += this.createLimitExpression();\n        sql += this.createOffsetExpression();\n        [sql] = this.connection.driver.escapeQueryWithParameters(sql, this.parameters);\n        return sql;\n    }\n\n    /**\n     * Gets generated sql without parameters being replaced.\n     *\n     * @experimental\n     */\n    getGeneratedQuery(): string {\n        let sql = this.createSelectExpression();\n        sql += this.createJoinExpression();\n        sql += this.createJoinRelationIdsExpression();\n        sql += this.createWhereExpression();\n        sql += this.createGroupByExpression();\n        sql += this.createHavingExpression();\n        sql += this.createOrderByExpression();\n        sql += this.createLimitExpression();\n        sql += this.createOffsetExpression();\n        return sql;\n    }\n\n    /**\n     * Gets sql to be executed with all parameters used in it.\n     *\n     * @experimental\n     */\n    getSqlWithParameters(options?: { skipOrderBy?: boolean }): [string, any[]] {\n        let sql = this.createSelectExpression();\n        sql += this.createJoinExpression();\n        sql += this.createJoinRelationIdsExpression();\n        sql += this.createWhereExpression();\n        sql += this.createGroupByExpression();\n        sql += this.createHavingExpression();\n        if (!options || !options.skipOrderBy)\n            sql += this.createOrderByExpression();\n        sql += this.createLimitExpression();\n        sql += this.createOffsetExpression();\n        return this.connection.driver.escapeQueryWithParameters(sql, this.getParameters());\n    }\n\n    /**\n     * Executes sql generated by query builder and returns raw database results.\n     */\n    async execute(): Promise<any> {\n        const queryRunner = await this.getQueryRunner();\n        const [sql, parameters] = this.getSqlWithParameters();\n        try {\n            return await queryRunner.query(sql, parameters);  // await is needed here because we are using finally\n\n        } finally {\n            if (this.hasOwnQueryRunner()) // means we created our own query runner\n                await queryRunner.release();\n        }\n    }\n\n    /**\n     * Executes sql generated by query builder and returns object with raw results and entities created from them.\n     */\n    async getEntitiesAndRawResults(): Promise<{ entities: Entity[], rawResults: any[] }> {\n        if (!this.aliasMap.hasMainAlias)\n            throw new Error(`Alias is not set. Looks like nothing is selected. Use select*, delete, update method to set an alias.`);\n\n        const queryRunner = await this.getQueryRunner();\n\n        const mainAliasName = this.fromTableName ? this.fromTableName : this.aliasMap.mainAlias.name;\n        let rawResults: any[];\n        if (this.firstResult || this.maxResults) {\n            // we are skipping order by here because its not working in subqueries anyway\n            // to make order by working we need to apply it on a distinct query\n            const [sql, parameters] = this.getSqlWithParameters({ skipOrderBy: true });\n            const [selects, orderBys] = this.createOrderByCombinedWithSelectExpression(\"distinctAlias\");\n\n            const distinctAlias = this.connection.driver.escapeTableName(\"distinctAlias\");\n            const metadata = this.connection.getMetadata(this.fromEntity.alias.target);\n            let idsQuery = `SELECT `;\n            idsQuery += metadata.primaryColumns.map((primaryColumn, index) => {\n                const propertyName = this.connection.driver.escapeAliasName(mainAliasName + \"_\" + primaryColumn.name);\n                if (index === 0) {\n                    return `DISTINCT(${distinctAlias}.${propertyName}) as ids_${primaryColumn.name}`;\n                } else {\n                    return `${distinctAlias}.${propertyName}) as ids_${primaryColumn.name}`;\n                }\n            }).join(\", \");\n            if (selects.length > 0)\n                idsQuery += \", \" + selects;\n\n            idsQuery += ` FROM (${sql}) ${distinctAlias}`; // TODO: WHAT TO DO WITH PARAMETERS HERE? DO THEY WORK?\n\n            if (orderBys.length > 0) {\n                idsQuery += \" ORDER BY \" + orderBys;\n            } else {\n                idsQuery += ` ORDER BY \"ids_${metadata.firstPrimaryColumn.name}\"`; // this is required for mssql driver if firstResult is used. Other drivers don't care about it\n            }\n\n            if (this.connection.driver instanceof SqlServerDriver) { // todo: temporary. need to refactor and make a proper abstraction\n\n                if (this.firstResult || this.maxResults) {\n                    idsQuery += ` OFFSET ${this.firstResult || 0} ROWS`;\n                    if (this.maxResults)\n                        idsQuery += \" FETCH NEXT \" + this.maxResults + \" ROWS ONLY\";\n                }\n            } else {\n\n                if (this.maxResults)\n                    idsQuery += \" LIMIT \" + this.maxResults;\n                if (this.firstResult)\n                    idsQuery += \" OFFSET \" + this.firstResult;\n            }\n\n            try {\n                return await queryRunner.query(idsQuery, parameters)\n                    .then((results: any[]) => {\n                        rawResults = results;\n                        if (results.length === 0)\n                            return [];\n\n                        let condition = \"\";\n                        const parameters: ObjectLiteral = {};\n                        if (metadata.hasMultiplePrimaryKeys) {\n                            condition = results.map(result => {\n                                return metadata.primaryColumns.map(primaryColumn => {\n                                    parameters[\"ids_\" + primaryColumn.propertyName] = result[\"ids_\" + primaryColumn.propertyName];\n                                    return mainAliasName + \".\" + primaryColumn.propertyName + \"=:ids_\" + primaryColumn.propertyName;\n                                }).join(\" AND \");\n                            }).join(\" OR \");\n                        } else {\n                            const ids = results.map(result => result[\"ids_\" + metadata.firstPrimaryColumn.propertyName]);\n                            const areAllNumbers = ids.map((id: any) => typeof id === \"number\");\n                            if (areAllNumbers) {\n                                // fixes #190. if all numbers then its safe to perform query without parameter\n                                condition = `${mainAliasName}.${metadata.firstPrimaryColumn.propertyName} IN (${ids.join(\", \")})`;\n                            } else {\n                                parameters[\"ids\"] = ids;\n                                condition = mainAliasName + \".\" + metadata.firstPrimaryColumn.propertyName + \" IN (:ids)\";\n                            }\n                        }\n                        const [queryWithIdsSql, queryWithIdsParameters] = this.clone({queryRunnerProvider: this.queryRunnerProvider})\n                            .andWhere(condition, parameters)\n                            .getSqlWithParameters();\n                        return (queryRunner as QueryRunner).query(queryWithIdsSql, queryWithIdsParameters);\n                    })\n                    .then(results => {\n                        return this.rawResultsToEntities(results);\n                    })\n                    .then(results => {\n\n                        return this.loadRelationCounts(queryRunner as QueryRunner, results)\n                            .then(counts => {\n                                // console.log(\"counts: \", counts);\n                                return results;\n                            });\n                    })\n                    .then(results => {\n                        if (!this.fromTableName)\n                            return this.connection.broadcaster.broadcastLoadEventsForAll(this.aliasMap.mainAlias.target, results).then(() => results);\n\n                        return results;\n                    })\n                    .then(results => {\n                        return {\n                            entities: results,\n                            rawResults: rawResults\n                        };\n                    });\n\n            } finally {\n                if (this.hasOwnQueryRunner()) // means we created our own query runner\n                    await queryRunner.release();\n            }\n\n        } else {\n\n            const [sql, parameters] = this.getSqlWithParameters();\n\n            try {\n                // console.log(sql);\n                return await queryRunner.query(sql, parameters)\n                    .then(results => {\n                        rawResults = results;\n                        return this.rawResultsToEntities(results);\n                    })\n                    .then(results => {\n\n                        return this.loadRelationCounts(queryRunner as QueryRunner, results)\n                            .then(counts => {\n                                // console.log(\"counts: \", counts);\n                                return results;\n                            });\n                    })\n                    .then(results => {\n                        if (!this.fromTableName) {\n                            return this.connection.broadcaster\n                                .broadcastLoadEventsForAll(this.aliasMap.mainAlias.target, results)\n                                .then(() => results);\n                        }\n                        return results;\n                    })\n                    .then(results => {\n                        return {\n                            entities: results,\n                            rawResults: rawResults\n                        };\n                    });\n\n            } finally {\n                if (this.hasOwnQueryRunner()) // means we created our own query runner\n                    await queryRunner.release();\n            }\n        }\n    }\n\n    /**\n     * Gets count - number of entities selected by sql generated by this query builder.\n     * Count excludes all limitations set by setFirstResult and setMaxResults methods call.\n     */\n    async getCount(): Promise<number> {\n\n        const queryRunner = await this.getQueryRunner();\n\n        const mainAlias = this.fromTableName ? this.fromTableName : this.aliasMap.mainAlias.name; // todo: will this work with \"fromTableName\"?\n        const metadata = this.connection.getMetadata(this.fromEntity.alias.target);\n\n        const distinctAlias = this.connection.driver.escapeAliasName(mainAlias);\n        let countSql = `COUNT(` + metadata.primaryColumnsWithParentIdColumns.map((primaryColumn, index) => {\n                const propertyName = this.connection.driver.escapeColumnName(primaryColumn.name);\n                if (index === 0) {\n                    return `DISTINCT(${distinctAlias}.${propertyName})`;\n                } else {\n                    return `${distinctAlias}.${propertyName})`;\n                }\n            }).join(\", \") + \") as cnt\";\n\n        const countQuery = this\n            .clone({\n                queryRunnerProvider: this.queryRunnerProvider,\n                skipOrderBys: true,\n                ignoreParentTablesJoins: true,\n                skipLimit: true,\n                skipOffset: true\n            })\n            .select(countSql);\n\n        const [countQuerySql, countQueryParameters] = countQuery.getSqlWithParameters();\n\n        try {\n            const results = await queryRunner.query(countQuerySql, countQueryParameters);\n            if (!results || !results[0] || !results[0][\"cnt\"])\n                return 0;\n\n            return parseInt(results[0][\"cnt\"]);\n\n        } finally {\n            if (this.hasOwnQueryRunner()) // means we created our own query runner\n                await queryRunner.release();\n        }\n    }\n\n    /**\n     * Gets all raw results returned by execution of generated query builder sql.\n     */\n    getRawMany(): Promise<any[]> { // todo: rename to getRawMany\n        return this.execute();\n    }\n\n    /**\n     * Gets first raw result returned by execution of generated query builder sql.\n     */\n    getRawOne(): Promise<any> { // todo: rename to getRawOne\n        return this.getRawMany().then(results => results[0]);\n\n    }\n\n    /**\n     * Gets entities and count returned by execution of generated query builder sql.\n     */\n    getManyAndCount(): Promise<[Entity[], number]> {\n        // todo: share database connection and counter\n        return Promise.all<any>([\n            this.getMany(),\n            this.getCount()\n        ]);\n    }\n\n    /**\n     * Gets entities returned by execution of generated query builder sql.\n     */\n    getMany(): Promise<Entity[]> {\n        return this.getEntitiesAndRawResults().then(results => {\n            return results.entities;\n        });\n    }\n\n    /**\n     * Gets single entity returned by execution of generated query builder sql.\n     */\n    getOne(): Promise<Entity|undefined> {\n        return this.getMany().then(entities => entities[0]);\n    }\n\n    /**\n     * Clones query builder as it is.\n     */\n    clone(options?: { queryRunnerProvider?: QueryRunnerProvider, skipOrderBys?: boolean, skipLimit?: boolean, skipOffset?: boolean, ignoreParentTablesJoins?: boolean }): QueryBuilder<Entity> {\n        const qb = new QueryBuilder(this.connection, options ? options.queryRunnerProvider : undefined);\n        if (options && options.ignoreParentTablesJoins)\n            qb.ignoreParentTablesJoins = options.ignoreParentTablesJoins;\n\n        switch (this.type) {\n            case \"select\":\n                qb.select(this.selects);\n                break;\n            case \"update\":\n                qb.update(this.updateQuerySet);\n                break;\n            case \"delete\":\n                qb.delete();\n                break;\n        }\n\n        if (this.fromEntity && this.fromEntity.alias && this.fromEntity.alias.target) {\n            qb.from(this.fromEntity.alias.target, this.fromEntity.alias.name);\n\n        } else if (this.fromTableName) {\n            qb.fromTable(this.fromTableName, this.fromTableAlias);\n        }\n\n        this.joins.forEach(join => {\n            const property = join.tableName || join.alias.target || (join.alias.parentAliasName + \".\" + join.alias.parentPropertyName);\n            qb.join(join.type, property, join.alias.name, join.condition || \"\", undefined, join.mapToProperty, join.isMappingMany);\n        });\n\n        this.groupBys.forEach(groupBy => qb.addGroupBy(groupBy));\n\n        this.wheres.forEach(where => {\n            switch (where.type) {\n                case \"simple\":\n                    qb.where(where.condition);\n                    break;\n                case \"and\":\n                    qb.andWhere(where.condition);\n                    break;\n                case \"or\":\n                    qb.orWhere(where.condition);\n                    break;\n            }\n        });\n\n        this.havings.forEach(having => {\n            switch (having.type) {\n                case \"simple\":\n                    qb.having(having.condition);\n                    break;\n                case \"and\":\n                    qb.andHaving(having.condition);\n                    break;\n                case \"or\":\n                    qb.orHaving(having.condition);\n                    break;\n            }\n        });\n\n        if (!options || !options.skipOrderBys)\n            Object.keys(this.orderBys).forEach(columnName => qb.addOrderBy(columnName, this.orderBys[columnName]));\n\n        Object.keys(this.parameters).forEach(key => qb.setParameter(key, this.parameters[key]));\n\n        if (!options || !options.skipLimit)\n            qb.setLimit(this.limit);\n\n        if (!options || !options.skipOffset)\n            qb.setOffset(this.offset);\n\n        qb.setFirstResult(this.firstResult)\n            .setMaxResults(this.maxResults);\n\n        return qb;\n    }\n\n    /**\n     * Enables special query builder options.\n     */\n    enableOption(option: \"RELATION_ID_VALUES\"): this {\n        switch (option) {\n            case \"RELATION_ID_VALUES\":\n                this.enableRelationIdValues = true;\n        }\n\n        return this;\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    protected loadRelationCounts(queryRunner: QueryRunner, results: Entity[]): Promise<{}> {\n\n        const promises = this.relationCountMetas.map(relationCountMeta => {\n            const parentAlias = relationCountMeta.alias.parentAliasName;\n            const foundAlias = this.aliasMap.findAliasByName(parentAlias);\n            if (!foundAlias)\n                throw new Error(`Alias \"${parentAlias}\" was not found`);\n\n            const parentMetadata = this.aliasMap.getEntityMetadataByAlias(foundAlias);\n            if (!parentMetadata)\n                throw new Error(\"Cannot get entity metadata for the given alias \" + foundAlias.name);\n\n            const relation = parentMetadata.findRelationWithPropertyName(relationCountMeta.alias.parentPropertyName);\n\n            const queryBuilder = new QueryBuilder(this.connection, this.queryRunnerProvider);\n            let condition = \"\";\n\n            const metadata = this.aliasMap.getEntityMetadataByAlias(relationCountMeta.alias);\n            if (!metadata)\n                throw new Error(\"Cannot get entity metadata for the given alias \" + relationCountMeta.alias.name);\n\n            let joinTableName: string = metadata.table.name;\n\n            const junctionMetadata = relation.junctionEntityMetadata;\n            const appendedCondition = relationCountMeta.condition ? \" AND \" + this.replacePropertyNames(relationCountMeta.condition) : \"\";\n\n            /*if (relation.isManyToMany) {\n             const junctionTable = junctionMetadata.table.name;\n             const junctionAlias = relationCountMeta.alias.parentAliasName + \"_\" + relationCountMeta.alias.name;\n             const joinAlias = relationCountMeta.alias.name;\n             const joinTable = relation.isOwning ? relation.joinTable : relation.inverseRelation.joinTable; // not sure if this is correct\n             const joinTableColumn = joinTable.referencedColumn.name; // not sure if this is correct\n             const inverseJoinColumnName = joinTable.inverseReferencedColumn.name; // not sure if this is correct\n\n             let condition1 = \"\", condition2 = \"\";\n             if (relation.isOwning) {\n             condition1 = junctionAlias + \".\" + junctionMetadata.columns[0].name + \"=\" + parentAlias + \".\" + joinTableColumn;\n             condition2 = joinAlias + \".\" + inverseJoinColumnName + \"=\" + junctionAlias + \".\" + junctionMetadata.columns[1].name;\n             } else {\n             condition1 = junctionAlias + \".\" + junctionMetadata.columns[1].name + \"=\" + parentAlias + \".\" + joinTableColumn;\n             condition2 = joinAlias + \".\" + inverseJoinColumnName + \"=\" + junctionAlias + \".\" + junctionMetadata.columns[0].name;\n             }\n\n             condition = \" LEFT JOIN \" + junctionTable + \" \" + junctionAlias + \" \" + relationCountMeta.conditionType + \" \" + condition1 +\n             \" LEFT JOIN \" + joinTableName + \" \" + joinAlias + \" \" + relationCountMeta.conditionType + \" \" + condition2 + appendedCondition;\n\n             } else if (relation.isManyToOne || (relation.isOneToOne && relation.isOwning)) {\n             const joinTableColumn = relation.joinColumn.referencedColumn.name;\n             const condition2 = relationCountMeta.alias.name + \".\" + joinTableColumn + \"=\" + parentAlias + \".\" + relation.name;\n             condition = \" LEFT JOIN \" + joinTableName + \" \" + relationCountMeta.alias.name + \" \" + relationCountMeta.conditionType + \" \" + condition2 + appendedCondition;\n\n             } else {\n             throw new Error(`Relation count can be applied only `); // this should be done on entity build\n             }*/\n\n            // if (relationCountMeta.condition)\n            //     condition += relationCountMeta.condition;\n            // relationCountMeta.alias.target;\n            // todo: FIX primaryColumn usages\n\n            const ids = relationCountMeta.entities\n                .map(entityWithMetadata => entityWithMetadata.metadata.getEntityIdMap(entityWithMetadata.entity))\n                .filter(idMap => idMap !== undefined)\n                .map(idMap => idMap![parentMetadata.primaryColumn.propertyName]);\n            if (!ids || !ids.length)\n                return Promise.resolve(); // todo: need to set zero to relationCount column in this case?\n\n            return queryBuilder\n                .select(`${parentMetadata.name + \".\" + parentMetadata.primaryColumn.propertyName} AS id`)\n                .addSelect(`COUNT(${ this.connection.driver.escapeAliasName(relation.propertyName) + \".\" + this.connection.driver.escapeColumnName(relation.inverseEntityMetadata.primaryColumn.name) }) as cnt`)\n                .from(parentMetadata.target, parentMetadata.name)\n                .leftJoin(parentMetadata.name + \".\" + relation.propertyName, relation.propertyName, relationCountMeta.condition)\n                .setParameters(this.parameters)\n                .where(`${parentMetadata.name + \".\" + parentMetadata.primaryColumn.propertyName} IN (:relationCountIds)`, {relationCountIds: ids})\n                .groupBy(parentMetadata.name + \".\" + parentMetadata.primaryColumn.propertyName)\n                .getRawMany()\n                .then((results: { id: any, cnt: any }[]) => {\n                    // console.log(relationCountMeta.entities);\n                    relationCountMeta.entities.forEach(entityWithMetadata => {\n                        const entityId = entityWithMetadata.entity[entityWithMetadata.metadata.primaryColumn.propertyName];\n                        const entityResult = results.find(result => {\n                            return entityId === this.connection.driver.prepareHydratedValue(result.id, entityWithMetadata.metadata.primaryColumn);\n                        });\n                        if (entityResult) {\n\n                            if (relationCountMeta.mapToProperty) {\n                                const [parentName, propertyName] = (relationCountMeta.mapToProperty as string).split(\".\");\n                                // todo: right now mapping is working only on the currently countRelation class, but\n                                // different properties are working. make different classes to work too\n                                entityWithMetadata.entity[propertyName] = parseInt(entityResult.cnt);\n\n                            } else if (relation.countField) {\n                                entityWithMetadata.entity[relation.countField] = parseInt(entityResult.cnt);\n                            }\n                        }\n                    });\n                });\n        });\n\n        return Promise.all(promises);\n    }\n\n    protected rawResultsToEntities(results: any[]) {\n        const transformer = new RawSqlResultsToEntityTransformer(this.connection.driver, this.aliasMap, this.extractJoinMappings(), this.relationCountMetas, this.enableRelationIdValues);\n        return transformer.transform(results);\n    }\n\n    protected createSelectExpression() {\n        // todo throw exception if selects or from is missing\n\n        let alias: string = \"\", tableName: string;\n        const allSelects: string[] = [];\n\n        if (this.fromTableName) {\n            tableName = this.fromTableName;\n            alias = this.fromTableAlias;\n            // console.log(\"ALIAS F:\", alias);\n\n        } else if (this.fromEntity) {\n            const metadata = this.aliasMap.getEntityMetadataByAlias(this.fromEntity.alias);\n            if (!metadata)\n                throw new Error(\"Cannot get entity metadata for the given alias \" + this.fromEntity.alias.name);\n            tableName = metadata.table.name;\n            alias = this.fromEntity.alias.name;\n            // console.log(\"ALIAS N:\", this.fromEntity.alias);\n            // console.log(\"ALIAS N:\", alias);\n\n            // add select from the main table\n            if (this.selects.indexOf(alias) !== -1) {\n                metadata.columns.forEach(column => {\n                    allSelects.push(this.connection.driver.escapeAliasName(alias) + \".\" + this.connection.driver.escapeColumnName(column.name) + \" AS \" + this.connection.driver.escapeAliasName(alias + \"_\" + column.name));\n                });\n            }\n\n        } else {\n            throw new Error(\"No from given\");\n        }\n\n        // add selects from joins\n        this.joins\n            .filter(join => this.selects.indexOf(join.alias.name) !== -1)\n            .forEach(join => {\n                const joinMetadata = this.aliasMap.getEntityMetadataByAlias(join.alias);\n                if (joinMetadata) {\n                    joinMetadata.columns.forEach(column => {\n                        allSelects.push(this.connection.driver.escapeAliasName(join.alias.name) + \".\" + this.connection.driver.escapeColumnName(column.name) + \" AS \" + this.connection.driver.escapeAliasName(join.alias.name + \"_\" + column.name));\n                    });\n                } else {\n                    allSelects.push(this.connection.driver.escapeAliasName(join.alias.name));\n                }\n            });\n\n        if (!this.ignoreParentTablesJoins && !this.fromTableName) {\n            const metadata = this.connection.getMetadata(this.aliasMap.mainAlias.target);\n            if (metadata.parentEntityMetadata && metadata.parentIdColumns) {\n                const alias = \"parentIdColumn_\" + this.connection.driver.escapeAliasName(metadata.parentEntityMetadata.table.name);\n                metadata.parentEntityMetadata.columns.forEach(column => {\n                    allSelects.push(alias + \".\" + this.connection.driver.escapeColumnName(column.name) + \" AS \" + alias + \"_\" + this.connection.driver.escapeAliasName(column.name));\n                });\n            }\n        }\n\n        // add selects from relation id joins\n        this.joinRelationIds.forEach(join => {\n            // const joinMetadata = this.aliasMap.getEntityMetadataByAlias(join.alias);\n\n            const parentAlias = join.alias.parentAliasName;\n            const foundAlias = this.aliasMap.findAliasByName(parentAlias);\n            if (!foundAlias)\n                throw new Error(`Alias \"${parentAlias}\" was not found`);\n\n            const parentMetadata = this.aliasMap.getEntityMetadataByAlias(foundAlias);\n            if (!parentMetadata)\n                throw new Error(\"Cannot get entity metadata for the given alias \" + foundAlias.name);\n            const relation = parentMetadata.findRelationWithPropertyName(join.alias.parentPropertyName);\n            const junctionMetadata = relation.junctionEntityMetadata;\n            // const junctionTable = junctionMetadata.table.name;\n\n            junctionMetadata.columns.forEach(column => {\n                allSelects.push(this.connection.driver.escapeAliasName(join.alias.name) + \".\" + this.connection.driver.escapeColumnName(column.name) + \" AS \" + this.connection.driver.escapeAliasName(join.alias.name + \"_\" + column.name));\n            });\n        });\n\n        //\n        /*if (this.enableRelationIdValues) {\n            const parentMetadata = this.aliasMap.getEntityMetadataByAlias(this.aliasMap.mainAlias);\n            if (!parentMetadata)\n                throw new Error(\"Cannot get entity metadata for the given alias \" + this.aliasMap.mainAlias.name);\n\n            const metadata = this.connection.entityMetadatas.findByTarget(this.aliasMap.mainAlias.target);\n            metadata.manyToManyRelations.forEach(relation => {\n\n                const junctionMetadata = relation.junctionEntityMetadata;\n                junctionMetadata.columns.forEach(column => {\n                    const select = this.connection.driver.escapeAliasName(this.aliasMap.mainAlias.name + \"_\" + junctionMetadata.table.name + \"_ids\") + \".\" +\n                        this.connection.driver.escapeColumnName(column.name) + \" AS \" +\n                        this.connection.driver.escapeAliasName(this.aliasMap.mainAlias.name + \"_\" + relation.name + \"_ids_\" + column.name);\n                    allSelects.push(select);\n                });\n            });\n        }*/\n\n        // add all other selects\n        this.selects.filter(select => {\n            return select !== alias && !this.joins.find(join => join.alias.name === select);\n        }).forEach(select => allSelects.push(this.replacePropertyNames(select)));\n\n        // if still selection is empty, then simply set it to all (*)\n        if (allSelects.length === 0)\n            allSelects.push(\"*\");\n\n        // create a selection query\n        switch (this.type) {\n            case \"select\":\n                return \"SELECT \" + allSelects.join(\", \") + \" FROM \" + this.connection.driver.escapeTableName(tableName) + \" \" + this.connection.driver.escapeAliasName(alias);\n            case \"delete\":\n                return \"DELETE FROM \" + this.connection.driver.escapeTableName(tableName);\n                // return \"DELETE \" + (alias ? this.connection.driver.escapeAliasName(alias) : \"\") + \" FROM \" + this.connection.driver.escapeTableName(tableName) + \" \" + (alias ? this.connection.driver.escapeAliasName(alias) : \"\"); // TODO: only mysql supports aliasing, so what to do with aliases in DELETE queries? right now aliases are used however we are relaying that they will always match a table names\n            case \"update\":\n                const updateSet = Object.keys(this.updateQuerySet).map(key => key + \"=:updateQuerySet_\" + key);\n                const params = Object.keys(this.updateQuerySet).reduce((object, key) => {\n                    // todo: map propertyNames to names ?\n                    (<any> object)[\"updateQuerySet_\" + key] = (<any> this.updateQuerySet)[key];\n                    return object;\n                }, {});\n                this.setParameters(params);\n                return \"UPDATE \" + tableName + \" \" + (alias ? this.connection.driver.escapeAliasName(alias) : \"\") + \" SET \" + updateSet;\n        }\n\n        throw new Error(\"No query builder type is specified.\");\n    }\n\n    protected createWhereExpression() {\n\n        const conditions = this.wheres.map((where, index) => {\n            switch (where.type) {\n                case \"and\":\n                    return (index > 0 ? \"AND \" : \"\") + this.replacePropertyNames(where.condition);\n                case \"or\":\n                    return (index > 0 ? \"OR \" : \"\") + this.replacePropertyNames(where.condition);\n                default:\n                    return this.replacePropertyNames(where.condition);\n            }\n        }).join(\" \");\n\n        if (!this.fromTableName) {\n            const mainMetadata = this.connection.getMetadata(this.aliasMap.mainAlias.target);\n            if (mainMetadata.hasDiscriminatorColumn)\n                return ` WHERE ${ conditions.length ? \"(\" + conditions + \") AND\" : \"\" } ${mainMetadata.discriminatorColumn.name}=:discriminatorColumnValue`;\n\n        }\n\n        if (!conditions.length) return \"\";\n        return \" WHERE \" + conditions;\n    }\n\n    /**\n     * Replaces all entity's propertyName to name in the given statement.\n     */\n    private replacePropertyNames(statement: string) {\n        this.aliasMap.aliases.forEach(alias => {\n            const metadata = this.aliasMap.getEntityMetadataByAlias(alias);\n            if (!metadata) return;\n            metadata.embeddeds.forEach(embedded => {\n                embedded.columns.forEach(column => {\n                    const expression = alias.name + \"\\\\.\" + embedded.propertyName + \"\\\\.\" + column.propertyName + \"([ =]|.{0}$)\";\n                    statement = statement.replace(new RegExp(expression, \"gm\"), this.connection.driver.escapeAliasName(alias.name) + \".\" + this.connection.driver.escapeColumnName(column.name) + \"$1\");\n                });\n                // todo: what about embedded relations here?\n            });\n            metadata.columns.filter(column => !column.isInEmbedded).forEach(column => {\n                const expression = alias.name + \"\\\\.\" + column.propertyName + \"([ =]|.{0}$)\";\n                statement = statement.replace(new RegExp(expression, \"gm\"), this.connection.driver.escapeAliasName(alias.name) + \".\" + this.connection.driver.escapeColumnName(column.name) + \"$1\");\n            });\n            metadata.relationsWithJoinColumns/*.filter(relation => !relation.isInEmbedded)*/.forEach(relation => {\n                const expression = alias.name + \"\\\\.\" + relation.propertyName + \"([ =]|.{0}$)\";\n                statement = statement.replace(new RegExp(expression, \"gm\"), this.connection.driver.escapeAliasName(alias.name) + \".\" + this.connection.driver.escapeColumnName(relation.name) + \"$1\");\n            });\n        });\n        return statement;\n    }\n\n    protected createJoinRelationIdsExpression() {\n        return this.joinRelationIds.map(join => {\n            const parentAlias = join.alias.parentAliasName;\n            const foundAlias = this.aliasMap.findAliasByName(parentAlias);\n            if (!foundAlias)\n                throw new Error(`Alias \"${parentAlias}\" was not found`);\n\n            const parentMetadata = this.aliasMap.getEntityMetadataByAlias(foundAlias);\n            if (!parentMetadata)\n                throw new Error(\"Cannot get entity metadata for the given alias \" + foundAlias.name);\n\n            const relation = parentMetadata.findRelationWithPropertyName(join.alias.parentPropertyName);\n            const junctionMetadata = relation.junctionEntityMetadata;\n            const junctionTable = junctionMetadata.table.name;\n            const junctionAlias = join.alias.name;\n            const joinTable = relation.isOwning ? relation.joinTable : relation.inverseRelation.joinTable; // not sure if this is correct\n            const joinTableColumn = joinTable.referencedColumn.name; // not sure if this is correct\n\n            let condition1 = \"\";\n            if (relation.isOwning) {\n                condition1 = this.connection.driver.escapeAliasName(junctionAlias) + \".\" + this.connection.driver.escapeColumnName(junctionMetadata.columns[0].name) + \"=\" + this.connection.driver.escapeAliasName(parentAlias) + \".\" + this.connection.driver.escapeColumnName(joinTableColumn);\n                // condition2 = joinAlias + \".\" + inverseJoinColumnName + \"=\" + junctionAlias + \".\" + junctionMetadata.columns[1].name;\n            } else {\n                condition1 = this.connection.driver.escapeAliasName(junctionAlias) + \".\" + this.connection.driver.escapeColumnName(junctionMetadata.columns[1].name) + \"=\" + this.connection.driver.escapeAliasName(parentAlias) + \".\" + this.connection.driver.escapeColumnName(joinTableColumn);\n                // condition2 = joinAlias + \".\" + inverseJoinColumnName + \"=\" + junctionAlias + \".\" + junctionMetadata.columns[0].name;\n            }\n\n            return \" \" + join.type + \" JOIN \" + junctionTable + \" \" + this.connection.driver.escapeAliasName(junctionAlias) + \" ON \" + condition1;\n            // \" \" + joinType + \" JOIN \" + joinTableName + \" \" + joinAlias + \" \" + join.conditionType + \" \" + condition2 + appendedCondition;\n            // console.log(join);\n            // return \" \" + join.type + \" JOIN \" + joinTableName + \" \" + join.alias.name + \" \" + (join.condition ? (join.conditionType + \" \" + join.condition) : \"\");\n        });\n    }\n\n    protected createJoinExpression() {\n        let joins = this.joins.map(join => {\n            const joinType = join.type; // === \"INNER\" ? \"INNER\" : \"LEFT\";\n            let joinTableName: string = join.tableName;\n            if (!joinTableName) {\n                const metadata = this.aliasMap.getEntityMetadataByAlias(join.alias);\n                if (!metadata)\n                    throw new Error(\"Cannot get entity metadata for the given alias \" + join.alias.name);\n\n                joinTableName = metadata.table.name;\n            }\n\n            const parentAlias = join.alias.parentAliasName;\n            if (!parentAlias) {\n                return \" \" + joinType + \" JOIN \" + this.connection.driver.escapeTableName(joinTableName) + \" \" + this.connection.driver.escapeAliasName(join.alias.name) + \" \" + (join.condition ? ( \"ON \" + this.replacePropertyNames(join.condition) ) : \"\");\n            }\n\n            const foundAlias = this.aliasMap.findAliasByName(parentAlias);\n            if (!foundAlias)\n                throw new Error(`Alias \"${parentAlias}\" was not found`);\n\n            const parentMetadata = this.aliasMap.getEntityMetadataByAlias(foundAlias);\n            if (!parentMetadata)\n                throw new Error(\"Cannot get entity metadata for the given alias \" + foundAlias.name);\n\n            const relation = parentMetadata.findRelationWithPropertyName(join.alias.parentPropertyName);\n            const junctionMetadata = relation.junctionEntityMetadata;\n            const appendedCondition = join.condition ? \" AND \" + this.replacePropertyNames(join.condition) : \"\";\n\n            if (relation.isManyToMany) {\n                const junctionTable = junctionMetadata.table.name;\n                const junctionAlias = join.alias.parentAliasName + \"_\" + join.alias.name;\n                const joinAlias = join.alias.name;\n                const joinTable = relation.isOwning ? relation.joinTable : relation.inverseRelation.joinTable;\n                const joinTableColumn = relation.isOwning ? joinTable.referencedColumn.name : joinTable.inverseReferencedColumn.name;\n                const inverseJoinColumnName = relation.isOwning ? joinTable.inverseReferencedColumn.name : joinTable.referencedColumn.name;\n\n                let condition1 = \"\", condition2 = \"\";\n                if (relation.isOwning) {\n                    condition1 = this.connection.driver.escapeAliasName(junctionAlias) + \".\" + this.connection.driver.escapeColumnName(junctionMetadata.columns[0].name) + \"=\" + this.connection.driver.escapeAliasName(parentAlias) + \".\" + this.connection.driver.escapeColumnName(joinTableColumn);\n                    condition2 = this.connection.driver.escapeAliasName(joinAlias) + \".\" + this.connection.driver.escapeColumnName(inverseJoinColumnName) + \"=\" + this.connection.driver.escapeAliasName(junctionAlias) + \".\" + this.connection.driver.escapeColumnName(junctionMetadata.columns[1].name);\n                } else {\n                    condition1 = this.connection.driver.escapeAliasName(junctionAlias) + \".\" + this.connection.driver.escapeColumnName(junctionMetadata.columns[1].name) + \"=\" + this.connection.driver.escapeAliasName(parentAlias) + \".\" + this.connection.driver.escapeColumnName(joinTableColumn);\n                    condition2 = this.connection.driver.escapeAliasName(joinAlias) + \".\" + this.connection.driver.escapeColumnName(inverseJoinColumnName) + \"=\" + this.connection.driver.escapeAliasName(junctionAlias) + \".\" + this.connection.driver.escapeColumnName(junctionMetadata.columns[0].name);\n                }\n\n                return \" \" + joinType + \" JOIN \" + this.connection.driver.escapeTableName(junctionTable) + \" \" + this.connection.driver.escapeAliasName(junctionAlias) + \" ON \" + condition1 +\n                       \" \" + joinType + \" JOIN \" + this.connection.driver.escapeTableName(joinTableName) + \" \" + this.connection.driver.escapeAliasName(joinAlias) + \" ON \" + condition2 + appendedCondition;\n\n            } else if (relation.isManyToOne || (relation.isOneToOne && relation.isOwning)) {\n                const joinTableColumn = relation.joinColumn.referencedColumn.name;\n                const condition = this.connection.driver.escapeAliasName(join.alias.name) + \".\" + this.connection.driver.escapeColumnName(joinTableColumn) + \"=\" + this.connection.driver.escapeAliasName(parentAlias) + \".\" + this.connection.driver.escapeColumnName(relation.name);\n                return \" \" + joinType + \" JOIN \" + this.connection.driver.escapeTableName(joinTableName) + \" \" + this.connection.driver.escapeAliasName(join.alias.name) + \" ON \" + condition + appendedCondition;\n\n            } else if (relation.isOneToMany || (relation.isOneToOne && !relation.isOwning)) {\n                const joinTableColumn = relation.inverseRelation.joinColumn.referencedColumn.name;\n                const condition = this.connection.driver.escapeAliasName(join.alias.name) + \".\" + this.connection.driver.escapeColumnName(relation.inverseRelation.name) + \"=\" + this.connection.driver.escapeAliasName(parentAlias) + \".\" + this.connection.driver.escapeColumnName(joinTableColumn);\n                return \" \" + joinType + \" JOIN \" + this.connection.driver.escapeTableName(joinTableName) + \" \" + this.connection.driver.escapeAliasName(join.alias.name) + \" ON \" + condition + appendedCondition;\n\n            } else {\n                throw new Error(\"Unexpected relation type\"); // this should not be possible\n            }\n        }).join(\" \");\n\n        if (!this.ignoreParentTablesJoins && !this.fromTableName) {\n            const metadata = this.connection.getMetadata(this.aliasMap.mainAlias.target);\n            if (metadata.parentEntityMetadata && metadata.parentIdColumns) {\n                const alias = this.connection.driver.escapeAliasName(\"parentIdColumn_\" + metadata.parentEntityMetadata.table.name);\n                joins += \" JOIN \" + this.connection.driver.escapeTableName(metadata.parentEntityMetadata.table.name)\n                    + \" \" + alias + \" ON \";\n                joins += metadata.parentIdColumns.map(parentIdColumn => {\n                    return this.aliasMap.mainAlias.name + \".\" + parentIdColumn.name + \"=\" + alias + \".\" + parentIdColumn.propertyName;\n                });\n            }\n        }\n\n        /*if (this.enableRelationIdValues) {\n            const parentMetadata = this.aliasMap.getEntityMetadataByAlias(this.aliasMap.mainAlias);\n            if (!parentMetadata)\n                throw new Error(\"Cannot get entity metadata for the given alias \" + this.aliasMap.mainAlias.name);\n\n            const metadata = this.connection.entityMetadatas.findByTarget(this.aliasMap.mainAlias.target);\n            joins += metadata.manyToManyRelations.map(relation => {\n\n                const junctionMetadata = relation.junctionEntityMetadata;\n                const junctionTable = junctionMetadata.table.name;\n                const junctionAlias = this.aliasMap.mainAlias.name + \"_\" + junctionTable + \"_ids\";\n                const joinTable = relation.isOwning ? relation.joinTable : relation.inverseRelation.joinTable; // not sure if this is correct\n                const joinTableColumn = joinTable.referencedColumn.name; // not sure if this is correct\n\n                let condition1 = \"\";\n                if (relation.isOwning) {\n                    condition1 = this.connection.driver.escapeAliasName(junctionAlias) + \".\" +\n                        this.connection.driver.escapeColumnName(junctionMetadata.columns[0].name) + \"=\" +\n                        this.connection.driver.escapeAliasName(this.aliasMap.mainAlias.name) + \".\" +\n                        this.connection.driver.escapeColumnName(joinTableColumn);\n                } else {\n                    condition1 = this.connection.driver.escapeAliasName(junctionAlias) + \".\" +\n                        this.connection.driver.escapeColumnName(junctionMetadata.columns[1].name) + \"=\" +\n                        this.connection.driver.escapeAliasName(this.aliasMap.mainAlias.name) + \".\" +\n                        this.connection.driver.escapeColumnName(joinTableColumn);\n                }\n\n                return \" LEFT JOIN \" + junctionTable + \" \" + this.connection.driver.escapeAliasName(junctionAlias) + \" ON \" + condition1;\n            }).join(\" \");\n        }*/\n\n        return joins;\n    }\n\n    protected createGroupByExpression() {\n        if (!this.groupBys || !this.groupBys.length) return \"\";\n        return \" GROUP BY \" + this.replacePropertyNames(this.groupBys.join(\", \"));\n    }\n\n    protected createHavingExpression() {\n        if (!this.havings || !this.havings.length) return \"\";\n        return \" HAVING \" + this.havings.map(having => {\n                switch (having.type) {\n                    case \"and\":\n                        return \" AND \" + this.replacePropertyNames(having.condition);\n                    case \"or\":\n                        return \" OR \" + this.replacePropertyNames(having.condition);\n                    default:\n                        return \" \" + this.replacePropertyNames(having.condition);\n                }\n            }).join(\" \");\n    }\n\n    protected createOrderByCombinedWithSelectExpression(parentAlias: string) {\n\n        // if table has a default order then apply it\n        let orderBys = this.orderBys;\n        if (!Object.keys(orderBys).length && !this.fromTableName) {\n            const metadata = this.connection.getMetadata(this.aliasMap.mainAlias.target);\n            orderBys = metadata.table.orderBy || {};\n        }\n\n        const selectString = Object.keys(orderBys)\n            .map(columnName => {\n                const [alias, column, ...embeddedProperties] = columnName.split(\".\");\n                return this.connection.driver.escapeAliasName(parentAlias) + \".\" + this.connection.driver.escapeColumnName(alias + \"_\" + column + embeddedProperties.join(\"_\"));\n            })\n            .join(\", \");\n\n        const orderByString = Object.keys(orderBys)\n            .map(columnName => {\n                const [alias, column, ...embeddedProperties] = columnName.split(\".\");\n                return this.connection.driver.escapeAliasName(parentAlias) + \".\" + this.connection.driver.escapeColumnName(alias + \"_\" + column + embeddedProperties.join(\"_\")) + \" \" + this.orderBys[columnName];\n            })\n            .join(\", \");\n\n        return [selectString, orderByString];\n    }\n\n    protected createOrderByExpression() {\n\n        let orderBys = this.orderBys;\n\n        // if table has a default order then apply it\n        if (!Object.keys(orderBys).length && !this.fromTableName) {\n            const metadata = this.connection.getMetadata(this.aliasMap.mainAlias.target);\n            orderBys = metadata.table.orderBy || {};\n        }\n\n        // if user specified a custom order then apply it\n        if (Object.keys(orderBys).length > 0)\n            return \" ORDER BY \" + Object.keys(orderBys)\n                    .map(columnName => {\n                        return this.replacePropertyNames(columnName) + \" \" + this.orderBys[columnName];\n                    })\n                    .join(\", \");\n\n        return \"\";\n    }\n\n    protected createLimitExpression() {\n        if (!this.limit) return \"\";\n        return \" LIMIT \" + this.limit;\n    }\n\n    protected createOffsetExpression() {\n        if (!this.offset) return \"\";\n        return \" OFFSET \" + this.offset;\n    }\n\n    private extractJoinMappings(): JoinMapping[] {\n        const mappings: JoinMapping[] = [];\n        this.joins\n            .filter(join => !!join.mapToProperty)\n            .forEach(join => {\n                const [parentName, propertyName] = (join.mapToProperty as string).split(\".\");\n                mappings.push({\n                    type: \"join\",\n                    alias: join.alias,\n                    parentName: parentName,\n                    propertyName: propertyName,\n                    isMany: join.isMappingMany\n                } as JoinMapping);\n            });\n\n        this.joinRelationIds\n            .filter(join => !!join.mapToProperty)\n            .forEach(join => {\n                const [parentName, propertyName] = (join.mapToProperty as string).split(\".\");\n                mappings.push({\n                    type: \"relationId\",\n                    alias: join.alias,\n                    parentName: parentName,\n                    propertyName: propertyName,\n                    isMany: false\n                });\n            });\n\n        return mappings;\n    }\n\n    protected join(joinType: \"INNER\"|\"LEFT\", property: string, alias: string, condition?: string, options?: JoinOptions, mapToProperty?: string, isMappingMany?: boolean): this;\n    protected join(joinType: \"INNER\"|\"LEFT\", entity: Function, alias: string, condition?: string, options?: JoinOptions, mapToProperty?: string, isMappingMany?: boolean): this;\n    protected join(joinType: \"INNER\"|\"LEFT\", entityOrProperty: Function|string, alias: string, condition: string, options?: JoinOptions, mapToProperty?: string, isMappingMany?: boolean): this;\n    protected join(joinType: \"INNER\"|\"LEFT\", entityOrProperty: Function|string, alias: string, condition: string = \"\", options?: JoinOptions, mapToProperty?: string, isMappingMany: boolean = false): this {\n\n        // todo: entityOrProperty can be a table name. implement if its a table\n        // todo: entityOrProperty can be target name. implement proper behaviour if it is.\n\n        let tableName = \"\";\n        const aliasObj = new Alias(alias);\n        this.aliasMap.addAlias(aliasObj);\n        if (entityOrProperty instanceof Function) {\n            aliasObj.target = entityOrProperty;\n\n        } else if (this.isPropertyAlias(entityOrProperty)) {\n            [aliasObj.parentAliasName, aliasObj.parentPropertyName] = entityOrProperty.split(\".\");\n\n        } else if (typeof entityOrProperty === \"string\") {\n            tableName = entityOrProperty;\n            if (!mapToProperty)\n                mapToProperty = entityOrProperty;\n        }\n\n        const join: Join = {\n            type: joinType,\n            alias: aliasObj,\n            tableName: tableName,\n            condition: condition,\n            options: options,\n            mapToProperty: mapToProperty,\n            isMappingMany: isMappingMany\n        };\n        this.joins.push(join);\n        return this;\n    }\n\n    protected joinRelationId(joinType: \"LEFT\"|\"INNER\", mapToProperty: string|undefined, property: string, condition?: string): this {\n\n        if (!this.isPropertyAlias(property))\n            throw new Error(\"Only entity relations are allowed in the leftJoinRelationId operation\"); // todo: also check if that relation really has entityId\n\n        const [parentAliasName, parentPropertyName] = property.split(\".\");\n        const alias = parentAliasName + \"_\" + parentPropertyName + \"_relation_id\";\n\n        const aliasObj = new Alias(alias);\n        this.aliasMap.addAlias(aliasObj);\n        aliasObj.parentAliasName = parentAliasName;\n        aliasObj.parentPropertyName = parentPropertyName;\n\n        this.joinRelationIds.push({\n            type: joinType,\n            mapToProperty: mapToProperty,\n            alias: aliasObj,\n            condition: condition\n        });\n\n        return this;\n    }\n\n    private isValueSimpleString(str: any) {\n        return /^[A-Za-z0-9_-]+$/.test(str);\n    }\n\n    private isPropertyAlias(str: any): str is string {\n        if (!(typeof str === \"string\"))\n            return false;\n        if (str.indexOf(\".\") === -1)\n            return false;\n\n        const aliasName = str.split(\".\")[0];\n        const propertyName = str.split(\".\")[1];\n\n        if (!aliasName || !propertyName)\n            return false;\n\n        const aliasNameRegexp = /^[a-zA-Z0-9_-]+$/;\n        const propertyNameRegexp = aliasNameRegexp;\n        if (!aliasNameRegexp.test(aliasName) || !propertyNameRegexp.test(propertyName))\n            return false;\n\n        return true;\n    }\n\n    /**\n     * Creates \"WHERE\" expression and variables for the given \"ids\".\n     */\n    protected createWhereIdsExpression(ids: any[]): [string, ObjectLiteral] {\n        const metadata = this.connection.getMetadata(this.aliasMap.mainAlias.target);\n\n        // create shortcuts for better readability\n        const escapeAlias = (alias: string) => this.connection.driver.escapeAliasName(alias);\n        const escapeColumn = (column: string) => this.connection.driver.escapeColumnName(column);\n\n        const alias = this.aliasMap.mainAlias.name;\n        const parameters: ObjectLiteral = {};\n        const whereStrings = ids.map((id, index) => {\n            const whereSubStrings: string[] = [];\n            if (metadata.hasMultiplePrimaryKeys) {\n                metadata.primaryColumns.forEach((primaryColumn, secondIndex) => {\n                    whereSubStrings.push(escapeAlias(alias) + \".\" + escapeColumn(primaryColumn.name) + \"=:id_\" + index + \"_\" + secondIndex);\n                    parameters[\"id_\" + index + \"_\" + secondIndex] = id[primaryColumn.name];\n                });\n                metadata.parentIdColumns.forEach((primaryColumn, secondIndex) => {\n                    whereSubStrings.push(escapeAlias(alias) + \".\" + escapeColumn(id[primaryColumn.name]) + \"=:parentId_\" + index + \"_\" + secondIndex);\n                    parameters[\"parentId_\" + index + \"_\" + secondIndex] = id[primaryColumn.propertyName];\n                });\n            } else {\n                if (metadata.primaryColumns.length > 0) {\n                    whereSubStrings.push(escapeAlias(alias) + \".\" + escapeColumn(metadata.firstPrimaryColumn.name) + \"=:id_\" + index);\n                    parameters[\"id_\" + index] = id;\n\n                } else if (metadata.parentIdColumns.length > 0) {\n                    whereSubStrings.push(escapeAlias(alias) + \".\" + escapeColumn(metadata.parentIdColumns[0].name) + \"=:parentId_\" + index);\n                    parameters[\"parentId_\" + index] = id;\n                }\n            }\n            return whereSubStrings.join(\" AND \");\n        });\n\n        const whereString = whereStrings.length > 1 ? \"(\" + whereStrings.join(\" OR \") + \")\" : whereStrings[0];\n        return [whereString, parameters];\n    }\n\n    protected async getQueryRunner(): Promise<QueryRunner> {\n\n        if (this.queryRunnerProvider instanceof QueryRunnerProvider) {\n            return this.queryRunnerProvider.provide();\n\n        } else { // means its empty\n            return this.connection.driver.createQueryRunner();\n        }\n    }\n\n    protected hasOwnQueryRunner(): boolean {\n        return !this.queryRunnerProvider;\n    }\n\n}\n"],"sourceRoot":".."}