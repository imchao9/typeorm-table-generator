{"version":3,"sources":["../../src/entity-manager/BaseEntityManager.ts"],"names":[],"mappings":"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","file":"BaseEntityManager.js","sourcesContent":["import {Connection} from \"../connection/Connection\";\nimport {QueryBuilder} from \"../query-builder/QueryBuilder\";\nimport {Repository} from \"../repository/Repository\";\nimport {ObjectType} from \"../common/ObjectType\";\nimport {TreeRepository} from \"../repository/TreeRepository\";\nimport {ObjectLiteral} from \"../common/ObjectLiteral\";\nimport {QueryRunnerProvider} from \"../query-runner/QueryRunnerProvider\";\nimport {RepositoryAggregator} from \"../repository/RepositoryAggregator\";\nimport {RepositoryNotTreeError} from \"../connection/error/RepositoryNotTreeError\";\nimport {NoNeedToReleaseEntityManagerError} from \"./error/NoNeedToReleaseEntityManagerError\";\nimport {QueryRunnerProviderAlreadyReleasedError} from \"../query-runner/error/QueryRunnerProviderAlreadyReleasedError\";\nimport {SpecificRepository} from \"../repository/SpecificRepository\";\n\n/**\n * Common functions shared between different entity manager types.\n */\nexport abstract class BaseEntityManager {\n\n    // -------------------------------------------------------------------------\n    // Private Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Stores all registered repositories.\n     * Used when custom queryRunnerProvider is provided.\n     */\n    private readonly repositoryAggregators: RepositoryAggregator[] = [];\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    /**\n     * @param connection Connection to be used in this entity manager\n     * @param queryRunnerProvider Custom query runner to be used for operations in this entity manager\n     */\n    constructor(protected connection: Connection,\n                protected queryRunnerProvider?: QueryRunnerProvider) {\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Gets repository for the given entity class.\n     * If single database connection mode is used, then repository is obtained from the\n     * repository aggregator, where each repository is individually created for this entity manager.\n     * When single database connection is not used, repository is being obtained from the connection.\n     */\n    getRepository<Entity>(entityClass: ObjectType<Entity>): Repository<Entity>;\n\n    /**\n     * Gets repository for the given entity name.\n     * If single database connection mode is used, then repository is obtained from the\n     * repository aggregator, where each repository is individually created for this entity manager.\n     * When single database connection is not used, repository is being obtained from the connection.\n     */\n    getRepository<Entity>(entityName: string): Repository<Entity>;\n\n    /**\n     * Gets repository for the given entity class or name.\n     * If single database connection mode is used, then repository is obtained from the\n     * repository aggregator, where each repository is individually created for this entity manager.\n     * When single database connection is not used, repository is being obtained from the connection.\n     */\n    getRepository<Entity>(entityClassOrName: ObjectType<Entity>|string): Repository<Entity> {\n\n        // if single db connection is used then create its own repository with reused query runner\n        if (this.queryRunnerProvider)\n            return this.obtainRepositoryAggregator(entityClassOrName as any).repository;\n\n        return this.connection.getRepository<Entity>(entityClassOrName as any);\n    }\n\n    /**\n     * Gets tree repository for the given entity class.\n     * If single database connection mode is used, then repository is obtained from the\n     * repository aggregator, where each repository is individually created for this entity manager.\n     * When single database connection is not used, repository is being obtained from the connection.\n     */\n    getTreeRepository<Entity>(entityClass: ObjectType<Entity>): TreeRepository<Entity>;\n\n    /**\n     * Gets tree repository for the given entity name.\n     * If single database connection mode is used, then repository is obtained from the\n     * repository aggregator, where each repository is individually created for this entity manager.\n     * When single database connection is not used, repository is being obtained from the connection.\n     */\n    getTreeRepository<Entity>(entityName: string): TreeRepository<Entity>;\n\n    /**\n     * Gets tree repository for the given entity class or name.\n     * If single database connection mode is used, then repository is obtained from the\n     * repository aggregator, where each repository is individually created for this entity manager.\n     * When single database connection is not used, repository is being obtained from the connection.\n     */\n    getTreeRepository<Entity>(entityClassOrName: ObjectType<Entity>|string): TreeRepository<Entity> {\n\n        // if single db connection is used then create its own repository with reused query runner\n        if (this.queryRunnerProvider) {\n            const treeRepository = this.obtainRepositoryAggregator(entityClassOrName).treeRepository;\n            if (!treeRepository)\n                throw new RepositoryNotTreeError(entityClassOrName);\n\n            return treeRepository;\n        }\n\n        return this.connection.getTreeRepository<Entity>(entityClassOrName as any);\n    }\n\n    /**\n     * Gets specific repository for the given entity class.\n     * If single database connection mode is used, then repository is obtained from the\n     * repository aggregator, where each repository is individually created for this entity manager.\n     * When single database connection is not used, repository is being obtained from the connection.\n     */\n    getSpecificRepository<Entity>(entityClass: ObjectType<Entity>): SpecificRepository<Entity>;\n\n    /**\n     * Gets specific repository for the given entity name.\n     * If single database connection mode is used, then repository is obtained from the\n     * repository aggregator, where each repository is individually created for this entity manager.\n     * When single database connection is not used, repository is being obtained from the connection.\n     */\n    getSpecificRepository<Entity>(entityName: string): SpecificRepository<Entity>;\n\n    /**\n     * Gets specific repository for the given entity class or name.\n     * If single database connection mode is used, then repository is obtained from the\n     * repository aggregator, where each repository is individually created for this entity manager.\n     * When single database connection is not used, repository is being obtained from the connection.\n     */\n    getSpecificRepository<Entity>(entityClassOrName: ObjectType<Entity>|string): SpecificRepository<Entity> {\n\n        // if single db connection is used then create its own repository with reused query runner\n        if (this.queryRunnerProvider)\n            return this.obtainRepositoryAggregator(entityClassOrName).specificRepository;\n\n        return this.connection.getSpecificRepository<Entity>(entityClassOrName as any);\n    }\n\n    /**\n     * Gets custom entity repository marked with @EntityRepository decorator.\n     */\n    getCustomRepository<T>(customRepository: ObjectType<T>): T {\n        return this.connection.getCustomRepository<T>(customRepository);\n    }\n\n    /**\n     * Checks if entity has an id.\n     */\n    hasId(entity: Object): boolean;\n\n    /**\n     * Checks if entity of given schema name has an id.\n     */\n    hasId(target: string, entity: Object): boolean;\n\n    /**\n     * Checks if entity has an id by its Function type or schema name.\n     */\n    hasId(targetOrEntity: Object|string, maybeEntity?: Object): boolean {\n        const target = arguments.length === 2 ? targetOrEntity : targetOrEntity.constructor;\n        const entity = arguments.length === 2 ? <Object> maybeEntity : <Object> targetOrEntity;\n        return this.getRepository(target as any).hasId(entity);\n    }\n\n    /**\n     * Creates a new query builder that can be used to build an sql query.\n     */\n    createQueryBuilder<Entity>(entityClass: ObjectType<Entity>|Function|string, alias: string): QueryBuilder<Entity> {\n        return this.getRepository(entityClass as any).createQueryBuilder(alias);\n    }\n\n    /**\n     * Creates a new entity instance.\n     */\n    create<Entity>(entityClass: ObjectType<Entity>): Entity;\n\n    /**\n     * Creates a new entity instance and copies all entity properties from this object into a new entity.\n     * Note that it copies only properties that present in entity schema.\n     */\n    create<Entity>(entityClass: ObjectType<Entity>, plainObject: Object): Entity;\n\n    /**\n     * Creates a new entities and copies all entity properties from given objects into their new entities.\n     * Note that it copies only properties that present in entity schema.\n     */\n    create<Entity>(entityClass: ObjectType<Entity>, plainObjects: Object[]): Entity[];\n\n    /**\n     * Creates a new entity instance or instances.\n     * Can copy properties from the given object into new entities.\n     */\n    create<Entity>(entityClass: ObjectType<Entity>, plainObjectOrObjects?: Object|Object[]): Entity|Entity[] {\n        if (plainObjectOrObjects instanceof Array) {\n            return this.getRepository(entityClass).create(plainObjectOrObjects);\n\n        } else if (plainObjectOrObjects) {\n            return this.getRepository(entityClass).create(plainObjectOrObjects);\n\n        } else {\n            return this.getRepository(entityClass).create();\n        }\n    }\n\n    /**\n     * Creates a new entity from the given plan javascript object. If entity already exist in the database, then\n     * it loads it (and everything related to it), replaces all values with the new ones from the given object\n     * and returns this new entity. This new entity is actually a loaded from the db entity with all properties\n     * replaced from the new object.\n     */\n    preload<Entity>(entityClass: ObjectType<Entity>, object: Object): Promise<Entity> {\n        return this.getRepository(entityClass).preload(object);\n    }\n\n    /**\n     * Merges two entities into one new entity.\n     */\n    merge<Entity>(entityClass: ObjectType<Entity>, ...objects: ObjectLiteral[]): Entity { // todo: throw exception ie tntity manager is released\n        return <Entity> this.getRepository(entityClass).merge(...objects);\n    }\n\n    /**\n     * Releases all resources used by entity manager.\n     * This is used when entity manager is created with a single query runner,\n     * and this single query runner needs to be released after job with entity manager is done.\n     */\n    async release(): Promise<void> {\n        if (!this.queryRunnerProvider)\n            throw new NoNeedToReleaseEntityManagerError();\n\n        return this.queryRunnerProvider.releaseReused();\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Gets, or if does not exist yet, creates and returns a repository aggregator for a particular entity target.\n     */\n    protected obtainRepositoryAggregator<Entity>(entityClassOrName: ObjectType<Entity>|string): RepositoryAggregator {\n        if (this.queryRunnerProvider && this.queryRunnerProvider.isReleased)\n            throw new QueryRunnerProviderAlreadyReleasedError();\n\n        const metadata = this.connection.getMetadata(entityClassOrName);\n        let repositoryAggregator = this.repositoryAggregators.find(repositoryAggregate => repositoryAggregate.metadata === metadata);\n        if (!repositoryAggregator) {\n            repositoryAggregator = new RepositoryAggregator(\n                this.connection,\n                this.connection.getMetadata(entityClassOrName as any),\n                this.queryRunnerProvider\n            );\n            this.repositoryAggregators.push(repositoryAggregator); // todo: check isnt memory leak here?\n        }\n\n        return repositoryAggregator;\n    }\n\n}"],"sourceRoot":".."}