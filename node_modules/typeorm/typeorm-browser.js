var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t;
    return { next: verb(0), "throw": verb(1), "return": verb(2) };
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
System.register("typeorm/driver/DriverOptions", [], function (exports_1, context_1) {
    "use strict";
    var __moduleName = context_1 && context_1.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/metadata/types/ColumnTypes", [], function (exports_2, context_2) {
    "use strict";
    var __moduleName = context_2 && context_2.id;
    var ColumnTypes;
    return {
        setters: [],
        execute: function () {
            /**
             * All data types that column can be.
             */
            ColumnTypes = (function () {
                function ColumnTypes() {
                }
                /**
                 * Checks if given type in a string format is supported by ORM.
                 */
                ColumnTypes.isTypeSupported = function (type) {
                    return this.supportedTypes.indexOf(type) !== -1;
                };
                Object.defineProperty(ColumnTypes, "supportedTypes", {
                    /**
                     * Returns list of all supported types by the ORM.
                     */
                    get: function () {
                        return [
                            this.STRING,
                            this.TEXT,
                            this.NUMBER,
                            this.INTEGER,
                            this.INT,
                            this.SMALLINT,
                            this.BIGINT,
                            this.FLOAT,
                            this.DOUBLE,
                            this.DECIMAL,
                            this.DATE,
                            this.TIME,
                            this.DATETIME,
                            this.BOOLEAN,
                            this.JSON,
                            this.JSONB,
                            this.SIMPLE_ARRAY,
                            this.UUID
                        ];
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Tries to guess a column type from the given function.
                 */
                ColumnTypes.determineTypeFromFunction = function (type) {
                    if (type instanceof Date) {
                        return ColumnTypes.DATETIME;
                    }
                    else if (type instanceof Function) {
                        var typeName = type.name.toLowerCase();
                        switch (typeName) {
                            case "number":
                                return ColumnTypes.NUMBER;
                            case "boolean":
                                return ColumnTypes.BOOLEAN;
                            case "string":
                                return ColumnTypes.STRING;
                            case "date":
                                return ColumnTypes.DATETIME;
                            case "object":
                                return ColumnTypes.JSON;
                        }
                    }
                    else if (type instanceof Object) {
                        return ColumnTypes.JSON;
                    }
                    throw new Error("Column type of " + type + " cannot be determined.");
                    // return undefined;
                };
                ColumnTypes.typeToString = function (type) {
                    return type.name.toLowerCase();
                };
                /**
                 * Checks if column type is numeric.
                 */
                ColumnTypes.isNumeric = function (type) {
                    return type === ColumnTypes.NUMBER ||
                        type === ColumnTypes.INT ||
                        type === ColumnTypes.INTEGER ||
                        type === ColumnTypes.BIGINT ||
                        type === ColumnTypes.SMALLINT ||
                        type === ColumnTypes.DOUBLE ||
                        type === ColumnTypes.FLOAT;
                };
                return ColumnTypes;
            }());
            /**
             * SQL VARCHAR type. Your class's property type should be a "string".
             */
            ColumnTypes.STRING = "string";
            /**
             * SQL CLOB type. Your class's property type should be a "string".
             */
            ColumnTypes.TEXT = "text";
            /**
             * SQL FLOAT type. Your class's property type should be a "number".
             */
            ColumnTypes.NUMBER = "number";
            /**
             * SQL INT type. Your class's property type should be a "number".
             */
            ColumnTypes.INTEGER = "integer";
            /**
             * SQL INT type. Your class's property type should be a "number".
             */
            ColumnTypes.INT = "int";
            /**
             * SQL SMALLINT type. Your class's property type should be a "number".
             */
            ColumnTypes.SMALLINT = "smallint";
            /**
             * SQL BIGINT type. Your class's property type should be a "number".
             */
            ColumnTypes.BIGINT = "bigint";
            /**
             * SQL FLOAT type. Your class's property type should be a "number".
             */
            ColumnTypes.FLOAT = "float";
            /**
             * SQL FLOAT type. Your class's property type should be a "number".
             */
            ColumnTypes.DOUBLE = "double";
            /**
             * SQL DECIMAL type. Your class's property type should be a "string".
             */
            ColumnTypes.DECIMAL = "decimal";
            /**
             * SQL DATETIME type. Your class's property type should be a "Date" object.
             */
            ColumnTypes.DATE = "date";
            /**
             * SQL TIME type. Your class's property type should be a "Date" object.
             */
            ColumnTypes.TIME = "time";
            /**
             * SQL DATETIME/TIMESTAMP type. Your class's property type should be a "Date" object.
             */
            ColumnTypes.DATETIME = "datetime";
            /**
             * SQL BOOLEAN type. Your class's property type should be a "boolean".
             */
            ColumnTypes.BOOLEAN = "boolean";
            /**
             * SQL CLOB type. Your class's property type should be any Object.
             */
            ColumnTypes.JSON = "json";
            /**
             * Postgres jsonb type. Your class's property type should be any Object.
             */
            ColumnTypes.JSONB = "jsonb";
            /**
             * SQL CLOB type. Your class's property type should be array of string. Note: value in this column should not contain
             * a comma (",") since this symbol is used to create a string from the array, using .join(",") operator.
             */
            ColumnTypes.SIMPLE_ARRAY = "simple_array";
            /**
             * UUID type. Serialized to a string in typescript or javascript
             */
            ColumnTypes.UUID = "uuid";
            exports_2("ColumnTypes", ColumnTypes);
        }
    };
});
System.register("typeorm/decorator/options/ColumnOptions", [], function (exports_3, context_3) {
    "use strict";
    var __moduleName = context_3 && context_3.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/metadata-args/ColumnMetadataArgs", [], function (exports_4, context_4) {
    "use strict";
    var __moduleName = context_4 && context_4.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/metadata/types/TableTypes", [], function (exports_5, context_5) {
    "use strict";
    var __moduleName = context_5 && context_5.id;
    var TableTypes;
    return {
        setters: [],
        execute: function () {
            /**
             * Represents a class with constants - list of all possible table types.
             */
            TableTypes = (function () {
                function TableTypes() {
                }
                return TableTypes;
            }());
            /**
             * All non-specific tables are just regular tables. Its a default table type.
             */
            TableTypes.REGULAR = "regular";
            /**
             * This type is for the tables that does not exist in the database,
             * but provide columns and relations for the tables of the child classes who inherit them.
             */
            TableTypes.ABSTRACT = "abstract";
            /**
             * Junction table is a table automatically created by many-to-many relationship.
             */
            TableTypes.JUNCTION = "junction";
            /**
             * Closure table is one of the tree-specific tables that supports closure database pattern.
             */
            TableTypes.CLOSURE = "closure";
            /**
             * This type is for tables that contain junction metadata of the closure tables.
             */
            TableTypes.CLOSURE_JUNCTION = "closure-junction";
            /**
             * Embeddable tables are not stored in the database as separate tables.
             * Instead their columns are embed into tables who owns them.
             */
            TableTypes.EMBEDDABLE = "embeddable";
            /**
             * Special table type for tables that are mapped into single table using Single Table Inheritance pattern.
             */
            TableTypes.SINGLE_TABLE_CHILD = "single-table-child";
            /**
             * Special table type for tables that are mapped into multiple tables using Class Table Inheritance pattern.
             */
            TableTypes.CLASS_TABLE_CHILD = "class-table-child";
            exports_5("TableTypes", TableTypes);
        }
    };
});
System.register("typeorm/find-options/OrderByCondition", [], function (exports_6, context_6) {
    "use strict";
    var __moduleName = context_6 && context_6.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/metadata-args/TableMetadataArgs", [], function (exports_7, context_7) {
    "use strict";
    var __moduleName = context_7 && context_7.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/metadata/error/EntityMetadataAlreadySetError", [], function (exports_8, context_8) {
    "use strict";
    var __moduleName = context_8 && context_8.id;
    var EntityMetadataAlreadySetError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown when user tries to execute operation that requires connection to be established.
             */
            EntityMetadataAlreadySetError = (function (_super) {
                __extends(EntityMetadataAlreadySetError, _super);
                function EntityMetadataAlreadySetError(type, target, tableName) {
                    var _this = _super.call(this) || this;
                    _this.name = "EntityMetadataAlreadySetError";
                    var targetMessage = target ? " for " + (target instanceof Function ? target.constructor.name : target) : "";
                    var tableNameMessage = tableName ? " with " + tableName + " table name" : "";
                    _this.message = "Entity metadata" + targetMessage + tableNameMessage + " has been already set to this " + type.constructor.name;
                    return _this;
                }
                return EntityMetadataAlreadySetError;
            }(Error));
            exports_8("EntityMetadataAlreadySetError", EntityMetadataAlreadySetError);
        }
    };
});
System.register("typeorm/metadata/error/EntityMetadataNotSetError", [], function (exports_9, context_9) {
    "use strict";
    var __moduleName = context_9 && context_9.id;
    var EntityMetadataNotSetError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown when accessed to the class with entity metadata,
             * however on that time entity metadata is not set in the class.
             */
            EntityMetadataNotSetError = (function (_super) {
                __extends(EntityMetadataNotSetError, _super);
                function EntityMetadataNotSetError(type, target, tableName) {
                    var _this = _super.call(this) || this;
                    _this.name = "EntityMetadataNotSetError";
                    var targetMessage = target ? " for " + (target instanceof Function ? target.constructor.name : target) : "";
                    var tableNameMessage = tableName ? " with " + tableName + " table name" : "";
                    _this.message = "Entity metadata" + targetMessage + tableNameMessage + " is not set in " + type.constructor.name;
                    return _this;
                }
                return EntityMetadataNotSetError;
            }(Error));
            exports_9("EntityMetadataNotSetError", EntityMetadataNotSetError);
        }
    };
});
System.register("typeorm/metadata/TableMetadata", ["typeorm/metadata/types/TableTypes", "typeorm/metadata/error/EntityMetadataAlreadySetError", "typeorm/metadata/error/EntityMetadataNotSetError"], function (exports_10, context_10) {
    "use strict";
    var __moduleName = context_10 && context_10.id;
    var TableTypes_1, EntityMetadataAlreadySetError_1, EntityMetadataNotSetError_1, TableMetadata;
    return {
        setters: [
            function (TableTypes_1_1) {
                TableTypes_1 = TableTypes_1_1;
            },
            function (EntityMetadataAlreadySetError_1_1) {
                EntityMetadataAlreadySetError_1 = EntityMetadataAlreadySetError_1_1;
            },
            function (EntityMetadataNotSetError_1_1) {
                EntityMetadataNotSetError_1 = EntityMetadataNotSetError_1_1;
            }
        ],
        execute: function () {
            /**
             * TableMetadata contains all entity's table metadata and information.
             */
            TableMetadata = (function () {
                // ---------------------------------------------------------------------
                // Constructor
                // ---------------------------------------------------------------------
                /**
                 * Creates a new TableMetadata based on the given arguments object.
                 */
                function TableMetadata(args) {
                    // ---------------------------------------------------------------------
                    // Private Properties
                    // ---------------------------------------------------------------------
                    /**
                     * Table type. Tables can be abstract, closure, junction, embedded, etc.
                     */
                    this.tableType = "regular";
                    this.target = args.target;
                    this.tableType = args.type;
                    this._name = args.name;
                    this._orderBy = args.orderBy;
                    this.engine = args.engine;
                    this.skipSchemaSync = args.skipSchemaSync;
                }
                Object.defineProperty(TableMetadata.prototype, "entityMetadata", {
                    /**
                     * Gets entity metadata of this table metadata.
                     * If entity metadata was not set then exception will be thrown.
                     */
                    get: function () {
                        if (!this._entityMetadata)
                            throw new EntityMetadataNotSetError_1.EntityMetadataNotSetError(TableMetadata, this.target, this._name);
                        return this._entityMetadata;
                    },
                    // ---------------------------------------------------------------------
                    // Accessors
                    // ---------------------------------------------------------------------
                    /**
                     * Sets the entity metadata of this table metadata.
                     * Note that entity metadata can be set only once.
                     * Once you set it, you can't change it anymore.
                     */
                    set: function (metadata) {
                        if (this._entityMetadata)
                            throw new EntityMetadataAlreadySetError_1.EntityMetadataAlreadySetError(TableMetadata, this.target, this._name);
                        this._entityMetadata = metadata;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TableMetadata.prototype, "nameWithoutPrefix", {
                    /**
                     * Gets the table name without global table prefix.
                     * When querying table you need a table name with prefix, but in some scenarios,
                     * for example when you want to name a junction table that contains names of two other tables,
                     * you may want a table name without prefix.
                     */
                    get: function () {
                        if (this.isClosureJunction && this._name)
                            return this.entityMetadata.namingStrategy.closureJunctionTableName(this._name);
                        // otherwise generate table name from target's name
                        var name = this.target instanceof Function ? this.target.name : this.target;
                        return this.entityMetadata.namingStrategy.tableName(name, this._name);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TableMetadata.prototype, "name", {
                    /**
                     * Table name in the database.
                     * This name includes global table prefix if it was set.
                     */
                    get: function () {
                        if (this.entityMetadata.tablesPrefix)
                            return this.entityMetadata.namingStrategy.prefixTableName(this.entityMetadata.tablesPrefix, this.nameWithoutPrefix);
                        return this.nameWithoutPrefix;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TableMetadata.prototype, "orderBy", {
                    /**
                     * Specifies a default order by used for queries from this table when no explicit order by is specified.
                     * If default order by was not set, then returns undefined.
                     */
                    get: function () {
                        if (this._orderBy instanceof Function)
                            return this._orderBy(this.entityMetadata.createPropertiesMap());
                        return this._orderBy;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TableMetadata.prototype, "isRegular", {
                    /**
                     * Checks if this table is regular.
                     * All non-specific tables are just regular tables. Its a default table type.
                     */
                    get: function () {
                        return this.tableType === TableTypes_1.TableTypes.REGULAR;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TableMetadata.prototype, "isAbstract", {
                    /**
                     * Checks if this table is abstract.
                     * This type is for the tables that does not exist in the database,
                     * but provide columns and relations for the tables of the child classes who inherit them.
                     */
                    get: function () {
                        return this.tableType === TableTypes_1.TableTypes.ABSTRACT;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TableMetadata.prototype, "isJunction", {
                    /**
                     * Checks if this table is abstract.
                     * Junction table is a table automatically created by many-to-many relationship.
                     */
                    get: function () {
                        return this.tableType === TableTypes_1.TableTypes.JUNCTION;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TableMetadata.prototype, "isClosure", {
                    /**
                     * Checks if this table is a closure table.
                     * Closure table is one of the tree-specific tables that supports closure database pattern.
                     */
                    get: function () {
                        return this.tableType === TableTypes_1.TableTypes.CLOSURE;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TableMetadata.prototype, "isClosureJunction", {
                    /**
                     * Checks if this table is a junction table of the closure table.
                     * This type is for tables that contain junction metadata of the closure tables.
                     */
                    get: function () {
                        return this.tableType === TableTypes_1.TableTypes.CLOSURE_JUNCTION;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TableMetadata.prototype, "isEmbeddable", {
                    /**
                     * Checks if this table is an embeddable table.
                     * Embeddable tables are not stored in the database as separate tables.
                     * Instead their columns are embed into tables who owns them.
                     */
                    get: function () {
                        return this.tableType === TableTypes_1.TableTypes.EMBEDDABLE;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TableMetadata.prototype, "isSingleTableChild", {
                    /**
                     * Checks if this table is a single table child.
                     * Special table type for tables that are mapped into single table using Single Table Inheritance pattern.
                     */
                    get: function () {
                        return this.tableType === TableTypes_1.TableTypes.SINGLE_TABLE_CHILD;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TableMetadata.prototype, "isClassTableChild", {
                    /**
                     * Checks if this table is a class table child.
                     * Special table type for tables that are mapped into multiple tables using Class Table Inheritance pattern.
                     */
                    get: function () {
                        return this.tableType === TableTypes_1.TableTypes.CLASS_TABLE_CHILD;
                    },
                    enumerable: true,
                    configurable: true
                });
                return TableMetadata;
            }());
            exports_10("TableMetadata", TableMetadata);
        }
    };
});
System.register("typeorm/metadata/types/RelationTypes", [], function (exports_11, context_11) {
    "use strict";
    var __moduleName = context_11 && context_11.id;
    var RelationTypes;
    return {
        setters: [],
        execute: function () {
            /**
             * Provides a constants for each relation type.
             */
            RelationTypes = (function () {
                function RelationTypes() {
                }
                return RelationTypes;
            }());
            RelationTypes.ONE_TO_ONE = "one-to-one";
            RelationTypes.ONE_TO_MANY = "one-to-many";
            RelationTypes.MANY_TO_ONE = "many-to-one";
            RelationTypes.MANY_TO_MANY = "many-to-many";
            exports_11("RelationTypes", RelationTypes);
        }
    };
});
System.register("typeorm/metadata/ForeignKeyMetadata", [], function (exports_12, context_12) {
    "use strict";
    var __moduleName = context_12 && context_12.id;
    var ForeignKeyMetadata;
    return {
        setters: [],
        execute: function () {
            /**
             * Contains all information about entity's foreign key.
             */
            ForeignKeyMetadata = (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function ForeignKeyMetadata(columns, referencedTable, referencedColumns, onDelete) {
                    this.columns = columns;
                    this.referencedTable = referencedTable;
                    this.referencedColumns = referencedColumns;
                    if (onDelete)
                        this.onDelete = onDelete;
                }
                Object.defineProperty(ForeignKeyMetadata.prototype, "tableName", {
                    // -------------------------------------------------------------------------
                    // Accessors
                    // -------------------------------------------------------------------------
                    /**
                     * Gets the table name to which this foreign key is applied.
                     */
                    get: function () {
                        return this.entityMetadata.table.name;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ForeignKeyMetadata.prototype, "referencedTableName", {
                    /**
                     * Gets the table name to which this foreign key is referenced.
                     */
                    get: function () {
                        return this.referencedTable.name;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ForeignKeyMetadata.prototype, "name", {
                    /**
                     * Gets foreign key name.
                     */
                    get: function () {
                        return this.entityMetadata.namingStrategy.foreignKeyName(this.tableName, this.columnNames, this.referencedTable.name, this.referencedColumnNames);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ForeignKeyMetadata.prototype, "columnNames", {
                    /**
                     * Gets array of column names.
                     */
                    get: function () {
                        return this.columns.map(function (column) { return column.name; });
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ForeignKeyMetadata.prototype, "referencedColumnNames", {
                    /**
                     * Gets array of referenced column names.
                     */
                    get: function () {
                        return this.referencedColumns.map(function (column) { return column.name; });
                    },
                    enumerable: true,
                    configurable: true
                });
                return ForeignKeyMetadata;
            }());
            exports_12("ForeignKeyMetadata", ForeignKeyMetadata);
        }
    };
});
System.register("typeorm/decorator/options/JoinColumnOptions", [], function (exports_13, context_13) {
    "use strict";
    var __moduleName = context_13 && context_13.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/metadata-args/JoinTableMetadataArgs", [], function (exports_14, context_14) {
    "use strict";
    var __moduleName = context_14 && context_14.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/metadata/JoinTableMetadata", [], function (exports_15, context_15) {
    "use strict";
    var __moduleName = context_15 && context_15.id;
    var JoinTableMetadata;
    return {
        setters: [],
        execute: function () {
            /**
             * JoinTableMetadata contains all information about relation's join table.
             */
            JoinTableMetadata = (function () {
                // ---------------------------------------------------------------------
                // Constructor
                // ---------------------------------------------------------------------
                function JoinTableMetadata(args) {
                    this.target = args.target;
                    this.propertyName = args.propertyName;
                    this._name = args.name;
                    if (args.joinColumn) {
                        if (args.joinColumn.name)
                            this._joinColumnName = args.joinColumn.name;
                        if (args.joinColumn.referencedColumnName)
                            this._joinColumnReferencedColumnName = args.joinColumn.referencedColumnName;
                    }
                    if (args.inverseJoinColumn) {
                        if (args.inverseJoinColumn.name)
                            this._inverseJoinColumnName = args.inverseJoinColumn.name;
                        if (args.inverseJoinColumn.referencedColumnName)
                            this._inverseJoinColumnReferencedColumnName = args.inverseJoinColumn.referencedColumnName;
                    }
                }
                Object.defineProperty(JoinTableMetadata.prototype, "name", {
                    // ---------------------------------------------------------------------
                    // Accessors
                    // ---------------------------------------------------------------------
                    /**
                     * Join table name.
                     */
                    get: function () {
                        if (this._name)
                            return this._name;
                        return this.relation.entityMetadata.namingStrategy.joinTableName(this.relation.entityMetadata.table.nameWithoutPrefix, this.relation.inverseEntityMetadata.table.nameWithoutPrefix, this.relation.propertyName, this.relation.hasInverseSide ? this.relation.inverseRelation.propertyName : "", this.referencedColumn.name, this.inverseReferencedColumn.name);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(JoinTableMetadata.prototype, "joinColumnName", {
                    /**
                     * Join column name.
                     */
                    get: function () {
                        if (this._joinColumnName)
                            return this._joinColumnName;
                        return this.relation
                            .entityMetadata
                            .namingStrategy
                            .joinTableColumnName(this.relation.entityMetadata.table.nameWithoutPrefix, this.referencedColumn.name, this.relation.inverseEntityMetadata.table.nameWithoutPrefix, this.inverseReferencedColumn.name);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(JoinTableMetadata.prototype, "inverseJoinColumnName", {
                    /**
                     * Join column name of the inverse side.
                     */
                    get: function () {
                        if (this._inverseJoinColumnName)
                            return this._inverseJoinColumnName;
                        return this.relation
                            .entityMetadata
                            .namingStrategy
                            .joinTableInverseColumnName(this.relation.inverseEntityMetadata.table.nameWithoutPrefix, this.inverseReferencedColumn.name, this.relation.entityMetadata.table.nameWithoutPrefix, this.referencedColumn.name);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(JoinTableMetadata.prototype, "referencedColumn", {
                    /**
                     * Referenced join column.
                     */
                    get: function () {
                        var _this = this;
                        if (this._joinColumnReferencedColumnName) {
                            var referencedColumn = this.relation.entityMetadata.columns.find(function (column) { return column.name === _this._joinColumnReferencedColumnName; });
                            if (!referencedColumn)
                                throw new Error("Referenced column " + this._joinColumnReferencedColumnName + " was not found in entity " + this.name);
                            return referencedColumn;
                        }
                        if (this.relation.entityMetadata.primaryColumns.length > 1)
                            throw new Error("Cannot automatically determine a referenced column of the \"" + this.relation.entityMetadata.name + "\", because it has multiple primary columns. Try to specify a referenced column explicitly.");
                        return this.relation.entityMetadata.firstPrimaryColumn;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(JoinTableMetadata.prototype, "inverseReferencedColumn", {
                    /**
                     * Referenced join column of the inverse side.
                     */
                    get: function () {
                        var _this = this;
                        if (this._inverseJoinColumnReferencedColumnName) {
                            var referencedColumn = this.relation.inverseEntityMetadata.columns.find(function (column) { return column.name === _this._inverseJoinColumnReferencedColumnName; });
                            if (!referencedColumn)
                                throw new Error("Referenced column " + this._inverseJoinColumnReferencedColumnName + " was not found in entity " + this.name);
                            return referencedColumn;
                        }
                        if (this.relation.inverseEntityMetadata.primaryColumns.length > 1)
                            throw new Error("Cannot automatically determine inverse referenced column of the \"" + this.relation.inverseEntityMetadata.name + "\", because it has multiple primary columns. Try to specify a referenced column explicitly.");
                        return this.relation.inverseEntityMetadata.firstPrimaryColumn;
                    },
                    enumerable: true,
                    configurable: true
                });
                return JoinTableMetadata;
            }());
            exports_15("JoinTableMetadata", JoinTableMetadata);
        }
    };
});
System.register("typeorm/metadata-args/JoinColumnMetadataArgs", [], function (exports_16, context_16) {
    "use strict";
    var __moduleName = context_16 && context_16.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/metadata/JoinColumnMetadata", [], function (exports_17, context_17) {
    "use strict";
    var __moduleName = context_17 && context_17.id;
    var JoinColumnMetadata;
    return {
        setters: [],
        execute: function () {
            /**
             * JoinColumnMetadata contains all information about relation's join column.
             */
            JoinColumnMetadata = (function () {
                // ---------------------------------------------------------------------
                // Constructor
                // ---------------------------------------------------------------------
                function JoinColumnMetadata(args) {
                    this.target = args.target;
                    this.propertyName = args.propertyName;
                    this._name = args.name;
                    this.referencedColumnName = args.referencedColumnName;
                }
                Object.defineProperty(JoinColumnMetadata.prototype, "name", {
                    // ---------------------------------------------------------------------
                    // Accessors
                    // ---------------------------------------------------------------------
                    /**
                     * Join column name.
                     */
                    get: function () {
                        return this.relation.entityMetadata.namingStrategy.joinColumnInverseSideName(this._name, this.relation.propertyName);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(JoinColumnMetadata.prototype, "referencedColumn", {
                    /**
                     * Referenced join column.
                     */
                    get: function () {
                        var _this = this;
                        if (this.referencedColumnName) {
                            var referencedColumn = this.relation.inverseEntityMetadata.allColumns.find(function (column) { return column.name === _this.referencedColumnName; });
                            if (!referencedColumn)
                                throw new Error("Referenced column " + this.referencedColumnName + " was not found in entity " + this.name);
                            return referencedColumn;
                        }
                        var inverseEntityMetadata = this.relation.inverseEntityMetadata;
                        var primaryColumns = inverseEntityMetadata.primaryColumnsWithParentIdColumns;
                        if (primaryColumns.length > 1)
                            throw new Error("Cannot automatically determine a referenced column of the \"" + inverseEntityMetadata.name + "\", because it has multiple primary columns. Try to specify a referenced column explicitly.");
                        return primaryColumns[0];
                    },
                    enumerable: true,
                    configurable: true
                });
                return JoinColumnMetadata;
            }());
            exports_17("JoinColumnMetadata", JoinColumnMetadata);
        }
    };
});
System.register("typeorm/decorator/options/RelationOptions", [], function (exports_18, context_18) {
    "use strict";
    var __moduleName = context_18 && context_18.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/metadata-args/RelationMetadataArgs", [], function (exports_19, context_19) {
    "use strict";
    var __moduleName = context_19 && context_19.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/common/ObjectLiteral", [], function (exports_20, context_20) {
    "use strict";
    var __moduleName = context_20 && context_20.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/metadata/RelationMetadata", ["typeorm/metadata/types/RelationTypes"], function (exports_21, context_21) {
    "use strict";
    var __moduleName = context_21 && context_21.id;
    var RelationTypes_1, RelationMetadata;
    return {
        setters: [
            function (RelationTypes_1_1) {
                RelationTypes_1 = RelationTypes_1_1;
            }
        ],
        execute: function () {
            /**
             * Contains all information about some entity's relation.
             */
            RelationMetadata = (function () {
                // ---------------------------------------------------------------------
                // Constructor
                // ---------------------------------------------------------------------
                function RelationMetadata(args) {
                    /**
                     * Indicates if this is a parent (can be only many-to-one relation) relation in the tree tables.
                     */
                    this.isTreeParent = false;
                    /**
                     * Indicates if this is a children (can be only one-to-many relation) relation in the tree tables.
                     */
                    this.isTreeChildren = false;
                    /**
                     * Indicates if relation column value can be nullable or not.
                     */
                    this.isNullable = true;
                    this.target = args.target;
                    this.propertyName = args.propertyName;
                    this.relationType = args.relationType;
                    if (args.inverseSideProperty)
                        this._inverseSideProperty = args.inverseSideProperty;
                    // if (args.propertyType)
                    //     this.propertyType = args.propertyType;
                    if (args.isLazy !== undefined)
                        this.isLazy = args.isLazy;
                    if (args.options.cascadeInsert || args.options.cascadeAll)
                        this.isCascadeInsert = true;
                    if (args.options.cascadeUpdate || args.options.cascadeAll)
                        this.isCascadeUpdate = true;
                    if (args.options.cascadeRemove || args.options.cascadeAll)
                        this.isCascadeRemove = true;
                    if (args.options.nullable !== undefined)
                        this.isNullable = args.options.nullable;
                    if (args.options.onDelete)
                        this.onDelete = args.options.onDelete;
                    if (args.options.primary !== undefined)
                        this.isPrimary = args.options.primary;
                    if (args.isTreeParent)
                        this.isTreeParent = true;
                    if (args.isTreeChildren)
                        this.isTreeChildren = true;
                    if (!this._type)
                        this._type = args.type;
                }
                Object.defineProperty(RelationMetadata.prototype, "entityTarget", {
                    // ---------------------------------------------------------------------
                    // Accessors
                    // ---------------------------------------------------------------------
                    /**
                     * Gets relation's entity target.
                     * Original target returns target of the class where relation is.
                     * This class can be an abstract class, but relation even is from that class,
                     * but its more related to a specific entity. That's why we need this field.
                     */
                    get: function () {
                        return this.entityMetadata.target;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(RelationMetadata.prototype, "name", {
                    /**
                     * Gets the name of column in the database.
                     * //Cannot be used with many-to-many relations since they don't have a column in the database.
                     * //Also only owning sides of the relations have this property.
                     */
                    get: function () {
                        // if (!this.isOwning || this.isManyToMany)
                        if (this.isOwning) {
                            if (this.joinTable) {
                                return this.joinTable.joinColumnName;
                            }
                            else if (this.joinColumn) {
                                return this.joinColumn.name;
                            }
                        }
                        else if (this.hasInverseSide) {
                            if (this.inverseRelation.joinTable) {
                                return this.inverseRelation.joinTable.inverseJoinColumnName;
                            }
                            else if (this.inverseRelation.joinColumn && this.inverseRelation.joinColumn.referencedColumn) {
                                return this.inverseRelation.joinColumn.referencedColumn.name;
                            }
                        }
                        throw new Error("Relation name cannot be retrieved.");
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(RelationMetadata.prototype, "referencedColumnName", {
                    /**
                     * Gets the name of column to which this relation is referenced.
                     * //Cannot be used with many-to-many relations since all referenced are in the junction table.
                     * //Also only owning sides of the relations have this property.
                     */
                    get: function () {
                        // if (!this.isOwning)
                        //     throw new Error(`Only owning side of the relations can have information about referenced column names.`);
                        // for many-to-one and owner one-to-one relations we get referenced column from join column
                        /*if (this.joinColumn && this.joinColumn.referencedColumn && this.joinColumn.referencedColumn.name)
                            return this.joinColumn.referencedColumn.name;
                
                        // for many-to-many relation we give referenced column depend of owner side
                        if (this.joinTable) { // need to check if this algorithm works correctly
                            if (this.isOwning) {
                                return this.joinTable.referencedColumn.name;
                            } else {
                                return this.joinTable.inverseReferencedColumn.name;
                            }
                        }*/
                        if (this.isOwning) {
                            if (this.joinTable) {
                                return this.joinTable.referencedColumn.name;
                            }
                            else if (this.joinColumn) {
                                return this.joinColumn.referencedColumn.name;
                            }
                        }
                        else if (this.hasInverseSide) {
                            if (this.inverseRelation.joinTable) {
                                return this.inverseRelation.joinTable.inverseReferencedColumn.name;
                            }
                            else if (this.inverseRelation.joinColumn) {
                                return this.inverseRelation.joinColumn.name; // todo: didn't get this logic here
                            }
                        }
                        // this should not be possible, but anyway throw error
                        throw new Error("Cannot get referenced column name of the relation " + this.entityMetadata.name + "#" + this.name);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(RelationMetadata.prototype, "referencedColumn", {
                    /**
                     * Gets the column to which this relation is referenced.
                     */
                    get: function () {
                        if (this.isOwning) {
                            if (this.joinTable) {
                                return this.joinTable.referencedColumn;
                            }
                            else if (this.joinColumn) {
                                return this.joinColumn.referencedColumn;
                            }
                        }
                        else if (this.hasInverseSide) {
                            if (this.inverseRelation.joinTable) {
                                return this.inverseRelation.joinTable.inverseReferencedColumn;
                            }
                            else if (this.inverseRelation.joinColumn) {
                                return this.inverseRelation.joinColumn.referencedColumn;
                            }
                        }
                        // this should not be possible, but anyway throw error
                        throw new Error("Cannot get referenced column of the relation " + this.entityMetadata.name + "#" + this.name);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(RelationMetadata.prototype, "type", {
                    /**
                     * Gets the property's type to which this relation is applied.
                     */
                    get: function () {
                        return this._type instanceof Function ? this._type() : this._type;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(RelationMetadata.prototype, "isOwning", {
                    /**
                     * Indicates if this side is an owner of this relation.
                     */
                    get: function () {
                        return !!(this.isManyToOne ||
                            (this.isManyToMany && this.joinTable) ||
                            (this.isOneToOne && this.joinColumn));
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(RelationMetadata.prototype, "isOneToOne", {
                    /**
                     * Checks if this relation's type is "one-to-one".
                     */
                    get: function () {
                        return this.relationType === RelationTypes_1.RelationTypes.ONE_TO_ONE;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(RelationMetadata.prototype, "isOneToOneOwner", {
                    /**
                     * Checks if this relation is owner side of the "one-to-one" relation.
                     * Owner side means this side of relation has a join column in the table.
                     */
                    get: function () {
                        return this.isOneToOne && this.isOwning;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(RelationMetadata.prototype, "isOneToOneNotOwner", {
                    /**
                     * Checks if this relation is NOT owner side of the "one-to-one" relation.
                     * NOT owner side means this side of relation does not have a join column in the table.
                     */
                    get: function () {
                        return this.isOneToOne && !this.isOwning;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(RelationMetadata.prototype, "isOneToMany", {
                    /**
                     * Checks if this relation's type is "one-to-many".
                     */
                    get: function () {
                        return this.relationType === RelationTypes_1.RelationTypes.ONE_TO_MANY;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(RelationMetadata.prototype, "isManyToOne", {
                    /**
                     * Checks if this relation's type is "many-to-one".
                     */
                    get: function () {
                        return this.relationType === RelationTypes_1.RelationTypes.MANY_TO_ONE;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(RelationMetadata.prototype, "isManyToMany", {
                    /**
                     * Checks if this relation's type is "many-to-many".
                     */
                    get: function () {
                        return this.relationType === RelationTypes_1.RelationTypes.MANY_TO_MANY;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(RelationMetadata.prototype, "isManyToManyOwner", {
                    /**
                     * Checks if this relation's type is "many-to-many", and is owner side of the relationship.
                     * Owner side means this side of relation has a join table.
                     */
                    get: function () {
                        return this.isManyToMany && this.isOwning;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(RelationMetadata.prototype, "isManyToManyNotOwner", {
                    /**
                     * Checks if this relation's type is "many-to-many", and is NOT owner side of the relationship.
                     * Not owner side means this side of relation does not have a join table.
                     */
                    get: function () {
                        return this.isManyToMany && !this.isOwning;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(RelationMetadata.prototype, "hasInverseSide", {
                    /**
                     * Checks if inverse side is specified by a relation.
                     */
                    get: function () {
                        return this.inverseEntityMetadata && this.inverseEntityMetadata.hasRelationWithPropertyName(this.inverseSideProperty);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(RelationMetadata.prototype, "inverseSideProperty", {
                    /**
                     * Gets the property name of the inverse side of the relation.
                     */
                    get: function () {
                        if (this._inverseSideProperty) {
                            return this.computeInverseSide(this._inverseSideProperty);
                        }
                        else if (this.isTreeParent && this.entityMetadata.hasTreeChildrenRelation) {
                            return this.entityMetadata.treeChildrenRelation.propertyName;
                        }
                        else if (this.isTreeChildren && this.entityMetadata.hasTreeParentRelation) {
                            return this.entityMetadata.treeParentRelation.propertyName;
                        }
                        return "";
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(RelationMetadata.prototype, "inverseRelation", {
                    /**
                     * Gets the relation metadata of the inverse side of this relation.
                     */
                    get: function () {
                        var relation = this.inverseEntityMetadata.findRelationWithPropertyName(this.inverseSideProperty);
                        if (!relation)
                            throw new Error("Inverse side was not found in the relation " + this.entityMetadata.name + "#" + this.inverseSideProperty);
                        return relation;
                    },
                    enumerable: true,
                    configurable: true
                });
                // ---------------------------------------------------------------------
                // Public Methods
                // ---------------------------------------------------------------------
                /**
                 * Gets given entity's relation's value.
                 * Using of this method helps to access value of the lazy loaded relation.
                 */
                RelationMetadata.prototype.getEntityValue = function (entity) {
                    return this.isLazy ? entity["__" + this.propertyName + "__"] : entity[this.propertyName];
                };
                /**
                 * Checks if given entity has a value in a relation.
                 */
                RelationMetadata.prototype.hasEntityValue = function (entity) {
                    return this.isLazy ? entity["__" + this.propertyName + "__"] : entity[this.propertyName];
                };
                /**
                 * todo: lazy relations are not supported here? implement logic?
                 *
                 * examples:
                 *
                 * - isOneToOneNotOwner or isOneToMany:
                 *  Post has a Category.
                 *  Post is owner side.
                 *  Category is inverse side.
                 *  Post.category is mapped to Category.id
                 *
                 *  if from Post relation we are passing Category here,
                 *  it should return a post.category
                 */
                RelationMetadata.prototype.getOwnEntityRelationId = function (ownEntity) {
                    if (this.isManyToManyOwner) {
                        return ownEntity[this.joinTable.referencedColumn.propertyName];
                    }
                    else if (this.isManyToManyNotOwner) {
                        return ownEntity[this.inverseRelation.joinTable.inverseReferencedColumn.propertyName];
                    }
                    else if (this.isOneToOneOwner || this.isManyToOne) {
                        return ownEntity[this.joinColumn.propertyName];
                    }
                    else if (this.isOneToOneNotOwner || this.isOneToMany) {
                        return ownEntity[this.inverseRelation.joinColumn.referencedColumn.propertyName];
                    }
                };
                /**
                 *
                 * examples:
                 *
                 * - isOneToOneNotOwner or isOneToMany:
                 *  Post has a Category.
                 *  Post is owner side.
                 *  Category is inverse side.
                 *  Post.category is mapped to Category.id
                 *
                 *  if from Post relation we are passing Category here,
                 *  it should return a category.id
                 *
                 *  @deprecated Looks like this method does not make sence and does same as getOwnEntityRelationId ?
                 */
                RelationMetadata.prototype.getInverseEntityRelationId = function (inverseEntity) {
                    if (this.isManyToManyOwner) {
                        return inverseEntity[this.joinTable.inverseReferencedColumn.propertyName];
                    }
                    else if (this.isManyToManyNotOwner) {
                        return inverseEntity[this.inverseRelation.joinTable.referencedColumn.propertyName];
                    }
                    else if (this.isOneToOneOwner || this.isManyToOne) {
                        return inverseEntity[this.joinColumn.referencedColumn.propertyName];
                    }
                    else if (this.isOneToOneNotOwner || this.isOneToMany) {
                        return inverseEntity[this.inverseRelation.joinColumn.propertyName];
                    }
                };
                // ---------------------------------------------------------------------
                // Private Methods
                // ---------------------------------------------------------------------
                /**
                 * Inverse side set in the relation can be either string - property name of the column on inverse side,
                 * either can be a function that accepts a map of properties with the object and returns one of them.
                 * Second approach is used to achieve type-safety.
                 */
                RelationMetadata.prototype.computeInverseSide = function (inverseSide) {
                    var ownerEntityPropertiesMap = this.inverseEntityMetadata.createPropertiesMap();
                    if (typeof inverseSide === "function")
                        return inverseSide(ownerEntityPropertiesMap);
                    if (typeof inverseSide === "string")
                        return inverseSide;
                    // throw new Error("Cannot compute inverse side of the relation");
                    return "";
                };
                return RelationMetadata;
            }());
            exports_21("RelationMetadata", RelationMetadata);
        }
    };
});
System.register("typeorm/metadata-args/IndexMetadataArgs", [], function (exports_22, context_22) {
    "use strict";
    var __moduleName = context_22 && context_22.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/metadata/IndexMetadata", [], function (exports_23, context_23) {
    "use strict";
    var __moduleName = context_23 && context_23.id;
    var IndexMetadata;
    return {
        setters: [],
        execute: function () {
            /**
             * Index metadata contains all information about table's index.
             */
            IndexMetadata = (function () {
                // ---------------------------------------------------------------------
                // Constructor
                // ---------------------------------------------------------------------
                function IndexMetadata(args) {
                    this.target = args.target;
                    this._columns = args.columns;
                    this._name = args.name;
                    this.isUnique = args.unique;
                }
                Object.defineProperty(IndexMetadata.prototype, "name", {
                    // ---------------------------------------------------------------------
                    // Accessors
                    // ---------------------------------------------------------------------
                    /**
                     * Gets index's name.
                     */
                    get: function () {
                        return this.entityMetadata.namingStrategy.indexName(this._name, this.entityMetadata.table.name, this.columns);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(IndexMetadata.prototype, "tableName", {
                    /**
                     * Gets the table name on which index is applied.
                     */
                    get: function () {
                        return this.entityMetadata.table.name;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(IndexMetadata.prototype, "columns", {
                    /**
                     * Gets the column names which are in this index.
                     */
                    get: function () {
                        var _this = this;
                        // if columns already an array of string then simply return it
                        var columnPropertyNames = [];
                        if (this._columns instanceof Array) {
                            columnPropertyNames = this._columns;
                        }
                        else {
                            // if columns is a function that returns array of field names then execute it and get columns names from it
                            var propertiesMap = this.entityMetadata.createPropertiesMap();
                            columnPropertyNames = this._columns(propertiesMap).map(function (i) { return String(i); });
                        }
                        var columns = this.entityMetadata.columns.filter(function (column) { return columnPropertyNames.indexOf(column.propertyName) !== -1; });
                        var missingColumnNames = columnPropertyNames.filter(function (columnPropertyName) { return !_this.entityMetadata.columns.find(function (column) { return column.propertyName === columnPropertyName; }); });
                        if (missingColumnNames.length > 0) {
                            // console.log(this.entityMetadata.columns);
                            throw new Error("Index " + (this._name ? "\"" + this._name + "\" " : "") + "contains columns that are missing in the entity: " + missingColumnNames.join(", "));
                        }
                        return columns.map(function (column) { return column.name; });
                    },
                    enumerable: true,
                    configurable: true
                });
                return IndexMetadata;
            }());
            exports_23("IndexMetadata", IndexMetadata);
        }
    };
});
System.register("typeorm/naming-strategy/NamingStrategyInterface", [], function (exports_24, context_24) {
    "use strict";
    var __moduleName = context_24 && context_24.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/metadata/EmbeddedMetadata", [], function (exports_25, context_25) {
    "use strict";
    var __moduleName = context_25 && context_25.id;
    var EmbeddedMetadata;
    return {
        setters: [],
        execute: function () {
            /**
             * Contains all information about entity's embedded property.
             */
            EmbeddedMetadata = (function () {
                // ---------------------------------------------------------------------
                // Constructor
                // ---------------------------------------------------------------------
                function EmbeddedMetadata(type, propertyName, table, columns) {
                    var _this = this;
                    this.type = type;
                    this.propertyName = propertyName;
                    this.table = table;
                    this.columns = columns;
                    this.columns.forEach(function (column) {
                        column.embeddedMetadata = _this;
                    });
                }
                // ---------------------------------------------------------------------
                // Public Methods
                // ---------------------------------------------------------------------
                /**
                 * Creates a new embedded object.
                 */
                EmbeddedMetadata.prototype.create = function () {
                    return new this.type;
                };
                return EmbeddedMetadata;
            }());
            exports_25("EmbeddedMetadata", EmbeddedMetadata);
        }
    };
});
System.register("typeorm/metadata-args/EntityMetadataArgs", [], function (exports_26, context_26) {
    "use strict";
    var __moduleName = context_26 && context_26.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/query-builder/alias/Alias", [], function (exports_27, context_27) {
    "use strict";
    var __moduleName = context_27 && context_27.id;
    var Alias;
    return {
        setters: [],
        execute: function () {
            /**
             */
            Alias = (function () {
                function Alias(name) {
                    this.name = name;
                }
                Object.defineProperty(Alias.prototype, "selection", {
                    get: function () {
                        return this.parentAliasName + "." + this.parentPropertyName;
                    },
                    enumerable: true,
                    configurable: true
                });
                return Alias;
            }());
            exports_27("Alias", Alias);
        }
    };
});
System.register("typeorm/query-builder/alias/AliasMap", [], function (exports_28, context_28) {
    "use strict";
    var __moduleName = context_28 && context_28.id;
    var AliasMap;
    return {
        setters: [],
        execute: function () {
            /**
             */
            AliasMap = (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function AliasMap(connection) {
                    this.connection = connection;
                    // -------------------------------------------------------------------------
                    // Properties
                    // -------------------------------------------------------------------------
                    this.aliases = [];
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                AliasMap.prototype.addMainAlias = function (alias) {
                    if (this.hasMainAlias)
                        this.aliases.splice(this.aliases.indexOf(this.mainAlias), 1);
                    alias.isMain = true;
                    this.aliases.push(alias);
                };
                AliasMap.prototype.addAlias = function (alias) {
                    this.aliases.push(alias);
                };
                Object.defineProperty(AliasMap.prototype, "hasMainAlias", {
                    get: function () {
                        return !!this.aliases.find(function (alias) { return alias.isMain; });
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(AliasMap.prototype, "mainAlias", {
                    get: function () {
                        var alias = this.aliases.find(function (alias) { return alias.isMain; });
                        if (!alias)
                            throw new Error("Main alias is not set.");
                        return alias;
                    },
                    enumerable: true,
                    configurable: true
                });
                AliasMap.prototype.findAliasByName = function (name) {
                    return this.aliases.find(function (alias) { return alias.name === name; });
                };
                AliasMap.prototype.findAliasByParent = function (parentAliasName, parentPropertyName) {
                    return this.aliases.find(function (alias) {
                        return alias.parentAliasName === parentAliasName && alias.parentPropertyName === parentPropertyName;
                    });
                };
                AliasMap.prototype.getEntityMetadataByAlias = function (alias) {
                    if (alias.target) {
                        // todo: use connection.getMetadata instead?
                        return this.connection.getMetadata(alias.target);
                    }
                    else if (alias.parentAliasName && alias.parentPropertyName) {
                        var parentAlias = this.findAliasByName(alias.parentAliasName);
                        if (!parentAlias)
                            throw new Error("Alias \"" + alias.parentAliasName + "\" was not found");
                        var parentEntityMetadata = this.getEntityMetadataByAlias(parentAlias);
                        if (!parentEntityMetadata)
                            throw new Error("Cannot get entity metadata for the given alias " + alias.name);
                        if (!parentEntityMetadata.hasRelationWithPropertyName(alias.parentPropertyName))
                            throw new Error("Relation metadata for " + alias.parentAliasName + "#" + alias.parentPropertyName + " was not found.");
                        var relation = parentEntityMetadata.findRelationWithPropertyName(alias.parentPropertyName);
                        return relation.inverseEntityMetadata;
                    }
                    return undefined;
                };
                return AliasMap;
            }());
            exports_28("AliasMap", AliasMap);
        }
    };
});
System.register("typeorm/util/OrmUtils", [], function (exports_29, context_29) {
    "use strict";
    var __moduleName = context_29 && context_29.id;
    var OrmUtils;
    return {
        setters: [],
        execute: function () {
            OrmUtils = (function () {
                function OrmUtils() {
                }
                OrmUtils.groupBy = function (array, propertyCallback) {
                    return array.reduce(function (groupedArray, value) {
                        var key = propertyCallback(value);
                        var grouped = groupedArray.find(function (i) { return i.id === key; });
                        if (!grouped) {
                            grouped = { id: key, items: [] };
                            groupedArray.push(grouped);
                        }
                        grouped.items.push(value);
                        return groupedArray;
                    }, []);
                };
                /**
                 * Transforms given value into boolean value.
                 */
                OrmUtils.toBoolean = function (value) {
                    if (typeof value === "boolean")
                        return value;
                    if (typeof value === "string")
                        return value === "true" || value === "1";
                    if (typeof value === "number")
                        return value > 0;
                    return false;
                };
                /**
                 * Composes an object from the given array of keys and values.
                 */
                OrmUtils.zipObject = function (keys, values) {
                    return keys.reduce(function (object, column, index) {
                        object[column] = values[index];
                        return object;
                    }, {});
                };
                return OrmUtils;
            }());
            exports_29("OrmUtils", OrmUtils);
        }
    };
});
System.register("typeorm/query-builder/transformer/RawSqlResultsToEntityTransformer", ["typeorm/util/OrmUtils"], function (exports_30, context_30) {
    "use strict";
    var __moduleName = context_30 && context_30.id;
    var OrmUtils_1, RawSqlResultsToEntityTransformer;
    return {
        setters: [
            function (OrmUtils_1_1) {
                OrmUtils_1 = OrmUtils_1_1;
            }
        ],
        execute: function () {
            /**
             * Transforms raw sql results returned from the database into entity object.
             * Entity is constructed based on its entity metadata.
             */
            RawSqlResultsToEntityTransformer = (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function RawSqlResultsToEntityTransformer(driver, aliasMap, joinMappings, relationCountMetas, enableRelationIdValues) {
                    this.driver = driver;
                    this.aliasMap = aliasMap;
                    this.joinMappings = joinMappings;
                    this.relationCountMetas = relationCountMetas;
                    this.enableRelationIdValues = enableRelationIdValues;
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                RawSqlResultsToEntityTransformer.prototype.transform = function (rawSqlResults) {
                    // console.log("rawSqlResults: ", rawSqlResults);
                    return this.groupAndTransform(rawSqlResults, this.aliasMap.mainAlias);
                };
                // -------------------------------------------------------------------------
                // Private Methods
                // -------------------------------------------------------------------------
                /**
                 * Since db returns a duplicated rows of the data where accuracies of the same object can be duplicated
                 * we need to group our result and we must have some unique id (primary key in our case)
                 */
                RawSqlResultsToEntityTransformer.prototype.groupAndTransform = function (rawSqlResults, alias) {
                    var _this = this;
                    var metadata = this.aliasMap.getEntityMetadataByAlias(alias);
                    if (!metadata)
                        throw new Error("Cannot get entity metadata for the given alias " + alias.name);
                    var groupedResults = OrmUtils_1.OrmUtils.groupBy(rawSqlResults, function (result) {
                        if (!metadata)
                            return;
                        return metadata.primaryColumnsWithParentIdColumns.map(function (column) { return result[alias.name + "_" + column.name]; }).join("_"); // todo: check it
                    });
                    // console.log("groupedResults: ", groupedResults);
                    return groupedResults
                        .map(function (group) {
                        if (!metadata)
                            return;
                        return _this.transformIntoSingleResult(group.items, alias, metadata);
                    })
                        .filter(function (res) { return !!res; });
                };
                /**
                 * Transforms set of data results into single entity.
                 */
                RawSqlResultsToEntityTransformer.prototype.transformIntoSingleResult = function (rawSqlResults, alias, metadata) {
                    var _this = this;
                    var entity = metadata.create();
                    var hasData = false;
                    // console.log(rawSqlResults);
                    // add special columns that contains relation ids
                    if (this.enableRelationIdValues) {
                        metadata.columns
                            .filter(function (column) { return !!column.relationMetadata; })
                            .forEach(function (column) {
                            var valueInObject = rawSqlResults[0][alias.name + "_" + column.name]; // we use zero index since its grouped data
                            if (valueInObject !== undefined && valueInObject !== null && column.propertyName) {
                                var value = _this.driver.prepareHydratedValue(valueInObject, column);
                                entity[column.propertyName] = value;
                                hasData = true;
                            }
                        });
                    } // */
                    this.joinMappings
                        .filter(function (joinMapping) { return joinMapping.parentName === alias.name && !joinMapping.alias.parentAliasName && joinMapping.alias.target; })
                        .map(function (joinMapping) {
                        var relatedEntities = _this.groupAndTransform(rawSqlResults, joinMapping.alias);
                        var isResultArray = joinMapping.isMany;
                        var result = !isResultArray ? relatedEntities[0] : relatedEntities;
                        if (result && (!isResultArray || result.length > 0)) {
                            entity[joinMapping.propertyName] = result;
                            hasData = true;
                        }
                    });
                    // get value from columns selections and put them into object
                    metadata.columns.forEach(function (column) {
                        var columnName = column.name;
                        var valueInObject = rawSqlResults[0][alias.name + "_" + columnName]; // we use zero index since its grouped data
                        if (valueInObject !== undefined && valueInObject !== null && column.propertyName && !column.isVirtual && !column.isParentId && !column.isDiscriminator) {
                            var value = _this.driver.prepareHydratedValue(valueInObject, column);
                            if (column.isInEmbedded) {
                                if (!entity[column.embeddedProperty])
                                    entity[column.embeddedProperty] = column.embeddedMetadata.create();
                                entity[column.embeddedProperty][column.propertyName] = value;
                            }
                            else {
                                entity[column.propertyName] = value;
                            }
                            hasData = true;
                        }
                    });
                    // add parent tables metadata
                    // console.log(rawSqlResults);
                    if (metadata.parentEntityMetadata) {
                        metadata.parentEntityMetadata.columns.forEach(function (column) {
                            var columnName = column.name;
                            var valueInObject = rawSqlResults[0]["parentIdColumn_" + metadata.parentEntityMetadata.table.name + "_" + columnName]; // we use zero index since its grouped data
                            if (valueInObject !== undefined && valueInObject !== null && column.propertyName && !column.isVirtual && !column.isParentId && !column.isDiscriminator) {
                                var value = _this.driver.prepareHydratedValue(valueInObject, column);
                                if (column.isInEmbedded) {
                                    if (!entity[column.embeddedProperty])
                                        entity[column.embeddedProperty] = column.embeddedMetadata.create();
                                    entity[column.embeddedProperty][column.propertyName] = value;
                                }
                                else {
                                    entity[column.propertyName] = value;
                                }
                                hasData = true;
                            }
                        });
                    }
                    // if relation is loaded then go into it recursively and transform its values too
                    metadata.relations.forEach(function (relation) {
                        var relationAlias = _this.aliasMap.findAliasByParent(alias.name, relation.propertyName);
                        if (relationAlias) {
                            var joinMapping = _this.joinMappings.find(function (joinMapping) { return joinMapping.type === "join" && joinMapping.alias === relationAlias; });
                            var relatedEntities = _this.groupAndTransform(rawSqlResults, relationAlias);
                            var isResultArray = relation.isManyToMany || relation.isOneToMany;
                            var result = !isResultArray ? relatedEntities[0] : relatedEntities;
                            if (result) {
                                var propertyName = relation.propertyName;
                                if (joinMapping) {
                                    propertyName = joinMapping.propertyName;
                                }
                                if (relation.isLazy) {
                                    entity["__" + propertyName + "__"] = result;
                                }
                                else {
                                    entity[propertyName] = result;
                                }
                                if (!isResultArray || result.length > 0)
                                    hasData = true;
                            }
                        }
                        // if relation has id field then relation id/ids to that field.
                        if (relation.isManyToMany) {
                            if (relationAlias) {
                                var ids_1 = [];
                                var joinMapping = _this.joinMappings.find(function (joinMapping) { return joinMapping.type === "relationId" && joinMapping.alias === relationAlias; });
                                if (relation.idField || joinMapping) {
                                    var propertyName = joinMapping ? joinMapping.propertyName : relation.idField;
                                    var junctionMetadata = relation.junctionEntityMetadata;
                                    var columnName_1 = relation.isOwning ? junctionMetadata.columns[1].name : junctionMetadata.columns[0].name;
                                    rawSqlResults.forEach(function (results) {
                                        if (relationAlias) {
                                            var resultsKey = relationAlias.name + "_" + columnName_1;
                                            var value = _this.driver.prepareHydratedValue(results[resultsKey], relation.referencedColumn);
                                            if (value !== undefined && value !== null)
                                                ids_1.push(value);
                                        }
                                    });
                                    if (ids_1 && ids_1.length)
                                        entity[propertyName] = ids_1;
                                }
                            }
                        }
                        else if (relation.idField) {
                            var relationName = relation.name;
                            entity[relation.idField] = _this.driver.prepareHydratedValue(rawSqlResults[0][alias.name + "_" + relationName], relation.referencedColumn);
                        }
                        // if relation counter
                        _this.relationCountMetas.forEach(function (joinMeta) {
                            if (joinMeta.alias === relationAlias) {
                                // console.log("relation count was found for relation: ", relation);
                                // joinMeta.entity = entity;
                                joinMeta.entities.push({ entity: entity, metadata: metadata });
                                // console.log(joinMeta);
                                // console.log("---------------------");
                            }
                        });
                    });
                    return hasData ? entity : null;
                };
                return RawSqlResultsToEntityTransformer;
            }());
            exports_30("RawSqlResultsToEntityTransformer", RawSqlResultsToEntityTransformer);
        }
    };
});
System.register("typeorm/driver/error/ConnectionIsNotSetError", [], function (exports_31, context_31) {
    "use strict";
    var __moduleName = context_31 && context_31.id;
    var ConnectionIsNotSetError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown when user tries to execute operation that requires connection to be established.
             */
            ConnectionIsNotSetError = (function (_super) {
                __extends(ConnectionIsNotSetError, _super);
                function ConnectionIsNotSetError(dbType) {
                    var _this = _super.call(this) || this;
                    _this.name = "ConnectionIsNotSetError";
                    _this.message = "Connection with " + dbType + " database is not established. Check connection configuration.";
                    return _this;
                }
                return ConnectionIsNotSetError;
            }(Error));
            exports_31("ConnectionIsNotSetError", ConnectionIsNotSetError);
        }
    };
});
System.register("typeorm/driver/DatabaseConnection", [], function (exports_32, context_32) {
    "use strict";
    var __moduleName = context_32 && context_32.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/driver/error/DriverPackageNotInstalledError", [], function (exports_33, context_33) {
    "use strict";
    var __moduleName = context_33 && context_33.id;
    var DriverPackageNotInstalledError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown when required driver's package is not installed.
             */
            DriverPackageNotInstalledError = (function (_super) {
                __extends(DriverPackageNotInstalledError, _super);
                function DriverPackageNotInstalledError(driverName, packageName) {
                    var _this = _super.call(this) || this;
                    _this.name = "DriverPackageNotInstalledError";
                    _this.message = driverName + " package has not been found installed. Try to install it: npm install " + packageName + " --save";
                    return _this;
                }
                return DriverPackageNotInstalledError;
            }(Error));
            exports_33("DriverPackageNotInstalledError", DriverPackageNotInstalledError);
        }
    };
});
System.register("typeorm/driver/DriverUtils", [], function (exports_34, context_34) {
    "use strict";
    var __moduleName = context_34 && context_34.id;
    var DriverUtils;
    return {
        setters: [],
        execute: function () {
            /**
             * Common driver utility functions.
             */
            DriverUtils = (function () {
                function DriverUtils() {
                }
                // -------------------------------------------------------------------------
                // Public Static Methods
                // -------------------------------------------------------------------------
                /**
                 * Normalizes and builds a new driver options.
                 * Extracts settings from connection url and sets to a new options object.
                 */
                DriverUtils.buildDriverOptions = function (options, buildOptions) {
                    if (options.url) {
                        var parsedUrl = this.parseConnectionUrl(options.url);
                        if (buildOptions && buildOptions.useSid) {
                            var urlDriverOptions = {
                                type: options.type,
                                host: parsedUrl.host,
                                username: parsedUrl.username,
                                password: parsedUrl.password,
                                port: parsedUrl.port,
                                sid: parsedUrl.database
                            };
                            return Object.assign(urlDriverOptions, options);
                        }
                        else {
                            var urlDriverOptions = {
                                type: options.type,
                                host: parsedUrl.host,
                                username: parsedUrl.username,
                                password: parsedUrl.password,
                                port: parsedUrl.port,
                                database: parsedUrl.database
                            };
                            return Object.assign(urlDriverOptions, options);
                        }
                    }
                    return Object.assign({}, options);
                };
                // -------------------------------------------------------------------------
                // Private Static Methods
                // -------------------------------------------------------------------------
                /**
                 * Extracts connection data from the connection url.
                 */
                DriverUtils.parseConnectionUrl = function (url) {
                    var firstSlashes = url.indexOf("//");
                    var preBase = url.substr(firstSlashes + 2);
                    var secondSlash = preBase.indexOf("/");
                    var base = (secondSlash !== -1) ? preBase.substr(0, secondSlash) : preBase;
                    var afterBase = (secondSlash !== -1) ? preBase.substr(secondSlash + 1) : undefined;
                    var _a = base.split("@"), usernameAndPassword = _a[0], hostAndPort = _a[1];
                    var _b = usernameAndPassword.split(":"), username = _b[0], password = _b[1];
                    var _c = hostAndPort.split(":"), host = _c[0], port = _c[1];
                    return {
                        host: host,
                        username: username,
                        password: password,
                        port: port ? parseInt(port) : undefined,
                        database: afterBase || undefined
                    };
                };
                return DriverUtils;
            }());
            exports_34("DriverUtils", DriverUtils);
        }
    };
});
System.register("typeorm/logger/LoggerOptions", [], function (exports_35, context_35) {
    "use strict";
    var __moduleName = context_35 && context_35.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/platform/PlatformTools", [], function (exports_36, context_36) {
    "use strict";
    var __moduleName = context_36 && context_36.id;
    var PlatformTools;
    return {
        setters: [],
        execute: function () {
            /**
             * Browser's implementation of the platform-specific tools.
             *
             * This file gonna replace PlatformTools for browser environment.
             * For node.js environment this class is not getting packaged.
             * Don't use methods of this class in the code, use PlatformTools methods instead.
             */
            PlatformTools = (function () {
                function PlatformTools() {
                }
                /**
                 * Gets global variable where global stuff can be stored.
                 */
                PlatformTools.getGlobalVariable = function () {
                    return window;
                };
                /**
                 * Loads ("require"-s) given file or package.
                 * This operation only supports on node platform
                 */
                PlatformTools.load = function (name) {
                    if (this.type === "browser")
                        throw new Error("This option/function is not supported in the browser environment. Failed operation: require(\"" + name + "\").");
                    return "";
                };
                /**
                 * Normalizes given path. Does "path.normalize".
                 */
                PlatformTools.pathNormilize = function (pathStr) {
                    if (this.type === "browser")
                        throw new Error("This option/function is not supported in the browser environment. Failed operation: path.normalize(\"" + pathStr + "\").");
                    return "";
                };
                /**
                 * Gets file extension. Does "path.extname".
                 */
                PlatformTools.pathExtname = function (pathStr) {
                    if (this.type === "browser")
                        throw new Error("This option/function is not supported in the browser environment. Failed operation: path.extname(\"" + pathStr + "\").");
                    return "";
                };
                /**
                 * Resolved given path. Does "path.resolve".
                 */
                PlatformTools.pathResolve = function (pathStr) {
                    if (this.type === "browser")
                        throw new Error("This option/function is not supported in the browser environment. Failed operation: path.resolve(\"" + pathStr + "\").");
                    return "";
                };
                /**
                 * Synchronously checks if file exist. Does "fs.existsSync".
                 */
                PlatformTools.fileExist = function (pathStr) {
                    if (this.type === "browser")
                        throw new Error("This option/function is not supported in the browser environment. Failed operation: fs.existsSync(\"" + pathStr + "\").");
                    return false;
                };
                /**
                 * Gets environment variable.
                 */
                PlatformTools.getEnvVariable = function (name) {
                    // if (this.type === "browser")
                    //     throw new Error(`This option/function is not supported in the browser environment. Failed operation: process.env["${name}"].`);
                    return undefined;
                };
                return PlatformTools;
            }());
            /**
             * Type of the currently running platform.
             */
            PlatformTools.type = "browser";
            exports_36("PlatformTools", PlatformTools);
        }
    };
});
System.register("typeorm/logger/Logger", ["typeorm/platform/PlatformTools"], function (exports_37, context_37) {
    "use strict";
    var __moduleName = context_37 && context_37.id;
    var PlatformTools_1, Logger;
    return {
        setters: [
            function (PlatformTools_1_1) {
                PlatformTools_1 = PlatformTools_1_1;
            }
        ],
        execute: function () {
            /**
             * Performs logging of the events in TypeORM.
             */
            Logger = (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function Logger(options) {
                    this.options = options;
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Logs query and parameters used in it.
                 */
                Logger.prototype.logQuery = function (query, parameters) {
                    if (this.options.logQueries ||
                        PlatformTools_1.PlatformTools.getEnvVariable("LOGGER_CLI_SCHEMA_SYNC"))
                        this.log("log", "executing query: " + query + (parameters && parameters.length ? " -- PARAMETERS: " + this.stringifyParams(parameters) : ""));
                };
                /**
                 * Logs query that failed.
                 */
                Logger.prototype.logFailedQuery = function (query, parameters) {
                    if (this.options.logQueries ||
                        this.options.logOnlyFailedQueries ||
                        PlatformTools_1.PlatformTools.getEnvVariable("LOGGER_CLI_SCHEMA_SYNC"))
                        this.log("error", "query failed: " + query + (parameters && parameters.length ? " -- PARAMETERS: " + this.stringifyParams(parameters) : ""));
                };
                /**
                 * Logs failed query's error.
                 */
                Logger.prototype.logQueryError = function (error) {
                    if (this.options.logFailedQueryError ||
                        PlatformTools_1.PlatformTools.getEnvVariable("LOGGER_CLI_SCHEMA_SYNC"))
                        this.log("error", "error during executing query:" + error);
                };
                /**
                 * Logs events from the schema build process.
                 */
                Logger.prototype.logSchemaBuild = function (message) {
                    if (this.options.logSchemaCreation ||
                        PlatformTools_1.PlatformTools.getEnvVariable("LOGGER_CLI_SCHEMA_SYNC"))
                        this.log("info", message);
                };
                /**
                 * Perform logging using given logger, or by default to the console.
                 * Log has its own level and message.
                 */
                Logger.prototype.log = function (level, message) {
                    if (!this.options)
                        return;
                    if (this.options.logger) {
                        this.options.logger(level, message);
                    }
                    else {
                        switch (level) {
                            case "log":
                                console.log(message);
                                break;
                            case "info":
                                console.info(message);
                                break;
                            case "warn":
                                console.warn(message);
                                break;
                            case "error":
                                console.error(message);
                                break;
                        }
                    }
                };
                // -------------------------------------------------------------------------
                // Protected Methods
                // -------------------------------------------------------------------------
                /**
                 * Converts parameters to a string.
                 * Sometimes parameters can have circular objects and therefor we are handle this case too.
                 */
                Logger.prototype.stringifyParams = function (parameters) {
                    try {
                        return JSON.stringify(parameters);
                    }
                    catch (error) {
                        return parameters;
                    }
                };
                return Logger;
            }());
            exports_37("Logger", Logger);
        }
    };
});
System.register("typeorm/driver/error/TransactionAlreadyStartedError", [], function (exports_38, context_38) {
    "use strict";
    var __moduleName = context_38 && context_38.id;
    var TransactionAlreadyStartedError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown when transaction is already started and user tries to run it again.
             */
            TransactionAlreadyStartedError = (function (_super) {
                __extends(TransactionAlreadyStartedError, _super);
                function TransactionAlreadyStartedError() {
                    var _this = _super.call(this) || this;
                    _this.name = "TransactionAlreadyStartedError";
                    _this.message = "Transaction already started for the given connection, commit current transaction before starting a new one.";
                    return _this;
                }
                return TransactionAlreadyStartedError;
            }(Error));
            exports_38("TransactionAlreadyStartedError", TransactionAlreadyStartedError);
        }
    };
});
System.register("typeorm/driver/error/TransactionNotStartedError", [], function (exports_39, context_39) {
    "use strict";
    var __moduleName = context_39 && context_39.id;
    var TransactionNotStartedError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown when transaction is not started yet and user tries to run commit or rollback.
             */
            TransactionNotStartedError = (function (_super) {
                __extends(TransactionNotStartedError, _super);
                function TransactionNotStartedError() {
                    var _this = _super.call(this) || this;
                    _this.name = "TransactionNotStartedError";
                    _this.message = "Transaction is not started yet, start transaction before committing or rolling it back.";
                    return _this;
                }
                return TransactionNotStartedError;
            }(Error));
            exports_39("TransactionNotStartedError", TransactionNotStartedError);
        }
    };
});
System.register("typeorm/driver/error/DataTypeNotSupportedByDriverError", [], function (exports_40, context_40) {
    "use strict";
    var __moduleName = context_40 && context_40.id;
    var DataTypeNotSupportedByDriverError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown if some data type is not supported by a driver.
             */
            DataTypeNotSupportedByDriverError = (function (_super) {
                __extends(DataTypeNotSupportedByDriverError, _super);
                function DataTypeNotSupportedByDriverError(dataType, driverName) {
                    var _this = _super.call(this) || this;
                    _this.name = "DataTypeNotSupportedByDriverError";
                    _this.message = "Specified type (" + dataType + ") is not supported by " + driverName + " driver.";
                    return _this;
                }
                return DataTypeNotSupportedByDriverError;
            }(Error));
            exports_40("DataTypeNotSupportedByDriverError", DataTypeNotSupportedByDriverError);
        }
    };
});
System.register("typeorm/schema-builder/schema/IndexSchema", [], function (exports_41, context_41) {
    "use strict";
    var __moduleName = context_41 && context_41.id;
    var IndexSchema;
    return {
        setters: [],
        execute: function () {
            /**
             * Database's table index stored in this class.
             */
            IndexSchema = (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function IndexSchema(tableName, name, columnNames, isUnique) {
                    this.tableName = tableName;
                    this.name = name;
                    this.columnNames = columnNames;
                    this.isUnique = isUnique;
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Creates a new copy of this index with exactly same properties.
                 */
                IndexSchema.prototype.clone = function () {
                    return new IndexSchema(this.tableName, this.name, this.columnNames.map(function (name) { return name; }), this.isUnique);
                };
                // -------------------------------------------------------------------------
                // Static Methods
                // -------------------------------------------------------------------------
                /**
                 * Creates index from the index metadata object.
                 */
                IndexSchema.create = function (indexMetadata) {
                    return new IndexSchema(indexMetadata.entityMetadata.table.name, indexMetadata.name, indexMetadata.columns, indexMetadata.isUnique);
                };
                return IndexSchema;
            }());
            exports_41("IndexSchema", IndexSchema);
        }
    };
});
System.register("typeorm/schema-builder/schema/ForeignKeySchema", [], function (exports_42, context_42) {
    "use strict";
    var __moduleName = context_42 && context_42.id;
    var ForeignKeySchema;
    return {
        setters: [],
        execute: function () {
            /**
             * Foreign key from the database stored in this class.
             */
            ForeignKeySchema = (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function ForeignKeySchema(name, columnNames, referencedColumnNames, referencedTable, onDelete) {
                    this.name = name;
                    this.columnNames = columnNames;
                    this.referencedColumnNames = referencedColumnNames;
                    this.referencedTableName = referencedTable;
                    this.onDelete = onDelete;
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Creates a new copy of this foreign key with exactly same properties.
                 */
                ForeignKeySchema.prototype.clone = function () {
                    return new ForeignKeySchema(this.name, this.columnNames, this.referencedColumnNames, this.referencedTableName);
                };
                // -------------------------------------------------------------------------
                // Static Methods
                // -------------------------------------------------------------------------
                /**
                 * Creates a new foreign schema from the given foreign key metadata.
                 */
                ForeignKeySchema.create = function (metadata) {
                    return new ForeignKeySchema(metadata.name, metadata.columnNames, metadata.referencedColumnNames, metadata.referencedTableName, metadata.onDelete);
                };
                return ForeignKeySchema;
            }());
            exports_42("ForeignKeySchema", ForeignKeySchema);
        }
    };
});
System.register("typeorm/schema-builder/schema/PrimaryKeySchema", [], function (exports_43, context_43) {
    "use strict";
    var __moduleName = context_43 && context_43.id;
    var PrimaryKeySchema;
    return {
        setters: [],
        execute: function () {
            /**
             * Primary key from the database stored in this class.
             */
            PrimaryKeySchema = (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function PrimaryKeySchema(name, columnName) {
                    this.name = name;
                    this.columnName = columnName;
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Creates a new copy of this primary key with exactly same properties.
                 */
                PrimaryKeySchema.prototype.clone = function () {
                    return new PrimaryKeySchema(this.name, this.columnName);
                };
                return PrimaryKeySchema;
            }());
            exports_43("PrimaryKeySchema", PrimaryKeySchema);
        }
    };
});
System.register("typeorm/schema-builder/schema/TableSchema", ["typeorm/schema-builder/schema/ColumnSchema"], function (exports_44, context_44) {
    "use strict";
    var __moduleName = context_44 && context_44.id;
    var ColumnSchema_1, TableSchema;
    return {
        setters: [
            function (ColumnSchema_1_1) {
                ColumnSchema_1 = ColumnSchema_1_1;
            }
        ],
        execute: function () {
            /**
             * Table schema in the database represented in this class.
             */
            TableSchema = (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function TableSchema(name, columns, justCreated) {
                    /**
                     * Table columns.
                     */
                    this.columns = [];
                    /**
                     * Table indices.
                     */
                    this.indices = [];
                    /**
                     * Table foreign keys.
                     */
                    this.foreignKeys = [];
                    /**
                     * Table primary keys.
                     */
                    this.primaryKeys = [];
                    /**
                     * Indicates if table schema was just created.
                     * This is needed, for example to check if we need to skip primary keys creation
                     * for new table schemas.
                     */
                    this.justCreated = false;
                    this.name = name;
                    if (columns) {
                        this.columns = columns.map(function (column) {
                            if (column instanceof ColumnSchema_1.ColumnSchema) {
                                return column;
                            }
                            else {
                                return new ColumnSchema_1.ColumnSchema(column);
                            }
                        });
                    }
                    if (justCreated !== undefined)
                        this.justCreated = justCreated;
                }
                Object.defineProperty(TableSchema.prototype, "primaryKeysWithoutGenerated", {
                    // -------------------------------------------------------------------------
                    // Accessors
                    // -------------------------------------------------------------------------
                    /**
                     * Gets only those primary keys that does not
                     */
                    get: function () {
                        var generatedColumn = this.columns.find(function (column) { return column.isGenerated; });
                        if (!generatedColumn)
                            return this.primaryKeys;
                        return this.primaryKeys.filter(function (primaryKey) {
                            return primaryKey.columnName !== generatedColumn.name;
                        });
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TableSchema.prototype, "hasGeneratedColumn", {
                    get: function () {
                        return !!this.columns.find(function (column) { return column.isGenerated; });
                    },
                    enumerable: true,
                    configurable: true
                });
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Clones this table schema to a new table schema with all properties cloned.
                 */
                TableSchema.prototype.clone = function () {
                    var cloned = new TableSchema(this.name);
                    cloned.columns = this.columns.map(function (column) { return column.clone(); });
                    cloned.indices = this.indices.map(function (index) { return index.clone(); });
                    cloned.foreignKeys = this.foreignKeys.map(function (key) { return key.clone(); });
                    cloned.primaryKeys = this.primaryKeys.map(function (key) { return key.clone(); });
                    return cloned;
                };
                /**
                 * Adds column schemas.
                 */
                TableSchema.prototype.addColumns = function (columns) {
                    this.columns = this.columns.concat(columns);
                };
                /**
                 * Replaces given column.
                 */
                TableSchema.prototype.replaceColumn = function (oldColumn, newColumn) {
                    this.columns[this.columns.indexOf(oldColumn)] = newColumn;
                };
                /**
                 * Removes a column schema from this table schema.
                 */
                TableSchema.prototype.removeColumn = function (columnToRemove) {
                    var foundColumn = this.columns.find(function (column) { return column.name === columnToRemove.name; });
                    if (foundColumn)
                        this.columns.splice(this.columns.indexOf(foundColumn), 1);
                };
                /**
                 * Remove all column schemas from this table schema.
                 */
                TableSchema.prototype.removeColumns = function (columns) {
                    var _this = this;
                    columns.forEach(function (column) { return _this.removeColumn(column); });
                };
                /**
                 * Adds all given primary keys.
                 */
                TableSchema.prototype.addPrimaryKeys = function (addedKeys) {
                    var _this = this;
                    addedKeys.forEach(function (key) { return _this.primaryKeys.push(key); });
                };
                /**
                 * Removes all given primary keys.
                 */
                TableSchema.prototype.removePrimaryKeys = function (droppedKeys) {
                    var _this = this;
                    droppedKeys.forEach(function (key) {
                        _this.primaryKeys.splice(_this.primaryKeys.indexOf(key), 1);
                    });
                };
                /**
                 * Removes primary keys of the given columns.
                 */
                TableSchema.prototype.removePrimaryKeysOfColumns = function (columns) {
                    this.primaryKeys = this.primaryKeys.filter(function (primaryKey) {
                        return !columns.find(function (column) { return column.name === primaryKey.columnName; });
                    });
                };
                /**
                 * Adds foreign key schemas.
                 */
                TableSchema.prototype.addForeignKeys = function (foreignKeys) {
                    this.foreignKeys = this.foreignKeys.concat(foreignKeys);
                };
                /**
                 * Removes foreign key from this table schema.
                 */
                TableSchema.prototype.removeForeignKey = function (removedForeignKey) {
                    var fk = this.foreignKeys.find(function (foreignKey) { return foreignKey.name === removedForeignKey.name; }); // this must be by name
                    if (fk)
                        this.foreignKeys.splice(this.foreignKeys.indexOf(fk), 1);
                };
                /**
                 * Removes all foreign keys from this table schema.
                 */
                TableSchema.prototype.removeForeignKeys = function (dbForeignKeys) {
                    var _this = this;
                    dbForeignKeys.forEach(function (foreignKey) { return _this.removeForeignKey(foreignKey); });
                };
                /**
                 * Removes index schema from this table schema.
                 */
                TableSchema.prototype.removeIndex = function (indexSchema) {
                    var index = this.indices.find(function (index) { return index.name === indexSchema.name; });
                    if (index)
                        this.indices.splice(this.indices.indexOf(index), 1);
                };
                /**
                 * Differentiate columns of this table schema and columns from the given column metadatas columns
                 * and returns only changed.
                 */
                TableSchema.prototype.findChangedColumns = function (queryRunner, columnMetadatas) {
                    return this.columns.filter(function (columnSchema) {
                        var columnMetadata = columnMetadatas.find(function (columnMetadata) { return columnMetadata.name === columnSchema.name; });
                        if (!columnMetadata)
                            return false; // we don't need new columns, we only need exist and changed
                        return columnSchema.name !== columnMetadata.name ||
                            columnSchema.type !== queryRunner.normalizeType(columnMetadata) ||
                            columnSchema.comment !== columnMetadata.comment ||
                            (!columnSchema.isGenerated && !queryRunner.compareDefaultValues(columnMetadata.default, columnSchema.default)) ||
                            columnSchema.isNullable !== columnMetadata.isNullable ||
                            columnSchema.isUnique !== columnMetadata.isUnique ||
                            // columnSchema.isPrimary !== columnMetadata.isPrimary ||
                            columnSchema.isGenerated !== columnMetadata.isGenerated;
                    });
                };
                return TableSchema;
            }());
            exports_44("TableSchema", TableSchema);
        }
    };
});
System.register("typeorm/query-runner/error/QueryRunnerAlreadyReleasedError", [], function (exports_45, context_45) {
    "use strict";
    var __moduleName = context_45 && context_45.id;
    var QueryRunnerAlreadyReleasedError;
    return {
        setters: [],
        execute: function () {
            /**
             */
            QueryRunnerAlreadyReleasedError = (function (_super) {
                __extends(QueryRunnerAlreadyReleasedError, _super);
                function QueryRunnerAlreadyReleasedError() {
                    var _this = _super.call(this) || this;
                    _this.name = "QueryRunnerAlreadyReleasedError";
                    _this.message = "Query runner already released. Cannot run queries anymore.";
                    return _this;
                }
                return QueryRunnerAlreadyReleasedError;
            }(Error));
            exports_45("QueryRunnerAlreadyReleasedError", QueryRunnerAlreadyReleasedError);
        }
    };
});
System.register("typeorm/driver/sqlserver/SqlServerQueryRunner", ["typeorm/driver/error/TransactionAlreadyStartedError", "typeorm/driver/error/TransactionNotStartedError", "typeorm/driver/error/DataTypeNotSupportedByDriverError", "typeorm/schema-builder/schema/ColumnSchema", "typeorm/schema-builder/schema/TableSchema", "typeorm/schema-builder/schema/ForeignKeySchema", "typeorm/schema-builder/schema/PrimaryKeySchema", "typeorm/schema-builder/schema/IndexSchema", "typeorm/query-runner/error/QueryRunnerAlreadyReleasedError"], function (exports_46, context_46) {
    "use strict";
    var __moduleName = context_46 && context_46.id;
    var TransactionAlreadyStartedError_1, TransactionNotStartedError_1, DataTypeNotSupportedByDriverError_1, ColumnSchema_2, TableSchema_1, ForeignKeySchema_1, PrimaryKeySchema_1, IndexSchema_1, QueryRunnerAlreadyReleasedError_1, SqlServerQueryRunner;
    return {
        setters: [
            function (TransactionAlreadyStartedError_1_1) {
                TransactionAlreadyStartedError_1 = TransactionAlreadyStartedError_1_1;
            },
            function (TransactionNotStartedError_1_1) {
                TransactionNotStartedError_1 = TransactionNotStartedError_1_1;
            },
            function (DataTypeNotSupportedByDriverError_1_1) {
                DataTypeNotSupportedByDriverError_1 = DataTypeNotSupportedByDriverError_1_1;
            },
            function (ColumnSchema_2_1) {
                ColumnSchema_2 = ColumnSchema_2_1;
            },
            function (TableSchema_1_1) {
                TableSchema_1 = TableSchema_1_1;
            },
            function (ForeignKeySchema_1_1) {
                ForeignKeySchema_1 = ForeignKeySchema_1_1;
            },
            function (PrimaryKeySchema_1_1) {
                PrimaryKeySchema_1 = PrimaryKeySchema_1_1;
            },
            function (IndexSchema_1_1) {
                IndexSchema_1 = IndexSchema_1_1;
            },
            function (QueryRunnerAlreadyReleasedError_1_1) {
                QueryRunnerAlreadyReleasedError_1 = QueryRunnerAlreadyReleasedError_1_1;
            }
        ],
        execute: function () {
            /**
             * Runs queries on a single mysql database connection.
             */
            SqlServerQueryRunner = (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function SqlServerQueryRunner(databaseConnection, driver, logger) {
                    this.databaseConnection = databaseConnection;
                    this.driver = driver;
                    this.logger = logger;
                    // -------------------------------------------------------------------------
                    // Protected Properties
                    // -------------------------------------------------------------------------
                    /**
                     * Indicates if connection for this query runner is released.
                     * Once its released, query runner cannot run queries anymore.
                     */
                    this.isReleased = false;
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Releases database connection. This is needed when using connection pooling.
                 * If connection is not from a pool, it should not be released.
                 * You cannot use this class's methods after its released.
                 */
                SqlServerQueryRunner.prototype.release = function () {
                    if (this.databaseConnection.releaseCallback) {
                        this.isReleased = true;
                        return this.databaseConnection.releaseCallback();
                    }
                    return Promise.resolve();
                };
                /**
                 * Removes all tables from the currently connected database.
                 */
                SqlServerQueryRunner.prototype.clearDatabase = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var allTablesSql, allTablesResults, tableNames, error_1;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
                                    return [4 /*yield*/, this.beginTransaction()];
                                case 1:
                                    _a.sent();
                                    _a.label = 2;
                                case 2:
                                    _a.trys.push([2, 7, 9, 11]);
                                    allTablesSql = "SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE'";
                                    return [4 /*yield*/, this.query(allTablesSql)];
                                case 3:
                                    allTablesResults = _a.sent();
                                    tableNames = allTablesResults.map(function (result) { return result["TABLE_NAME"]; });
                                    return [4 /*yield*/, Promise.all(tableNames.map(function (tableName) { return __awaiter(_this, void 0, void 0, function () {
                                            var _this = this;
                                            var dropForeignKeySql, dropFkQueries;
                                            return __generator(this, function (_a) {
                                                switch (_a.label) {
                                                    case 0:
                                                        dropForeignKeySql = "SELECT 'ALTER TABLE ' +  OBJECT_SCHEMA_NAME(parent_object_id) + '.[' + OBJECT_NAME(parent_object_id) + '] DROP CONSTRAINT ' + name as query FROM sys.foreign_keys WHERE referenced_object_id = object_id('" + tableName + "')";
                                                        return [4 /*yield*/, this.query(dropForeignKeySql)];
                                                    case 1:
                                                        dropFkQueries = _a.sent();
                                                        return [2 /*return*/, Promise.all(dropFkQueries.map(function (result) { return result["query"]; }).map(function (dropQuery) {
                                                                return _this.query(dropQuery);
                                                            }))];
                                                }
                                            });
                                        }); }))];
                                case 4:
                                    _a.sent();
                                    return [4 /*yield*/, Promise.all(tableNames.map(function (tableName) {
                                            var dropTableSql = "DROP TABLE \"" + tableName + "\"";
                                            return _this.query(dropTableSql);
                                        }))];
                                case 5:
                                    _a.sent();
                                    return [4 /*yield*/, this.commitTransaction()];
                                case 6:
                                    _a.sent();
                                    return [3 /*break*/, 11];
                                case 7:
                                    error_1 = _a.sent();
                                    return [4 /*yield*/, this.rollbackTransaction()];
                                case 8:
                                    _a.sent();
                                    throw error_1;
                                case 9: return [4 /*yield*/, this.release()];
                                case 10:
                                    _a.sent();
                                    return [7 /*endfinally*/];
                                case 11: return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Starts transaction.
                 */
                SqlServerQueryRunner.prototype.beginTransaction = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        return __generator(this, function (_a) {
                            if (this.isReleased)
                                throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
                            if (this.databaseConnection.isTransactionActive)
                                throw new TransactionAlreadyStartedError_1.TransactionAlreadyStartedError();
                            return [2 /*return*/, new Promise(function (ok, fail) {
                                    _this.databaseConnection.isTransactionActive = true;
                                    _this.databaseConnection.transaction = _this.databaseConnection.connection.transaction();
                                    _this.databaseConnection.transaction.begin(function (err) {
                                        if (err) {
                                            _this.databaseConnection.isTransactionActive = false;
                                            return fail(err);
                                        }
                                        ok();
                                    });
                                })];
                        });
                    });
                };
                /**
                 * Commits transaction.
                 */
                SqlServerQueryRunner.prototype.commitTransaction = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        return __generator(this, function (_a) {
                            if (this.isReleased)
                                throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
                            if (!this.databaseConnection.isTransactionActive)
                                throw new TransactionNotStartedError_1.TransactionNotStartedError();
                            return [2 /*return*/, new Promise(function (ok, fail) {
                                    _this.databaseConnection.transaction.commit(function (err) {
                                        if (err)
                                            return fail(err);
                                        _this.databaseConnection.isTransactionActive = false;
                                        ok();
                                    });
                                })];
                        });
                    });
                };
                /**
                 * Rollbacks transaction.
                 */
                SqlServerQueryRunner.prototype.rollbackTransaction = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        return __generator(this, function (_a) {
                            if (this.isReleased)
                                throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
                            if (!this.databaseConnection.isTransactionActive)
                                throw new TransactionNotStartedError_1.TransactionNotStartedError();
                            return [2 /*return*/, new Promise(function (ok, fail) {
                                    _this.databaseConnection.transaction.rollback(function (err) {
                                        if (err)
                                            return fail(err);
                                        _this.databaseConnection.isTransactionActive = false;
                                        ok();
                                    });
                                })];
                        });
                    });
                };
                /**
                 * Checks if transaction is in progress.
                 */
                SqlServerQueryRunner.prototype.isTransactionActive = function () {
                    return this.databaseConnection.isTransactionActive;
                };
                /**
                 * Executes a given SQL query.
                 */
                SqlServerQueryRunner.prototype.query = function (query, parameters) {
                    var _this = this;
                    if (this.isReleased)
                        throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
                    return new Promise(function (ok, fail) {
                        _this.logger.logQuery(query, parameters);
                        var request = new _this.driver.mssql.Request(_this.isTransactionActive() ? _this.databaseConnection.transaction : _this.databaseConnection.connection);
                        if (parameters && parameters.length) {
                            parameters.forEach(function (parameter, index) {
                                request.input(index, parameters[index]);
                            });
                        }
                        request.query(query, function (err, result) {
                            if (err) {
                                _this.logger.logFailedQuery(query, parameters);
                                _this.logger.logQueryError(err);
                                return fail(err);
                            }
                            ok(result);
                        });
                    });
                };
                /**
                 * Insert a new row with given values into given table.
                 */
                SqlServerQueryRunner.prototype.insert = function (tableName, keyValues, generatedColumn) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var keys, columns, values, parameters, sql, result;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
                                    keys = Object.keys(keyValues);
                                    columns = keys.map(function (key) { return _this.driver.escapeColumnName(key); }).join(", ");
                                    values = keys.map(function (key, index) { return "@" + index; }).join(",");
                                    parameters = keys.map(function (key) { return keyValues[key]; });
                                    sql = columns.length > 0
                                        ? "INSERT INTO " + this.driver.escapeTableName(tableName) + "(" + columns + ") " + (generatedColumn ? "OUTPUT INSERTED." + generatedColumn.name + " " : "") + "VALUES (" + values + ")"
                                        : "INSERT INTO " + this.driver.escapeTableName(tableName) + " " + (generatedColumn ? "OUTPUT INSERTED." + generatedColumn.name + " " : "") + "DEFAULT VALUES ";
                                    return [4 /*yield*/, this.query(sql, parameters)];
                                case 1:
                                    result = _a.sent();
                                    return [2 /*return*/, generatedColumn ? result instanceof Array ? result[0][generatedColumn.name] : result[generatedColumn.name] : undefined];
                            }
                        });
                    });
                };
                /**
                 * Updates rows that match given conditions in the given table.
                 */
                SqlServerQueryRunner.prototype.update = function (tableName, valuesMap, conditions) {
                    return __awaiter(this, void 0, void 0, function () {
                        var conditionParams, updateParams, allParameters, updateValues, conditionString, sql;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
                                    conditionParams = Object.keys(conditions).map(function (key) { return conditions[key]; });
                                    updateParams = Object.keys(valuesMap).map(function (key) { return valuesMap[key]; });
                                    allParameters = updateParams.concat(conditionParams);
                                    updateValues = this.parametrize(valuesMap).join(", ");
                                    conditionString = this.parametrize(conditions, updateParams.length).join(" AND ");
                                    sql = "UPDATE " + this.driver.escapeTableName(tableName) + " SET " + updateValues + " " + (conditionString ? (" WHERE " + conditionString) : "");
                                    return [4 /*yield*/, this.query(sql, allParameters)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Deletes from the given table by a given conditions.
                 */
                SqlServerQueryRunner.prototype.delete = function (tableName, conditions, maybeParameters) {
                    return __awaiter(this, void 0, void 0, function () {
                        var conditionString, parameters, sql;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
                                    conditionString = typeof conditions === "string" ? conditions : this.parametrize(conditions).join(" AND ");
                                    parameters = conditions instanceof Object ? Object.keys(conditions).map(function (key) { return conditions[key]; }) : maybeParameters;
                                    sql = "DELETE FROM " + this.driver.escapeTableName(tableName) + " WHERE " + conditionString;
                                    return [4 /*yield*/, this.query(sql, parameters)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Inserts rows into the closure table.
                 */
                SqlServerQueryRunner.prototype.insertIntoClosureTable = function (tableName, newEntityId, parentId, hasLevel) {
                    return __awaiter(this, void 0, void 0, function () {
                        var sql, results;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
                                    sql = "";
                                    if (hasLevel) {
                                        sql = "INSERT INTO " + this.driver.escapeTableName(tableName) + "(ancestor, descendant, level) " +
                                            ("SELECT ancestor, " + newEntityId + ", level + 1 FROM " + this.driver.escapeTableName(tableName) + " WHERE descendant = " + parentId + " ") +
                                            ("UNION ALL SELECT " + newEntityId + ", " + newEntityId + ", 1");
                                    }
                                    else {
                                        sql = "INSERT INTO " + this.driver.escapeTableName(tableName) + "(ancestor, descendant) " +
                                            ("SELECT ancestor, " + newEntityId + " FROM " + this.driver.escapeTableName(tableName) + " WHERE descendant = " + parentId + " ") +
                                            ("UNION ALL SELECT " + newEntityId + ", " + newEntityId);
                                    }
                                    return [4 /*yield*/, this.query(sql)];
                                case 1:
                                    _a.sent();
                                    return [4 /*yield*/, this.query("SELECT MAX(level) as level FROM " + this.driver.escapeTableName(tableName) + " WHERE descendant = " + parentId)];
                                case 2:
                                    results = _a.sent();
                                    return [2 /*return*/, results && results[0] && results[0]["level"] ? parseInt(results[0]["level"]) + 1 : 1];
                            }
                        });
                    });
                };
                /**
                 * Loads given table's data from the database.
                 */
                SqlServerQueryRunner.prototype.loadTableSchema = function (tableName) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableSchemas;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.loadTableSchemas([tableName])];
                                case 1:
                                    tableSchemas = _a.sent();
                                    return [2 /*return*/, tableSchemas.length > 0 ? tableSchemas[0] : undefined];
                            }
                        });
                    });
                };
                /**
                 * Loads all tables (with given names) from the database and creates a TableSchema from them.
                 */
                SqlServerQueryRunner.prototype.loadTableSchemas = function (tableNames) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var tableNamesString, tablesSql, columnsSql, constraintsSql, identityColumnsSql, indicesSql, _a, dbTables, dbColumns, dbConstraints, dbIdentityColumns, dbIndices;
                        return __generator(this, function (_b) {
                            switch (_b.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
                                    // if no tables given then no need to proceed
                                    if (!tableNames || !tableNames.length)
                                        return [2 /*return*/, []];
                                    tableNamesString = tableNames.map(function (tableName) { return "'" + tableName + "'"; }).join(", ");
                                    tablesSql = "SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_CATALOG = '" + this.dbName + "' AND TABLE_NAME IN (" + tableNamesString + ")";
                                    columnsSql = "SELECT * FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_CATALOG = '" + this.dbName + "'";
                                    constraintsSql = "SELECT columnUsages.*, tableConstraints.CONSTRAINT_TYPE FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE columnUsages " +
                                        "LEFT JOIN INFORMATION_SCHEMA.TABLE_CONSTRAINTS tableConstraints ON tableConstraints.CONSTRAINT_NAME = columnUsages.CONSTRAINT_NAME " +
                                        ("WHERE columnUsages.TABLE_CATALOG = '" + this.dbName + "' AND tableConstraints.TABLE_CATALOG = '" + this.dbName + "'");
                                    identityColumnsSql = "SELECT COLUMN_NAME, TABLE_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_CATALOG = '" + this.dbName + "' AND COLUMNPROPERTY(object_id(TABLE_NAME), COLUMN_NAME, 'IsIdentity') = 1;";
                                    indicesSql = "SELECT TABLE_NAME = t.name, INDEX_NAME = ind.name, IndexId = ind.index_id, ColumnId = ic.index_column_id, COLUMN_NAME = col.name, ind.*, ic.*, col.* " +
                                        "FROM sys.indexes ind INNER JOIN sys.index_columns ic ON ind.object_id = ic.object_id and ind.index_id = ic.index_id INNER JOIN sys.columns col ON ic.object_id = col.object_id and ic.column_id = col.column_id " +
                                        "INNER JOIN sys.tables t ON ind.object_id = t.object_id WHERE ind.is_primary_key = 0 AND ind.is_unique = 0 AND ind.is_unique_constraint = 0 AND t.is_ms_shipped = 0 ORDER BY t.name, ind.name, ind.index_id, ic.index_column_id";
                                    return [4 /*yield*/, Promise.all([
                                            this.query(tablesSql),
                                            this.query(columnsSql),
                                            this.query(constraintsSql),
                                            this.query(identityColumnsSql),
                                            this.query(indicesSql),
                                        ])];
                                case 1:
                                    _a = _b.sent(), dbTables = _a[0], dbColumns = _a[1], dbConstraints = _a[2], dbIdentityColumns = _a[3], dbIndices = _a[4];
                                    // if tables were not found in the db, no need to proceed
                                    if (!dbTables.length)
                                        return [2 /*return*/, []];
                                    // create table schemas for loaded tables
                                    return [2 /*return*/, Promise.all(dbTables.map(function (dbTable) { return __awaiter(_this, void 0, void 0, function () {
                                            var tableSchema;
                                            return __generator(this, function (_a) {
                                                tableSchema = new TableSchema_1.TableSchema(dbTable["TABLE_NAME"]);
                                                // create column schemas from the loaded columns
                                                tableSchema.columns = dbColumns
                                                    .filter(function (dbColumn) { return dbColumn["TABLE_NAME"] === tableSchema.name; })
                                                    .map(function (dbColumn) {
                                                    var isPrimary = !!dbConstraints.find(function (dbConstraint) {
                                                        return dbConstraint["TABLE_NAME"] === tableSchema.name &&
                                                            dbConstraint["COLUMN_NAME"] === dbColumn["COLUMN_NAME"] &&
                                                            dbConstraint["CONSTRAINT_TYPE"] === "PRIMARY KEY";
                                                    });
                                                    var isGenerated = !!dbIdentityColumns.find(function (column) {
                                                        return column["TABLE_NAME"] === tableSchema.name &&
                                                            column["COLUMN_NAME"] === dbColumn["COLUMN_NAME"];
                                                    });
                                                    var isUnique = !!dbConstraints.find(function (dbConstraint) {
                                                        return dbConstraint["TABLE_NAME"] === tableSchema.name &&
                                                            dbConstraint["COLUMN_NAME"] === dbColumn["COLUMN_NAME"] &&
                                                            dbConstraint["CONSTRAINT_TYPE"] === "UNIQUE";
                                                    });
                                                    var columnSchema = new ColumnSchema_2.ColumnSchema();
                                                    columnSchema.name = dbColumn["COLUMN_NAME"];
                                                    columnSchema.type = dbColumn["DATA_TYPE"].toLowerCase() + (dbColumn["CHARACTER_MAXIMUM_LENGTH"] ? "(" + dbColumn["CHARACTER_MAXIMUM_LENGTH"] + ")" : ""); // todo: use normalize type?
                                                    columnSchema.default = dbColumn["COLUMN_DEFAULT"] !== null && dbColumn["COLUMN_DEFAULT"] !== undefined ? dbColumn["COLUMN_DEFAULT"] : undefined;
                                                    columnSchema.isNullable = dbColumn["IS_NULLABLE"] === "YES";
                                                    columnSchema.isPrimary = isPrimary;
                                                    columnSchema.isGenerated = isGenerated;
                                                    columnSchema.isUnique = isUnique;
                                                    columnSchema.comment = ""; // todo: less priority, implement this later
                                                    return columnSchema;
                                                });
                                                // create primary key schema
                                                tableSchema.primaryKeys = dbConstraints
                                                    .filter(function (dbConstraint) {
                                                    return dbConstraint["TABLE_NAME"] === tableSchema.name &&
                                                        dbConstraint["CONSTRAINT_TYPE"] === "PRIMARY KEY";
                                                })
                                                    .map(function (keyColumnUsage) {
                                                    return new PrimaryKeySchema_1.PrimaryKeySchema(keyColumnUsage["CONSTRAINT_NAME"], keyColumnUsage["COLUMN_NAME"]);
                                                });
                                                // create foreign key schemas from the loaded indices
                                                tableSchema.foreignKeys = dbConstraints
                                                    .filter(function (dbConstraint) {
                                                    return dbConstraint["TABLE_NAME"] === tableSchema.name &&
                                                        dbConstraint["CONSTRAINT_TYPE"] === "FOREIGN KEY";
                                                })
                                                    .map(function (dbConstraint) { return new ForeignKeySchema_1.ForeignKeySchema(dbConstraint["CONSTRAINT_NAME"], [], [], "", ""); }); // todo: fix missing params
                                                // create index schemas from the loaded indices
                                                tableSchema.indices = dbIndices
                                                    .filter(function (dbIndex) {
                                                    return dbIndex["TABLE_NAME"] === tableSchema.name &&
                                                        (!tableSchema.foreignKeys.find(function (foreignKey) { return foreignKey.name === dbIndex["INDEX_NAME"]; })) &&
                                                        (!tableSchema.primaryKeys.find(function (primaryKey) { return primaryKey.name === dbIndex["INDEX_NAME"]; }));
                                                })
                                                    .map(function (dbIndex) { return dbIndex["INDEX_NAME"]; })
                                                    .filter(function (value, index, self) { return self.indexOf(value) === index; }) // unqiue
                                                    .map(function (dbIndexName) {
                                                    var columnNames = dbIndices
                                                        .filter(function (dbIndex) { return dbIndex["TABLE_NAME"] === tableSchema.name && dbIndex["INDEX_NAME"] === dbIndexName; })
                                                        .map(function (dbIndex) { return dbIndex["COLUMN_NAME"]; });
                                                    return new IndexSchema_1.IndexSchema(dbTable["TABLE_NAME"], dbIndexName, columnNames, false /* todo: uniqueness? */);
                                                });
                                                return [2 /*return*/, tableSchema];
                                            });
                                        }); }))];
                            }
                        });
                    });
                };
                /**
                 * Checks if table with the given name exist in the database.
                 */
                SqlServerQueryRunner.prototype.hasTable = function (tableName) {
                    return __awaiter(this, void 0, void 0, function () {
                        var sql, result;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    sql = "SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_CATALOG = '" + this.dbName + "' AND TABLE_NAME = '" + tableName + "'";
                                    return [4 /*yield*/, this.query(sql)];
                                case 1:
                                    result = _a.sent();
                                    return [2 /*return*/, result.length ? true : false];
                            }
                        });
                    });
                };
                /**
                 * Creates a new table from the given table metadata and column metadatas.
                 */
                SqlServerQueryRunner.prototype.createTable = function (table) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var columnDefinitions, sql, primaryKeyColumns;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
                                    columnDefinitions = table.columns.map(function (column) { return _this.buildCreateColumnSql(column, false); }).join(", ");
                                    sql = "CREATE TABLE \"" + table.name + "\" (" + columnDefinitions;
                                    sql += table.columns
                                        .filter(function (column) { return column.isUnique; })
                                        .map(function (column) { return ", CONSTRAINT \"uk_" + table.name + "_" + column.name + "\" UNIQUE (\"" + column.name + "\")"; })
                                        .join(" ");
                                    primaryKeyColumns = table.columns.filter(function (column) { return column.isPrimary; });
                                    if (primaryKeyColumns.length > 0)
                                        sql += ", PRIMARY KEY(" + primaryKeyColumns.map(function (column) { return "\"" + column.name + "\""; }).join(", ") + ")";
                                    sql += ")";
                                    return [4 /*yield*/, this.query(sql)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Checks if column with the given name exist in the given table.
                 */
                SqlServerQueryRunner.prototype.hasColumn = function (tableName, columnName) {
                    return __awaiter(this, void 0, void 0, function () {
                        var sql, result;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    sql = "SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_CATALOG = '" + this.dbName + "' AND TABLE_NAME = '" + tableName + "' AND COLUMN_NAME = '" + columnName + "'";
                                    return [4 /*yield*/, this.query(sql)];
                                case 1:
                                    result = _a.sent();
                                    return [2 /*return*/, result.length ? true : false];
                            }
                        });
                    });
                };
                /**
                 * Creates a new column from the column schema in the table.
                 */
                SqlServerQueryRunner.prototype.addColumn = function (tableSchemaOrName, column) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableName, sql;
                        return __generator(this, function (_a) {
                            if (this.isReleased)
                                throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
                            tableName = tableSchemaOrName instanceof TableSchema_1.TableSchema ? tableSchemaOrName.name : tableSchemaOrName;
                            sql = "ALTER TABLE \"" + tableName + "\" ADD " + this.buildCreateColumnSql(column);
                            return [2 /*return*/, this.query(sql)];
                        });
                    });
                };
                /**
                 * Creates a new columns from the column schema in the table.
                 */
                SqlServerQueryRunner.prototype.addColumns = function (tableSchemaOrName, columns) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var queries;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
                                    queries = columns.map(function (column) { return _this.addColumn(tableSchemaOrName, column); });
                                    return [4 /*yield*/, Promise.all(queries)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Renames column in the given table.
                 */
                SqlServerQueryRunner.prototype.renameColumn = function (tableSchemaOrName, oldColumnSchemaOrName, newColumnSchemaOrName) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableSchema, oldColumn, newColumn;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    tableSchema = undefined;
                                    if (!(tableSchemaOrName instanceof TableSchema_1.TableSchema)) return [3 /*break*/, 1];
                                    tableSchema = tableSchemaOrName;
                                    return [3 /*break*/, 3];
                                case 1: return [4 /*yield*/, this.loadTableSchema(tableSchemaOrName)];
                                case 2:
                                    tableSchema = _a.sent();
                                    _a.label = 3;
                                case 3:
                                    if (!tableSchema)
                                        throw new Error("Table " + tableSchemaOrName + " was not found.");
                                    oldColumn = undefined;
                                    if (oldColumnSchemaOrName instanceof ColumnSchema_2.ColumnSchema) {
                                        oldColumn = oldColumnSchemaOrName;
                                    }
                                    else {
                                        oldColumn = tableSchema.columns.find(function (column) { return column.name === oldColumnSchemaOrName; });
                                    }
                                    if (!oldColumn)
                                        throw new Error("Column \"" + oldColumnSchemaOrName + "\" was not found in the \"" + tableSchemaOrName + "\" table.");
                                    newColumn = undefined;
                                    if (newColumnSchemaOrName instanceof ColumnSchema_2.ColumnSchema) {
                                        newColumn = newColumnSchemaOrName;
                                    }
                                    else {
                                        newColumn = oldColumn.clone();
                                        newColumn.name = newColumnSchemaOrName;
                                    }
                                    return [2 /*return*/, this.changeColumn(tableSchema, oldColumn, newColumn)];
                            }
                        });
                    });
                };
                /**
                 * Changes a column in the table.
                 */
                SqlServerQueryRunner.prototype.changeColumn = function (tableSchemaOrName, oldColumnSchemaOrName, newColumn) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableSchema, oldColumn, sql;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
                                    tableSchema = undefined;
                                    if (!(tableSchemaOrName instanceof TableSchema_1.TableSchema)) return [3 /*break*/, 1];
                                    tableSchema = tableSchemaOrName;
                                    return [3 /*break*/, 3];
                                case 1: return [4 /*yield*/, this.loadTableSchema(tableSchemaOrName)];
                                case 2:
                                    tableSchema = _a.sent();
                                    _a.label = 3;
                                case 3:
                                    if (!tableSchema)
                                        throw new Error("Table " + tableSchemaOrName + " was not found.");
                                    oldColumn = undefined;
                                    if (oldColumnSchemaOrName instanceof ColumnSchema_2.ColumnSchema) {
                                        oldColumn = oldColumnSchemaOrName;
                                    }
                                    else {
                                        oldColumn = tableSchema.columns.find(function (column) { return column.name === oldColumnSchemaOrName; });
                                    }
                                    if (!oldColumn)
                                        throw new Error("Column \"" + oldColumnSchemaOrName + "\" was not found in the \"" + tableSchemaOrName + "\" table.");
                                    if (!(newColumn.isGenerated !== oldColumn.isGenerated)) return [3 /*break*/, 6];
                                    return [4 /*yield*/, this.query("ALTER TABLE \"" + tableSchema.name + "\" DROP COLUMN \"" + newColumn.name + "\"")];
                                case 4:
                                    _a.sent();
                                    return [4 /*yield*/, this.query("ALTER TABLE \"" + tableSchema.name + "\" ADD " + this.buildCreateColumnSql(newColumn))];
                                case 5:
                                    _a.sent();
                                    _a.label = 6;
                                case 6:
                                    sql = "ALTER TABLE \"" + tableSchema.name + "\" ALTER COLUMN " + this.buildCreateColumnSql(newColumn, true);
                                    return [4 /*yield*/, this.query(sql)];
                                case 7:
                                    _a.sent();
                                    if (!(newColumn.isUnique !== oldColumn.isUnique)) return [3 /*break*/, 11];
                                    if (!(newColumn.isUnique === true)) return [3 /*break*/, 9];
                                    return [4 /*yield*/, this.query("ALTER TABLE \"" + tableSchema.name + "\" ADD CONSTRAINT \"uk_" + newColumn.name + "\" UNIQUE (\"" + newColumn.name + "\")")];
                                case 8:
                                    _a.sent();
                                    return [3 /*break*/, 11];
                                case 9:
                                    if (!(newColumn.isUnique === false)) return [3 /*break*/, 11];
                                    return [4 /*yield*/, this.query("ALTER TABLE \"" + tableSchema.name + "\" DROP CONSTRAINT \"uk_" + newColumn.name + "\"")];
                                case 10:
                                    _a.sent();
                                    _a.label = 11;
                                case 11: return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Changes a column in the table.
                 */
                SqlServerQueryRunner.prototype.changeColumns = function (tableSchema, changedColumns) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var updatePromises;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
                                    updatePromises = changedColumns.map(function (changedColumn) { return __awaiter(_this, void 0, void 0, function () {
                                        return __generator(this, function (_a) {
                                            return [2 /*return*/, this.changeColumn(tableSchema, changedColumn.oldColumn, changedColumn.newColumn)];
                                        });
                                    }); });
                                    return [4 /*yield*/, Promise.all(updatePromises)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Drops column in the table.
                 */
                SqlServerQueryRunner.prototype.dropColumn = function (tableSchemaOrName, columnSchemaOrName) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableName, columnName;
                        return __generator(this, function (_a) {
                            tableName = tableSchemaOrName instanceof TableSchema_1.TableSchema ? tableSchemaOrName.name : tableSchemaOrName;
                            columnName = columnSchemaOrName instanceof ColumnSchema_2.ColumnSchema ? columnSchemaOrName.name : columnSchemaOrName;
                            return [2 /*return*/, this.query("ALTER TABLE \"" + tableName + "\" DROP COLUMN \"" + columnName + "\"")];
                        });
                    });
                };
                /**
                 * Drops the columns in the table.
                 */
                SqlServerQueryRunner.prototype.dropColumns = function (tableSchemaOrName, columnSchemasOrNames) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var dropPromises;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
                                    dropPromises = columnSchemasOrNames.map(function (column) { return _this.dropColumn(tableSchemaOrName, column); });
                                    return [4 /*yield*/, Promise.all(dropPromises)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Updates table's primary keys.
                 */
                SqlServerQueryRunner.prototype.updatePrimaryKeys = function (dbTable) {
                    return __awaiter(this, void 0, void 0, function () {
                        var oldPrimaryKeySql, oldPrimaryKey, primaryColumnNames;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
                                    oldPrimaryKeySql = "SELECT columnUsages.*, tableConstraints.CONSTRAINT_TYPE FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE columnUsages\nLEFT JOIN INFORMATION_SCHEMA.TABLE_CONSTRAINTS tableConstraints ON tableConstraints.CONSTRAINT_NAME = columnUsages.CONSTRAINT_NAME AND tableConstraints.CONSTRAINT_TYPE = 'PRIMARY KEY'\nWHERE columnUsages.TABLE_CATALOG = '" + this.dbName + "' AND tableConstraints.TABLE_CATALOG = '" + this.dbName + "'";
                                    return [4 /*yield*/, this.query(oldPrimaryKeySql)];
                                case 1:
                                    oldPrimaryKey = _a.sent();
                                    if (!(oldPrimaryKey.length > 0)) return [3 /*break*/, 3];
                                    return [4 /*yield*/, this.query("ALTER TABLE \"" + dbTable.name + "\" DROP CONSTRAINT \"" + oldPrimaryKey[0]["CONSTRAINT_NAME"] + "\"")];
                                case 2:
                                    _a.sent();
                                    _a.label = 3;
                                case 3:
                                    primaryColumnNames = dbTable.primaryKeys.map(function (primaryKey) { return "\"" + primaryKey.columnName + "\""; });
                                    if (!(primaryColumnNames.length > 0)) return [3 /*break*/, 5];
                                    return [4 /*yield*/, this.query("ALTER TABLE \"" + dbTable.name + "\" ADD PRIMARY KEY (" + primaryColumnNames.join(", ") + ")")];
                                case 4:
                                    _a.sent();
                                    _a.label = 5;
                                case 5: return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Creates a new foreign key.
                 */
                SqlServerQueryRunner.prototype.createForeignKey = function (tableSchemaOrName, foreignKey) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableName, columnNames, referencedColumnNames, sql;
                        return __generator(this, function (_a) {
                            if (this.isReleased)
                                throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
                            tableName = tableSchemaOrName instanceof TableSchema_1.TableSchema ? tableSchemaOrName.name : tableSchemaOrName;
                            columnNames = foreignKey.columnNames.map(function (column) { return "\"" + column + "\""; }).join(", ");
                            referencedColumnNames = foreignKey.referencedColumnNames.map(function (column) { return "\"" + column + "\""; }).join(",");
                            sql = "ALTER TABLE \"" + tableName + "\" ADD CONSTRAINT \"" + foreignKey.name + "\" " +
                                ("FOREIGN KEY (" + columnNames + ") ") +
                                ("REFERENCES \"" + foreignKey.referencedTableName + "\"(" + referencedColumnNames + ")");
                            if (foreignKey.onDelete)
                                sql += " ON DELETE " + foreignKey.onDelete;
                            return [2 /*return*/, this.query(sql)];
                        });
                    });
                };
                /**
                 * Creates a new foreign keys.
                 */
                SqlServerQueryRunner.prototype.createForeignKeys = function (tableSchemaOrName, foreignKeys) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var promises;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
                                    promises = foreignKeys.map(function (foreignKey) { return _this.createForeignKey(tableSchemaOrName, foreignKey); });
                                    return [4 /*yield*/, Promise.all(promises)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Drops a foreign key from the table.
                 */
                SqlServerQueryRunner.prototype.dropForeignKey = function (tableSchemaOrName, foreignKey) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableName, sql;
                        return __generator(this, function (_a) {
                            if (this.isReleased)
                                throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
                            tableName = tableSchemaOrName instanceof TableSchema_1.TableSchema ? tableSchemaOrName.name : tableSchemaOrName;
                            sql = "ALTER TABLE \"" + tableName + "\" DROP CONSTRAINT \"" + foreignKey.name + "\"";
                            return [2 /*return*/, this.query(sql)];
                        });
                    });
                };
                /**
                 * Drops a foreign keys from the table.
                 */
                SqlServerQueryRunner.prototype.dropForeignKeys = function (tableSchemaOrName, foreignKeys) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var promises;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
                                    promises = foreignKeys.map(function (foreignKey) { return _this.dropForeignKey(tableSchemaOrName, foreignKey); });
                                    return [4 /*yield*/, Promise.all(promises)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Creates a new index.
                 */
                SqlServerQueryRunner.prototype.createIndex = function (tableName, index) {
                    return __awaiter(this, void 0, void 0, function () {
                        var columns, sql;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
                                    columns = index.columnNames.map(function (columnName) { return "\"" + columnName + "\""; }).join(", ");
                                    sql = "CREATE " + (index.isUnique ? "UNIQUE " : "") + "INDEX \"" + index.name + "\" ON \"" + tableName + "\"(" + columns + ")";
                                    return [4 /*yield*/, this.query(sql)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Drops an index from the table.
                 */
                SqlServerQueryRunner.prototype.dropIndex = function (tableName, indexName) {
                    return __awaiter(this, void 0, void 0, function () {
                        var sql;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
                                    sql = "DROP INDEX \"" + tableName + "\".\"" + indexName + "\"";
                                    return [4 /*yield*/, this.query(sql)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Creates a database type from a given column metadata.
                 */
                SqlServerQueryRunner.prototype.normalizeType = function (typeOptions) {
                    switch (typeOptions.type) {
                        case "string":
                            return "nvarchar(" + (typeOptions.length ? typeOptions.length : 255) + ")";
                        case "text":
                            return "ntext";
                        case "boolean":
                            return "bit";
                        case "integer":
                        case "int":
                            return "int";
                        case "smallint":
                            return "smallint";
                        case "bigint":
                            return "bigint";
                        case "float":
                            return "float";
                        case "double":
                        case "number":
                            return "real";
                        case "decimal":
                            // if (column.precision && column.scale) {
                            //     return `decimal(${column.precision},${column.scale})`;
                            //
                            // } else if (column.scale) {
                            //     return `decimal(${column.scale})`;
                            //
                            // } else if (column.precision) {
                            //     return `decimal(${column.precision})`;
                            //
                            // } else {
                            return "decimal";
                        // }
                        case "date":
                            return "date";
                        case "time":
                            return "time";
                        case "datetime":
                            return "datetime";
                        case "json":
                            return "text";
                        case "simple_array":
                            return typeOptions.length ? "nvarchar(" + typeOptions.length + ")" : "text";
                    }
                    throw new DataTypeNotSupportedByDriverError_1.DataTypeNotSupportedByDriverError(typeOptions.type, "SQLServer");
                };
                /**
                 * Checks if "DEFAULT" values in the column metadata and in the database schema are equal.
                 */
                SqlServerQueryRunner.prototype.compareDefaultValues = function (columnMetadataValue, databaseValue) {
                    if (typeof columnMetadataValue === "number")
                        return columnMetadataValue === parseInt(databaseValue);
                    if (typeof columnMetadataValue === "boolean")
                        return columnMetadataValue === (!!databaseValue || databaseValue === "false");
                    if (typeof columnMetadataValue === "function")
                        return columnMetadataValue() === databaseValue;
                    return columnMetadataValue === databaseValue;
                };
                /**
                 * Truncates table.
                 */
                SqlServerQueryRunner.prototype.truncate = function (tableName) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.query("TRUNCATE TABLE " + this.driver.escapeTableName(tableName))];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                Object.defineProperty(SqlServerQueryRunner.prototype, "dbName", {
                    // -------------------------------------------------------------------------
                    // Protected Methods
                    // -------------------------------------------------------------------------
                    /**
                     * Database name shortcut.
                     */
                    get: function () {
                        return this.driver.options.database;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Parametrizes given object of values. Used to create column=value queries.
                 */
                SqlServerQueryRunner.prototype.parametrize = function (objectLiteral, startFrom) {
                    var _this = this;
                    if (startFrom === void 0) { startFrom = 0; }
                    return Object.keys(objectLiteral).map(function (key, index) {
                        return _this.driver.escapeColumnName(key) + "=@" + (startFrom + index);
                    });
                };
                /**
                 * Builds a query for create column.
                 */
                SqlServerQueryRunner.prototype.buildCreateColumnSql = function (column, skipIdentity) {
                    if (skipIdentity === void 0) { skipIdentity = false; }
                    var c = "\"" + column.name + "\" " + column.type;
                    if (column.isNullable !== true)
                        c += " NOT NULL";
                    if (column.isGenerated === true && !skipIdentity)
                        c += " IDENTITY(1,1)";
                    // if (column.isPrimary === true && !skipPrimary)
                    //     c += " PRIMARY KEY";
                    if (column.comment)
                        c += " COMMENT '" + column.comment + "'";
                    if (column.default !== undefined && column.default !== null) {
                        if (typeof column.default === "number") {
                            c += " DEFAULT " + column.default + "";
                        }
                        else if (typeof column.default === "boolean") {
                            c += " DEFAULT " + (column.default === true ? "1" : "0") + "";
                        }
                        else if (typeof column.default === "function") {
                            c += " DEFAULT " + column.default() + "";
                        }
                        else if (typeof column.default === "string") {
                            c += " DEFAULT '" + column.default + "'";
                        }
                        else {
                            c += " DEFAULT " + column.default + "";
                        }
                    }
                    return c;
                };
                return SqlServerQueryRunner;
            }());
            exports_46("SqlServerQueryRunner", SqlServerQueryRunner);
        }
    };
});
System.register("typeorm/driver/error/DriverOptionNotSetError", [], function (exports_47, context_47) {
    "use strict";
    var __moduleName = context_47 && context_47.id;
    var DriverOptionNotSetError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown if some required driver's option is not set.
             */
            DriverOptionNotSetError = (function (_super) {
                __extends(DriverOptionNotSetError, _super);
                function DriverOptionNotSetError(optionName) {
                    var _this = _super.call(this) || this;
                    _this.name = "DriverOptionNotSetError";
                    _this.message = "Driver option (" + optionName + ") is not set. Please set it to perform connection to the database.";
                    return _this;
                }
                return DriverOptionNotSetError;
            }(Error));
            exports_47("DriverOptionNotSetError", DriverOptionNotSetError);
        }
    };
});
System.register("typeorm/util/DataTransformationUtils", [], function (exports_48, context_48) {
    "use strict";
    var __moduleName = context_48 && context_48.id;
    var DataTransformationUtils;
    return {
        setters: [],
        execute: function () {
            /**
             * Provides utilities to transform hydrated and persisted data.
             */
            DataTransformationUtils = (function () {
                function DataTransformationUtils() {
                }
                // -------------------------------------------------------------------------
                // Public Static Methods
                // -------------------------------------------------------------------------
                /**
                 * Normalizes date object hydrated from the database.
                 */
                DataTransformationUtils.normalizeHydratedDate = function (mixedDate, storedInLocal) {
                    if (!mixedDate)
                        return mixedDate;
                    var date = typeof mixedDate === "string" ? new Date(mixedDate) : mixedDate;
                    if (!storedInLocal) {
                        // else if it was not stored in local timezone, means it was stored in UTC
                        // because driver hydrates it with timezone applied why we need to add timezone hours to match a local timezone
                        var correctedDate = new Date();
                        correctedDate.setUTCFullYear(date.getFullYear(), date.getMonth(), date.getDate());
                        correctedDate.setUTCHours(date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());
                        return correctedDate;
                    }
                    return date;
                };
                /**
                 * Converts given value into date string in a "YYYY-MM-DD" format.
                 */
                DataTransformationUtils.mixedDateToDateString = function (value) {
                    if (value instanceof Date)
                        return this.formatZerolessValue(value.getFullYear()) + "-" + this.formatZerolessValue(value.getMonth() + 1) + "-" + this.formatZerolessValue(value.getDate());
                    return value;
                };
                /**
                 * Converts given value into time string in a "HH:mm:ss" format.
                 */
                DataTransformationUtils.mixedDateToTimeString = function (value) {
                    if (value instanceof Date)
                        return this.formatZerolessValue(value.getHours()) + ":" + this.formatZerolessValue(value.getMinutes()) + ":" + this.formatZerolessValue(value.getSeconds());
                    return value;
                };
                /**
                 * Converts given string value with "-" separator into a "HH:mm:ss" format.
                 */
                DataTransformationUtils.mixedTimeToString = function (value) {
                    value = value instanceof Date ? (value.getHours() + ":" + value.getMinutes() + ":" + value.getSeconds()) : value;
                    if (typeof value === "string") {
                        return value.split(":")
                            .map(function (v) { return v.length === 1 ? "0" + v : v; }) // append zero at beginning if we have a first-zero-less number
                            .join(":");
                    }
                    return value;
                };
                /**
                 * Converts given value into datetime string in a "YYYY-MM-DD HH-mm-ss" format.
                 */
                DataTransformationUtils.mixedDateToDatetimeString = function (value) {
                    if (typeof value === "string") {
                        value = new Date(value);
                    }
                    if (value instanceof Date) {
                        return this.formatZerolessValue(value.getFullYear()) + "-" +
                            this.formatZerolessValue(value.getMonth() + 1) + "-" +
                            this.formatZerolessValue(value.getDate()) + " " +
                            this.formatZerolessValue(value.getHours()) + ":" +
                            this.formatZerolessValue(value.getMinutes()) + ":" +
                            this.formatZerolessValue(value.getSeconds());
                    }
                    return value;
                };
                /**
                 * Converts given value into utc datetime string in a "YYYY-MM-DD HH-mm-ss" format.
                 */
                DataTransformationUtils.mixedDateToUtcDatetimeString = function (value) {
                    if (typeof value === "string") {
                        value = new Date(value);
                    }
                    if (value instanceof Date) {
                        return this.formatZerolessValue(value.getUTCFullYear()) + "-" +
                            this.formatZerolessValue(value.getUTCMonth() + 1) + "-" +
                            this.formatZerolessValue(value.getUTCDate()) + " " +
                            this.formatZerolessValue(value.getUTCHours()) + ":" +
                            this.formatZerolessValue(value.getUTCMinutes()) + ":" +
                            this.formatZerolessValue(value.getUTCSeconds());
                    }
                    return value;
                };
                /**
                 * Converts each item in the given array to string joined by "," separator.
                 */
                DataTransformationUtils.simpleArrayToString = function (value) {
                    if (value instanceof Array) {
                        return value
                            .map(function (i) { return String(i); })
                            .join(",");
                    }
                    return value;
                };
                /**
                 * Converts given string to simple array split by "," separator.
                 */
                DataTransformationUtils.stringToSimpleArray = function (value) {
                    if (value instanceof String || typeof value === "string") {
                        return value.split(",");
                    }
                    return value;
                };
                // -------------------------------------------------------------------------
                // Private Static Methods
                // -------------------------------------------------------------------------
                /**
                 * Formats given number to "0x" format, e.g. if it is 1 then it will return "01".
                 */
                DataTransformationUtils.formatZerolessValue = function (value) {
                    if (value < 10)
                        return "0" + value;
                    return String(value);
                };
                return DataTransformationUtils;
            }());
            exports_48("DataTransformationUtils", DataTransformationUtils);
        }
    };
});
System.register("typeorm/driver/sqlserver/SqlServerDriver", ["typeorm/driver/error/ConnectionIsNotSetError", "typeorm/driver/error/DriverPackageNotInstalledError", "typeorm/driver/DriverUtils", "typeorm/driver/sqlserver/SqlServerQueryRunner", "typeorm/metadata/types/ColumnTypes", "typeorm/driver/error/DriverOptionNotSetError", "typeorm/util/DataTransformationUtils", "typeorm/platform/PlatformTools"], function (exports_49, context_49) {
    "use strict";
    var __moduleName = context_49 && context_49.id;
    var ConnectionIsNotSetError_1, DriverPackageNotInstalledError_1, DriverUtils_1, SqlServerQueryRunner_1, ColumnTypes_1, DriverOptionNotSetError_1, DataTransformationUtils_1, PlatformTools_2, SqlServerDriver;
    return {
        setters: [
            function (ConnectionIsNotSetError_1_1) {
                ConnectionIsNotSetError_1 = ConnectionIsNotSetError_1_1;
            },
            function (DriverPackageNotInstalledError_1_1) {
                DriverPackageNotInstalledError_1 = DriverPackageNotInstalledError_1_1;
            },
            function (DriverUtils_1_1) {
                DriverUtils_1 = DriverUtils_1_1;
            },
            function (SqlServerQueryRunner_1_1) {
                SqlServerQueryRunner_1 = SqlServerQueryRunner_1_1;
            },
            function (ColumnTypes_1_1) {
                ColumnTypes_1 = ColumnTypes_1_1;
            },
            function (DriverOptionNotSetError_1_1) {
                DriverOptionNotSetError_1 = DriverOptionNotSetError_1_1;
            },
            function (DataTransformationUtils_1_1) {
                DataTransformationUtils_1 = DataTransformationUtils_1_1;
            },
            function (PlatformTools_2_1) {
                PlatformTools_2 = PlatformTools_2_1;
            }
        ],
        execute: function () {
            /**
             * Organizes communication with SQL Server DBMS.
             */
            SqlServerDriver = (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function SqlServerDriver(options, logger, mssql) {
                    /**
                     * Pool of database connections.
                     */
                    this.databaseConnectionPool = [];
                    this.options = DriverUtils_1.DriverUtils.buildDriverOptions(options);
                    this.logger = logger;
                    this.mssql = mssql;
                    // validate options to make sure everything is set
                    if (!this.options.host)
                        throw new DriverOptionNotSetError_1.DriverOptionNotSetError("host");
                    if (!this.options.username)
                        throw new DriverOptionNotSetError_1.DriverOptionNotSetError("username");
                    if (!this.options.database)
                        throw new DriverOptionNotSetError_1.DriverOptionNotSetError("database");
                    // if mssql package instance was not set explicitly then try to load it
                    if (!mssql)
                        this.loadDependencies();
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Performs connection to the database.
                 * Based on pooling options, it can either create connection immediately,
                 * either create a pool and create connection when needed.
                 */
                SqlServerDriver.prototype.connect = function () {
                    var _this = this;
                    // build connection options for the driver
                    var options = Object.assign({}, {
                        server: this.options.host,
                        user: this.options.username,
                        password: this.options.password,
                        database: this.options.database,
                        port: this.options.port
                    }, this.options.extra || {});
                    // set default useUTC option if it hasn't been set
                    if (!options.options)
                        options.options = { useUTC: false };
                    else if (!options.options.useUTC)
                        options.options.useUTC = false;
                    // pooling is enabled either when its set explicitly to true,
                    // either when its not defined at all (e.g. enabled by default)
                    return new Promise(function (ok, fail) {
                        var connection = new _this.mssql.Connection(options).connect(function (err) {
                            if (err)
                                return fail(err);
                            _this.connection = connection;
                            if (_this.options.usePool === false) {
                                _this.databaseConnection = {
                                    id: 1,
                                    connection: new _this.mssql.Request(connection),
                                    isTransactionActive: false
                                };
                            }
                            ok();
                        });
                    });
                };
                /**
                 * Closes connection with the database.
                 */
                SqlServerDriver.prototype.disconnect = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            if (!this.connection)
                                throw new ConnectionIsNotSetError_1.ConnectionIsNotSetError("mssql");
                            this.connection.close();
                            this.connection = undefined;
                            this.databaseConnection = undefined;
                            this.databaseConnectionPool = [];
                            return [2 /*return*/];
                        });
                    });
                };
                /**
                 * Creates a query runner used for common queries.
                 */
                SqlServerDriver.prototype.createQueryRunner = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var databaseConnection;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!this.connection)
                                        return [2 /*return*/, Promise.reject(new ConnectionIsNotSetError_1.ConnectionIsNotSetError("mssql"))];
                                    return [4 /*yield*/, this.retrieveDatabaseConnection()];
                                case 1:
                                    databaseConnection = _a.sent();
                                    return [2 /*return*/, new SqlServerQueryRunner_1.SqlServerQueryRunner(databaseConnection, this, this.logger)];
                            }
                        });
                    });
                };
                /**
                 * Access to the native implementation of the database.
                 */
                SqlServerDriver.prototype.nativeInterface = function () {
                    return {
                        driver: this.mssql,
                        connection: this.databaseConnection ? this.databaseConnection.connection : undefined,
                        pool: this.connection
                    };
                };
                /**
                 * Replaces parameters in the given sql with special escaping character
                 * and an array of parameter names to be passed to a query.
                 */
                SqlServerDriver.prototype.escapeQueryWithParameters = function (sql, parameters) {
                    if (!parameters || !Object.keys(parameters).length)
                        return [sql, []];
                    var escapedParameters = [];
                    var keys = Object.keys(parameters).map(function (parameter) { return "(:" + parameter + "\\b)"; }).join("|");
                    sql = sql.replace(new RegExp(keys, "g"), function (key) {
                        var value = parameters[key.substr(1)];
                        if (value instanceof Array) {
                            return value.map(function (v) {
                                escapedParameters.push(v);
                                return "@" + (escapedParameters.length - 1);
                            }).join(", ");
                        }
                        else {
                            escapedParameters.push(value);
                        }
                        return "@" + (escapedParameters.length - 1);
                    }); // todo: make replace only in value statements, otherwise problems
                    return [sql, escapedParameters];
                };
                /**
                 * Escapes a column name.
                 */
                SqlServerDriver.prototype.escapeColumnName = function (columnName) {
                    return "\"" + columnName + "\"";
                };
                /**
                 * Escapes an alias.
                 */
                SqlServerDriver.prototype.escapeAliasName = function (aliasName) {
                    return "\"" + aliasName + "\"";
                };
                /**
                 * Escapes a table name.
                 */
                SqlServerDriver.prototype.escapeTableName = function (tableName) {
                    return "\"" + tableName + "\"";
                };
                /**
                 * Prepares given value to a value to be persisted, based on its column type and metadata.
                 */
                SqlServerDriver.prototype.preparePersistentValue = function (value, columnMetadata) {
                    if (value === null || value === undefined)
                        return null;
                    switch (columnMetadata.type) {
                        case ColumnTypes_1.ColumnTypes.BOOLEAN:
                            return value === true ? 1 : 0;
                        case ColumnTypes_1.ColumnTypes.DATE:
                            return DataTransformationUtils_1.DataTransformationUtils.mixedDateToDateString(value);
                        case ColumnTypes_1.ColumnTypes.TIME:
                            return DataTransformationUtils_1.DataTransformationUtils.mixedDateToTimeString(value);
                        case ColumnTypes_1.ColumnTypes.DATETIME:
                            if (columnMetadata.localTimezone) {
                                return DataTransformationUtils_1.DataTransformationUtils.mixedDateToDatetimeString(value);
                            }
                            else {
                                return DataTransformationUtils_1.DataTransformationUtils.mixedDateToUtcDatetimeString(value);
                            }
                        case ColumnTypes_1.ColumnTypes.JSON:
                            return JSON.stringify(value);
                        case ColumnTypes_1.ColumnTypes.SIMPLE_ARRAY:
                            return DataTransformationUtils_1.DataTransformationUtils.simpleArrayToString(value);
                    }
                    return value;
                };
                /**
                 * Prepares given value to a value to be persisted, based on its column type or metadata.
                 */
                SqlServerDriver.prototype.prepareHydratedValue = function (value, columnMetadata) {
                    switch (columnMetadata.type) {
                        case ColumnTypes_1.ColumnTypes.BOOLEAN:
                            return value ? true : false;
                        case ColumnTypes_1.ColumnTypes.DATETIME:
                            return DataTransformationUtils_1.DataTransformationUtils.normalizeHydratedDate(value, columnMetadata.localTimezone === true);
                        case ColumnTypes_1.ColumnTypes.TIME:
                            return DataTransformationUtils_1.DataTransformationUtils.mixedTimeToString(value);
                        case ColumnTypes_1.ColumnTypes.JSON:
                            return JSON.parse(value);
                        case ColumnTypes_1.ColumnTypes.SIMPLE_ARRAY:
                            return DataTransformationUtils_1.DataTransformationUtils.stringToSimpleArray(value);
                    }
                    return value;
                };
                // -------------------------------------------------------------------------
                // Protected Methods
                // -------------------------------------------------------------------------
                /**
                 * Retrieves a new database connection.
                 * If pooling is enabled then connection from the pool will be retrieved.
                 * Otherwise active connection will be returned.
                 */
                SqlServerDriver.prototype.retrieveDatabaseConnection = function () {
                    var _this = this;
                    if (!this.connection)
                        throw new ConnectionIsNotSetError_1.ConnectionIsNotSetError("mssql");
                    return new Promise(function (ok, fail) {
                        if (_this.databaseConnection)
                            return ok(_this.databaseConnection);
                        // let dbConnection: DatabaseConnection|undefined;
                        // const connection = this.pool.connect((err: any) => {
                        //     if (err)
                        //         return fail(err);
                        //     ok(dbConnection);
                        // });
                        //
                        // console.log(connection);
                        // console.log(this.pool);
                        // console.log(this.pool === connection);
                        // const request = new this.mssql.Request(this.connection);
                        // console.log("request:", request);
                        // let dbConnection = this.databaseConnectionPool.find(dbConnection => dbConnection.connection === connection);
                        // if (!dbConnection) {
                        var dbConnection = {
                            id: _this.databaseConnectionPool.length,
                            connection: _this.connection,
                            isTransactionActive: false
                        };
                        dbConnection.releaseCallback = function () {
                            // }
                            // if (this.connection && dbConnection) {
                            // request.release();
                            _this.databaseConnectionPool.splice(_this.databaseConnectionPool.indexOf(dbConnection), 1);
                            return Promise.resolve();
                        };
                        _this.databaseConnectionPool.push(dbConnection);
                        ok(dbConnection);
                        // }
                    });
                };
                /**
                 * If driver dependency is not given explicitly, then try to load it via "require".
                 */
                SqlServerDriver.prototype.loadDependencies = function () {
                    try {
                        this.mssql = PlatformTools_2.PlatformTools.load("mssql");
                    }
                    catch (e) {
                        throw new DriverPackageNotInstalledError_1.DriverPackageNotInstalledError("SQL Server", "mssql");
                    }
                };
                return SqlServerDriver;
            }());
            exports_49("SqlServerDriver", SqlServerDriver);
        }
    };
});
System.register("typeorm/query-builder/JoinOptions", [], function (exports_50, context_50) {
    "use strict";
    var __moduleName = context_50 && context_50.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/query-runner/QueryRunnerProvider", [], function (exports_51, context_51) {
    "use strict";
    var __moduleName = context_51 && context_51.id;
    var QueryRunnerProvider;
    return {
        setters: [],
        execute: function () {
            /**
             * Represents functionality to provide a new query runners, and release old ones.
             * Also can provide always same query runner.
             */
            QueryRunnerProvider = (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function QueryRunnerProvider(driver, useSingleQueryRunner) {
                    if (useSingleQueryRunner === void 0) { useSingleQueryRunner = false; }
                    this.driver = driver;
                    this.useSingleQueryRunner = useSingleQueryRunner;
                }
                Object.defineProperty(QueryRunnerProvider.prototype, "isReleased", {
                    // -------------------------------------------------------------------------
                    // Accessors
                    // -------------------------------------------------------------------------
                    get: function () {
                        return this._isReleased;
                    },
                    enumerable: true,
                    configurable: true
                });
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Provides a new query runner used to run repository queries.
                 * If use useSingleQueryRunner mode is enabled then reusable query runner will be provided instead.
                 */
                QueryRunnerProvider.prototype.provide = function () {
                    var _this = this;
                    if (this.useSingleQueryRunner) {
                        if (!this.reusableQueryRunner) {
                            if (!this.reusableQueryRunnerPromise) {
                                // we do this because this method can be created multiple times
                                // this will lead to multiple query runner creations
                                this.reusableQueryRunnerPromise = this.driver
                                    .createQueryRunner()
                                    .then(function (reusableQueryRunner) {
                                    _this.reusableQueryRunner = reusableQueryRunner;
                                    return reusableQueryRunner;
                                });
                            }
                            return this.reusableQueryRunnerPromise;
                        }
                        return Promise.resolve(this.reusableQueryRunner);
                    }
                    return this.driver.createQueryRunner();
                };
                /**
                 * Query runner release logic extracted into separated methods intently,
                 * to make possible to create a subclass with its own release query runner logic.
                 * Note: release only query runners that provided by a provide() method.
                 * This is important and by design.
                 */
                QueryRunnerProvider.prototype.release = function (queryRunner) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            if (queryRunner === this.reusableQueryRunner)
                                return [2 /*return*/];
                            return [2 /*return*/, queryRunner.release()];
                        });
                    });
                };
                /**
                 * Releases reused query runner.
                 */
                QueryRunnerProvider.prototype.releaseReused = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            this._isReleased = true;
                            if (this.reusableQueryRunner)
                                return [2 /*return*/, this.reusableQueryRunner.release()];
                            return [2 /*return*/];
                        });
                    });
                };
                return QueryRunnerProvider;
            }());
            exports_51("QueryRunnerProvider", QueryRunnerProvider);
        }
    };
});
System.register("typeorm/query-builder/QueryBuilder", ["typeorm/query-builder/alias/Alias", "typeorm/query-builder/alias/AliasMap", "typeorm/query-builder/transformer/RawSqlResultsToEntityTransformer", "typeorm/driver/sqlserver/SqlServerDriver", "typeorm/query-runner/QueryRunnerProvider"], function (exports_52, context_52) {
    "use strict";
    var __moduleName = context_52 && context_52.id;
    var Alias_1, AliasMap_1, RawSqlResultsToEntityTransformer_1, SqlServerDriver_1, QueryRunnerProvider_1, QueryBuilder;
    return {
        setters: [
            function (Alias_1_1) {
                Alias_1 = Alias_1_1;
            },
            function (AliasMap_1_1) {
                AliasMap_1 = AliasMap_1_1;
            },
            function (RawSqlResultsToEntityTransformer_1_1) {
                RawSqlResultsToEntityTransformer_1 = RawSqlResultsToEntityTransformer_1_1;
            },
            function (SqlServerDriver_1_1) {
                SqlServerDriver_1 = SqlServerDriver_1_1;
            },
            function (QueryRunnerProvider_1_1) {
                QueryRunnerProvider_1 = QueryRunnerProvider_1_1;
            }
        ],
        execute: function () {
            /**
             * Allows to build complex sql queries in a fashion way and execute those queries.
             */
            QueryBuilder = (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function QueryBuilder(connection, queryRunnerProvider) {
                    this.connection = connection;
                    this.queryRunnerProvider = queryRunnerProvider;
                    this.type = "select";
                    this.selects = [];
                    this.joins = [];
                    this.joinRelationIds = [];
                    this.relationCountMetas = [];
                    this.groupBys = [];
                    this.wheres = [];
                    this.havings = [];
                    this.orderBys = {};
                    this.parameters = {};
                    this.ignoreParentTablesJoins = false;
                    /**
                     * Indicates if virtual columns should be included in entity result.
                     */
                    this.enableRelationIdValues = false;
                    this.aliasMap = new AliasMap_1.AliasMap(connection);
                }
                Object.defineProperty(QueryBuilder.prototype, "alias", {
                    // -------------------------------------------------------------------------
                    // Accessors
                    // -------------------------------------------------------------------------
                    /**
                     * Gets the main alias string used in this query builder.
                     */
                    get: function () {
                        return this.aliasMap.mainAlias.name;
                    },
                    enumerable: true,
                    configurable: true
                });
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Creates DELETE query.
                 */
                QueryBuilder.prototype.delete = function () {
                    this.type = "delete";
                    return this;
                };
                /**
                 * Creates UPDATE query and applies given update values.
                 */
                QueryBuilder.prototype.update = function (tableNameOrEntityOrUpdateSet, maybeUpdateSet) {
                    var updateSet = maybeUpdateSet ? maybeUpdateSet : tableNameOrEntityOrUpdateSet;
                    if (tableNameOrEntityOrUpdateSet instanceof Function) {
                        var aliasName = tableNameOrEntityOrUpdateSet.name;
                        var aliasObj = new Alias_1.Alias(aliasName);
                        aliasObj.target = tableNameOrEntityOrUpdateSet;
                        this.aliasMap.addMainAlias(aliasObj);
                        this.fromEntity = { alias: aliasObj };
                    }
                    else if (typeof tableNameOrEntityOrUpdateSet === "string") {
                        this.fromTableName = tableNameOrEntityOrUpdateSet;
                    }
                    this.type = "update";
                    this.updateQuerySet = updateSet;
                    return this;
                };
                /**
                 * Creates SELECT query and selects given data.
                 * Replaces all old selections if they exist.
                 */
                QueryBuilder.prototype.select = function (selection) {
                    this.type = "select";
                    if (selection) {
                        if (selection instanceof Array) {
                            this.selects = selection;
                        }
                        else {
                            this.selects = [selection];
                        }
                    }
                    return this;
                };
                /**
                 * Adds new selection to the SELECT query.
                 */
                QueryBuilder.prototype.addSelect = function (selection) {
                    if (selection instanceof Array)
                        this.selects = this.selects.concat(selection);
                    else
                        this.selects.push(selection);
                    return this;
                };
                /**
                 * Specifies FROM which entity's table select/update/delete will be executed.
                 * Also sets a main string alias of the selection data.
                 */
                QueryBuilder.prototype.from = function (entityTarget, alias) {
                    var aliasObj = new Alias_1.Alias(alias);
                    aliasObj.target = entityTarget;
                    this.aliasMap.addMainAlias(aliasObj);
                    this.fromEntity = { alias: aliasObj };
                    return this;
                };
                /**
                 * Specifies FROM which table select/update/delete will be executed.
                 * Also sets a main string alias of the selection data.
                 */
                QueryBuilder.prototype.fromTable = function (tableName, alias) {
                    this.fromTableName = tableName;
                    this.fromTableAlias = alias;
                    return this;
                };
                /**
                 * INNER JOINs (without selection).
                 * You also need to specify an alias of the joined data.
                 * Optionally, you can add condition and parameters used in condition.
                 */
                QueryBuilder.prototype.innerJoin = function (entityOrProperty, alias, condition, options) {
                    if (condition === void 0) { condition = ""; }
                    return this.join("INNER", entityOrProperty, alias, condition, options);
                };
                /**
                 * LEFT JOINs (without selection).
                 * You also need to specify an alias of the joined data.
                 * Optionally, you can add condition and parameters used in condition.
                 */
                QueryBuilder.prototype.leftJoin = function (entityOrProperty, alias, condition, options) {
                    if (condition === void 0) { condition = ""; }
                    return this.join("LEFT", entityOrProperty, alias, condition, options);
                };
                /**
                 * INNER JOINs and adds all selection properties to SELECT.
                 * You also need to specify an alias of the joined data.
                 * Optionally, you can add condition and parameters used in condition.
                 */
                QueryBuilder.prototype.innerJoinAndSelect = function (entityOrProperty, alias, condition, options) {
                    if (condition === void 0) { condition = ""; }
                    this.addSelect(alias);
                    return this.join("INNER", entityOrProperty, alias, condition, options);
                };
                /**
                 * LEFT JOINs and adds all selection properties to SELECT.
                 * You also need to specify an alias of the joined data.
                 * Optionally, you can add condition and parameters used in condition.
                 */
                QueryBuilder.prototype.leftJoinAndSelect = function (entityOrProperty, alias, condition, options) {
                    if (condition === void 0) { condition = ""; }
                    this.addSelect(alias);
                    return this.join("LEFT", entityOrProperty, alias, condition, options);
                };
                /**
                 * INNER JOINs, SELECTs the data returned by a join and MAPs all that data to some entity's property.
                 * This is extremely useful when you want to select some data and map it to some virtual property.
                 * It will assume that there are multiple rows of selecting data, and mapped result will be an array.
                 * You also need to specify an alias of the joined data.
                 * Optionally, you can add condition and parameters used in condition.
                 */
                QueryBuilder.prototype.innerJoinAndMapMany = function (mapToProperty, entityOrProperty, alias, condition, options) {
                    if (condition === void 0) { condition = ""; }
                    this.addSelect(alias);
                    return this.join("INNER", entityOrProperty, alias, condition, options, mapToProperty, true);
                };
                /**
                 * INNER JOINs, SELECTs the data returned by a join and MAPs all that data to some entity's property.
                 * This is extremely useful when you want to select some data and map it to some virtual property.
                 * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.
                 * You also need to specify an alias of the joined data.
                 * Optionally, you can add condition and parameters used in condition.
                 */
                QueryBuilder.prototype.innerJoinAndMapOne = function (mapToProperty, entityOrProperty, alias, condition, options) {
                    if (condition === void 0) { condition = ""; }
                    this.addSelect(alias);
                    return this.join("INNER", entityOrProperty, alias, condition, options, mapToProperty, false);
                };
                /**
                 * LEFT JOINs, SELECTs the data returned by a join and MAPs all that data to some entity's property.
                 * This is extremely useful when you want to select some data and map it to some virtual property.
                 * It will assume that there are multiple rows of selecting data, and mapped result will be an array.
                 * You also need to specify an alias of the joined data.
                 * Optionally, you can add condition and parameters used in condition.
                 */
                QueryBuilder.prototype.leftJoinAndMapMany = function (mapToProperty, entityOrProperty, alias, condition, options) {
                    if (condition === void 0) { condition = ""; }
                    this.addSelect(alias);
                    return this.join("LEFT", entityOrProperty, alias, condition, options, mapToProperty, true);
                };
                /**
                 * LEFT JOINs, SELECTs the data returned by a join and MAPs all that data to some entity's property.
                 * This is extremely useful when you want to select some data and map it to some virtual property.
                 * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.
                 * You also need to specify an alias of the joined data.
                 * Optionally, you can add condition and parameters used in condition.
                 */
                QueryBuilder.prototype.leftJoinAndMapOne = function (mapToProperty, entityOrProperty, alias, condition, options) {
                    if (condition === void 0) { condition = ""; }
                    this.addSelect(alias);
                    return this.join("LEFT", entityOrProperty, alias, condition, options, mapToProperty, false);
                };
                /**
                 * LEFT JOINs relation id.
                 * Optionally, you can add condition and parameters used in condition.
                 *
                 * @experimental
                 */
                QueryBuilder.prototype.leftJoinRelationId = function (property, condition) {
                    return this.joinRelationId("LEFT", undefined, property, condition);
                };
                /**
                 * INNER JOINs relation id.
                 * Optionally, you can add condition and parameters used in condition.
                 *
                 * @experimental
                 */
                QueryBuilder.prototype.innerJoinRelationId = function (property, condition) {
                    return this.joinRelationId("INNER", undefined, property, condition);
                };
                /**
                 * LEFT JOINs relation id and maps it into some entity's property.
                 * Optionally, you can add condition and parameters used in condition.
                 *
                 * @experimental
                 */
                QueryBuilder.prototype.leftJoinRelationIdAndMap = function (mapToProperty, property, condition) {
                    if (condition === void 0) { condition = ""; }
                    return this.joinRelationId("INNER", mapToProperty, property, condition);
                };
                /**
                 * INNER JOINs relation id and maps it into some entity's property.
                 * Optionally, you can add condition and parameters used in condition.
                 *
                 * @experimental
                 */
                QueryBuilder.prototype.innerJoinRelationIdAndMap = function (mapToProperty, property, condition) {
                    if (condition === void 0) { condition = ""; }
                    return this.joinRelationId("INNER", mapToProperty, property, condition);
                };
                /**
                 * Counts number of entities of entity's relation.
                 * Optionally, you can add condition and parameters used in condition.
                 *
                 * @experimental
                 */
                QueryBuilder.prototype.countRelation = function (property, condition) {
                    if (condition === void 0) { condition = ""; }
                    var _a = property.split("."), parentAliasName = _a[0], parentPropertyName = _a[1];
                    var alias = parentAliasName + "_" + parentPropertyName + "_relation_count";
                    var aliasObj = new Alias_1.Alias(alias);
                    this.aliasMap.addAlias(aliasObj);
                    aliasObj.parentAliasName = parentAliasName;
                    aliasObj.parentPropertyName = parentPropertyName;
                    var relationCountMeta = {
                        condition: condition,
                        alias: aliasObj,
                        entities: []
                    };
                    this.relationCountMetas.push(relationCountMeta);
                    return this;
                };
                /**
                 * Counts number of entities of entity's relation and maps the value into some entity's property.
                 * Optionally, you can add condition and parameters used in condition.
                 *
                 * @experimental
                 */
                QueryBuilder.prototype.countRelationAndMap = function (mapProperty, property, condition) {
                    if (condition === void 0) { condition = ""; }
                    var _a = property.split("."), parentAliasName = _a[0], parentPropertyName = _a[1];
                    var alias = parentAliasName + "_" + parentPropertyName + "_relation_count";
                    var aliasObj = new Alias_1.Alias(alias);
                    this.aliasMap.addAlias(aliasObj);
                    aliasObj.parentAliasName = parentAliasName;
                    aliasObj.parentPropertyName = parentPropertyName;
                    var relationCountMeta = {
                        mapToProperty: mapProperty,
                        condition: condition,
                        alias: aliasObj,
                        entities: []
                    };
                    this.relationCountMetas.push(relationCountMeta);
                    return this;
                };
                /**
                 * Sets WHERE condition in the query builder.
                 * If you had previously WHERE expression defined,
                 * calling this function will override previously set WHERE conditions.
                 * Additionally you can add parameters used in where expression.
                 */
                QueryBuilder.prototype.where = function (where, parameters) {
                    this.wheres.push({ type: "simple", condition: where });
                    if (parameters)
                        this.setParameters(parameters);
                    return this;
                };
                /**
                 * Adds new AND WHERE condition in the query builder.
                 * Additionally you can add parameters used in where expression.
                 */
                QueryBuilder.prototype.andWhere = function (where, parameters) {
                    this.wheres.push({ type: "and", condition: where });
                    if (parameters)
                        this.setParameters(parameters);
                    return this;
                };
                /**
                 * Adds new AND WHERE with conditions for the given ids.
                 *
                 * @experimental Maybe this method should be moved to repository?
                 */
                QueryBuilder.prototype.andWhereInIds = function (ids) {
                    var _a = this.createWhereIdsExpression(ids), whereExpression = _a[0], parameters = _a[1];
                    this.andWhere(whereExpression, parameters);
                    return this;
                };
                /**
                 * Adds new OR WHERE condition in the query builder.
                 * Additionally you can add parameters used in where expression.
                 */
                QueryBuilder.prototype.orWhere = function (where, parameters) {
                    this.wheres.push({ type: "or", condition: where });
                    if (parameters)
                        this.setParameters(parameters);
                    return this;
                };
                /**
                 * Adds new OR WHERE with conditions for the given ids.
                 *
                 * @experimental Maybe this method should be moved to repository?
                 */
                QueryBuilder.prototype.orWhereInIds = function (ids) {
                    var _a = this.createWhereIdsExpression(ids), whereExpression = _a[0], parameters = _a[1];
                    this.orWhere(whereExpression, parameters);
                    return this;
                };
                /**
                 * Sets HAVING condition in the query builder.
                 * If you had previously HAVING expression defined,
                 * calling this function will override previously set HAVING conditions.
                 * Additionally you can add parameters used in where expression.
                 */
                QueryBuilder.prototype.having = function (having, parameters) {
                    this.havings.push({ type: "simple", condition: having });
                    if (parameters)
                        this.setParameters(parameters);
                    return this;
                };
                /**
                 * Adds new AND HAVING condition in the query builder.
                 * Additionally you can add parameters used in where expression.
                 */
                QueryBuilder.prototype.andHaving = function (having, parameters) {
                    this.havings.push({ type: "and", condition: having });
                    if (parameters)
                        this.setParameters(parameters);
                    return this;
                };
                /**
                 * Adds new OR HAVING condition in the query builder.
                 * Additionally you can add parameters used in where expression.
                 */
                QueryBuilder.prototype.orHaving = function (having, parameters) {
                    this.havings.push({ type: "or", condition: having });
                    if (parameters)
                        this.setParameters(parameters);
                    return this;
                };
                /**
                 * Sets GROUP BY condition in the query builder.
                 * If you had previously GROUP BY expression defined,
                 * calling this function will override previously set GROUP BY conditions.
                 */
                QueryBuilder.prototype.groupBy = function (groupBy) {
                    this.groupBys = [groupBy];
                    return this;
                };
                /**
                 * Adds GROUP BY condition in the query builder.
                 */
                QueryBuilder.prototype.addGroupBy = function (groupBy) {
                    this.groupBys.push(groupBy);
                    return this;
                };
                /**
                 * Sets ORDER BY condition in the query builder.
                 * If you had previously ORDER BY expression defined,
                 * calling this function will override previously set ORDER BY conditions.
                 */
                QueryBuilder.prototype.orderBy = function (sort, order) {
                    if (order === void 0) { order = "ASC"; }
                    this.orderBys = (_a = {}, _a[sort] = order, _a);
                    return this;
                    var _a;
                };
                /**
                 * Adds ORDER BY condition in the query builder.
                 */
                QueryBuilder.prototype.addOrderBy = function (sort, order) {
                    if (order === void 0) { order = "ASC"; }
                    this.orderBys[sort] = order;
                    return this;
                };
                /**
                 * Set's LIMIT - maximum number of rows to be selected.
                 * NOTE that it may not work as you expect if you are using joins.
                 * If you want to implement pagination, and you are having join in your query,
                 * then use instead setMaxResults instead.
                 */
                QueryBuilder.prototype.setLimit = function (limit) {
                    this.limit = limit;
                    return this;
                };
                /**
                 * Set's OFFSET - selection offset.
                 * NOTE that it may not work as you expect if you are using joins.
                 * If you want to implement pagination, and you are having join in your query,
                 * then use instead setFirstResult instead.
                 */
                QueryBuilder.prototype.setOffset = function (offset) {
                    this.offset = offset;
                    return this;
                };
                /**
                 * Set's maximum number of entities to be selected.
                 */
                QueryBuilder.prototype.setMaxResults = function (maxResults) {
                    this.maxResults = maxResults;
                    return this;
                };
                /**
                 * Set's offset of entities to be selected.
                 */
                QueryBuilder.prototype.setFirstResult = function (firstResult) {
                    this.firstResult = firstResult;
                    return this;
                };
                /**
                 * Sets given parameter's value.
                 */
                QueryBuilder.prototype.setParameter = function (key, value) {
                    this.parameters[key] = value;
                    return this;
                };
                /**
                 * Adds all parameters from the given object.
                 * Unlike setParameters method it does not clear all previously set parameters.
                 */
                QueryBuilder.prototype.setParameters = function (parameters) {
                    var _this = this;
                    Object.keys(parameters).forEach(function (key) {
                        _this.parameters[key] = parameters[key];
                    });
                    return this;
                };
                /**
                 * Adds all parameters from the given object.
                 * Unlike setParameters method it does not clear all previously set parameters.
                 *
                 * @deprecated use setParameters instead
                 */
                QueryBuilder.prototype.addParameters = function (parameters) {
                    var _this = this;
                    Object.keys(parameters).forEach(function (key) {
                        _this.parameters[key] = parameters[key];
                    });
                    return this;
                };
                /**
                 * Gets all parameters.
                 */
                QueryBuilder.prototype.getParameters = function () {
                    var parameters = Object.assign({}, this.parameters);
                    // add discriminator column parameter if it exist
                    if (!this.fromTableName) {
                        var mainMetadata = this.connection.getMetadata(this.aliasMap.mainAlias.target);
                        if (mainMetadata.hasDiscriminatorColumn)
                            parameters["discriminatorColumnValue"] = mainMetadata.discriminatorValue;
                    }
                    return parameters;
                };
                /**
                 * Gets generated sql that will be executed.
                 * Parameters in the query are escaped for the currently used driver.
                 */
                QueryBuilder.prototype.getSql = function () {
                    var sql = this.createSelectExpression();
                    sql += this.createJoinExpression();
                    sql += this.createJoinRelationIdsExpression();
                    sql += this.createWhereExpression();
                    sql += this.createGroupByExpression();
                    sql += this.createHavingExpression();
                    sql += this.createOrderByExpression();
                    sql += this.createLimitExpression();
                    sql += this.createOffsetExpression();
                    sql = this.connection.driver.escapeQueryWithParameters(sql, this.parameters)[0];
                    return sql;
                };
                /**
                 * Gets generated sql without parameters being replaced.
                 *
                 * @experimental
                 */
                QueryBuilder.prototype.getGeneratedQuery = function () {
                    var sql = this.createSelectExpression();
                    sql += this.createJoinExpression();
                    sql += this.createJoinRelationIdsExpression();
                    sql += this.createWhereExpression();
                    sql += this.createGroupByExpression();
                    sql += this.createHavingExpression();
                    sql += this.createOrderByExpression();
                    sql += this.createLimitExpression();
                    sql += this.createOffsetExpression();
                    return sql;
                };
                /**
                 * Gets sql to be executed with all parameters used in it.
                 *
                 * @experimental
                 */
                QueryBuilder.prototype.getSqlWithParameters = function (options) {
                    var sql = this.createSelectExpression();
                    sql += this.createJoinExpression();
                    sql += this.createJoinRelationIdsExpression();
                    sql += this.createWhereExpression();
                    sql += this.createGroupByExpression();
                    sql += this.createHavingExpression();
                    if (!options || !options.skipOrderBy)
                        sql += this.createOrderByExpression();
                    sql += this.createLimitExpression();
                    sql += this.createOffsetExpression();
                    return this.connection.driver.escapeQueryWithParameters(sql, this.getParameters());
                };
                /**
                 * Executes sql generated by query builder and returns raw database results.
                 */
                QueryBuilder.prototype.execute = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var queryRunner, _a, sql, parameters;
                        return __generator(this, function (_b) {
                            switch (_b.label) {
                                case 0: return [4 /*yield*/, this.getQueryRunner()];
                                case 1:
                                    queryRunner = _b.sent();
                                    _a = this.getSqlWithParameters(), sql = _a[0], parameters = _a[1];
                                    _b.label = 2;
                                case 2:
                                    _b.trys.push([2, , 4, 7]);
                                    return [4 /*yield*/, queryRunner.query(sql, parameters)];
                                case 3: return [2 /*return*/, _b.sent()]; // await is needed here because we are using finally
                                case 4:
                                    if (!this.hasOwnQueryRunner()) return [3 /*break*/, 6];
                                    return [4 /*yield*/, queryRunner.release()];
                                case 5:
                                    _b.sent();
                                    _b.label = 6;
                                case 6: return [7 /*endfinally*/];
                                case 7: return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Executes sql generated by query builder and returns object with raw results and entities created from them.
                 */
                QueryBuilder.prototype.getEntitiesAndRawResults = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var queryRunner, mainAliasName, rawResults, _a, sql, parameters, _b, selects, orderBys, distinctAlias_1, metadata_1, idsQuery, _c, sql, parameters;
                        return __generator(this, function (_d) {
                            switch (_d.label) {
                                case 0:
                                    if (!this.aliasMap.hasMainAlias)
                                        throw new Error("Alias is not set. Looks like nothing is selected. Use select*, delete, update method to set an alias.");
                                    return [4 /*yield*/, this.getQueryRunner()];
                                case 1:
                                    queryRunner = _d.sent();
                                    mainAliasName = this.fromTableName ? this.fromTableName : this.aliasMap.mainAlias.name;
                                    if (!(this.firstResult || this.maxResults)) return [3 /*break*/, 8];
                                    _a = this.getSqlWithParameters({ skipOrderBy: true }), sql = _a[0], parameters = _a[1];
                                    _b = this.createOrderByCombinedWithSelectExpression("distinctAlias"), selects = _b[0], orderBys = _b[1];
                                    distinctAlias_1 = this.connection.driver.escapeTableName("distinctAlias");
                                    metadata_1 = this.connection.getMetadata(this.fromEntity.alias.target);
                                    idsQuery = "SELECT ";
                                    idsQuery += metadata_1.primaryColumns.map(function (primaryColumn, index) {
                                        var propertyName = _this.connection.driver.escapeAliasName(mainAliasName + "_" + primaryColumn.name);
                                        if (index === 0) {
                                            return "DISTINCT(" + distinctAlias_1 + "." + propertyName + ") as ids_" + primaryColumn.name;
                                        }
                                        else {
                                            return distinctAlias_1 + "." + propertyName + ") as ids_" + primaryColumn.name;
                                        }
                                    }).join(", ");
                                    if (selects.length > 0)
                                        idsQuery += ", " + selects;
                                    idsQuery += " FROM (" + sql + ") " + distinctAlias_1; // TODO: WHAT TO DO WITH PARAMETERS HERE? DO THEY WORK?
                                    if (orderBys.length > 0) {
                                        idsQuery += " ORDER BY " + orderBys;
                                    }
                                    else {
                                        idsQuery += " ORDER BY \"ids_" + metadata_1.firstPrimaryColumn.name + "\""; // this is required for mssql driver if firstResult is used. Other drivers don't care about it
                                    }
                                    if (this.connection.driver instanceof SqlServerDriver_1.SqlServerDriver) {
                                        if (this.firstResult || this.maxResults) {
                                            idsQuery += " OFFSET " + (this.firstResult || 0) + " ROWS";
                                            if (this.maxResults)
                                                idsQuery += " FETCH NEXT " + this.maxResults + " ROWS ONLY";
                                        }
                                    }
                                    else {
                                        if (this.maxResults)
                                            idsQuery += " LIMIT " + this.maxResults;
                                        if (this.firstResult)
                                            idsQuery += " OFFSET " + this.firstResult;
                                    }
                                    _d.label = 2;
                                case 2:
                                    _d.trys.push([2, , 4, 7]);
                                    return [4 /*yield*/, queryRunner.query(idsQuery, parameters)
                                            .then(function (results) {
                                            rawResults = results;
                                            if (results.length === 0)
                                                return [];
                                            var condition = "";
                                            var parameters = {};
                                            if (metadata_1.hasMultiplePrimaryKeys) {
                                                condition = results.map(function (result) {
                                                    return metadata_1.primaryColumns.map(function (primaryColumn) {
                                                        parameters["ids_" + primaryColumn.propertyName] = result["ids_" + primaryColumn.propertyName];
                                                        return mainAliasName + "." + primaryColumn.propertyName + "=:ids_" + primaryColumn.propertyName;
                                                    }).join(" AND ");
                                                }).join(" OR ");
                                            }
                                            else {
                                                var ids = results.map(function (result) { return result["ids_" + metadata_1.firstPrimaryColumn.propertyName]; });
                                                var areAllNumbers = ids.map(function (id) { return typeof id === "number"; });
                                                if (areAllNumbers) {
                                                    // fixes #190. if all numbers then its safe to perform query without parameter
                                                    condition = mainAliasName + "." + metadata_1.firstPrimaryColumn.propertyName + " IN (" + ids.join(", ") + ")";
                                                }
                                                else {
                                                    parameters["ids"] = ids;
                                                    condition = mainAliasName + "." + metadata_1.firstPrimaryColumn.propertyName + " IN (:ids)";
                                                }
                                            }
                                            var _a = _this.clone({ queryRunnerProvider: _this.queryRunnerProvider })
                                                .andWhere(condition, parameters)
                                                .getSqlWithParameters(), queryWithIdsSql = _a[0], queryWithIdsParameters = _a[1];
                                            return queryRunner.query(queryWithIdsSql, queryWithIdsParameters);
                                        })
                                            .then(function (results) {
                                            return _this.rawResultsToEntities(results);
                                        })
                                            .then(function (results) {
                                            return _this.loadRelationCounts(queryRunner, results)
                                                .then(function (counts) {
                                                // console.log("counts: ", counts);
                                                return results;
                                            });
                                        })
                                            .then(function (results) {
                                            if (!_this.fromTableName)
                                                return _this.connection.broadcaster.broadcastLoadEventsForAll(_this.aliasMap.mainAlias.target, results).then(function () { return results; });
                                            return results;
                                        })
                                            .then(function (results) {
                                            return {
                                                entities: results,
                                                rawResults: rawResults
                                            };
                                        })];
                                case 3: return [2 /*return*/, _d.sent()];
                                case 4:
                                    if (!this.hasOwnQueryRunner()) return [3 /*break*/, 6];
                                    return [4 /*yield*/, queryRunner.release()];
                                case 5:
                                    _d.sent();
                                    _d.label = 6;
                                case 6: return [7 /*endfinally*/];
                                case 7: return [3 /*break*/, 14];
                                case 8:
                                    _c = this.getSqlWithParameters(), sql = _c[0], parameters = _c[1];
                                    _d.label = 9;
                                case 9:
                                    _d.trys.push([9, , 11, 14]);
                                    return [4 /*yield*/, queryRunner.query(sql, parameters)
                                            .then(function (results) {
                                            rawResults = results;
                                            return _this.rawResultsToEntities(results);
                                        })
                                            .then(function (results) {
                                            return _this.loadRelationCounts(queryRunner, results)
                                                .then(function (counts) {
                                                // console.log("counts: ", counts);
                                                return results;
                                            });
                                        })
                                            .then(function (results) {
                                            if (!_this.fromTableName) {
                                                return _this.connection.broadcaster
                                                    .broadcastLoadEventsForAll(_this.aliasMap.mainAlias.target, results)
                                                    .then(function () { return results; });
                                            }
                                            return results;
                                        })
                                            .then(function (results) {
                                            return {
                                                entities: results,
                                                rawResults: rawResults
                                            };
                                        })];
                                case 10: 
                                // console.log(sql);
                                return [2 /*return*/, _d.sent()];
                                case 11:
                                    if (!this.hasOwnQueryRunner()) return [3 /*break*/, 13];
                                    return [4 /*yield*/, queryRunner.release()];
                                case 12:
                                    _d.sent();
                                    _d.label = 13;
                                case 13: return [7 /*endfinally*/];
                                case 14: return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Gets count - number of entities selected by sql generated by this query builder.
                 * Count excludes all limitations set by setFirstResult and setMaxResults methods call.
                 */
                QueryBuilder.prototype.getCount = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var queryRunner, mainAlias, metadata, distinctAlias, countSql, countQuery, _a, countQuerySql, countQueryParameters, results;
                        return __generator(this, function (_b) {
                            switch (_b.label) {
                                case 0: return [4 /*yield*/, this.getQueryRunner()];
                                case 1:
                                    queryRunner = _b.sent();
                                    mainAlias = this.fromTableName ? this.fromTableName : this.aliasMap.mainAlias.name;
                                    metadata = this.connection.getMetadata(this.fromEntity.alias.target);
                                    distinctAlias = this.connection.driver.escapeAliasName(mainAlias);
                                    countSql = "COUNT(" + metadata.primaryColumnsWithParentIdColumns.map(function (primaryColumn, index) {
                                        var propertyName = _this.connection.driver.escapeColumnName(primaryColumn.name);
                                        if (index === 0) {
                                            return "DISTINCT(" + distinctAlias + "." + propertyName + ")";
                                        }
                                        else {
                                            return distinctAlias + "." + propertyName + ")";
                                        }
                                    }).join(", ") + ") as cnt";
                                    countQuery = this
                                        .clone({
                                        queryRunnerProvider: this.queryRunnerProvider,
                                        skipOrderBys: true,
                                        ignoreParentTablesJoins: true,
                                        skipLimit: true,
                                        skipOffset: true
                                    })
                                        .select(countSql);
                                    _a = countQuery.getSqlWithParameters(), countQuerySql = _a[0], countQueryParameters = _a[1];
                                    _b.label = 2;
                                case 2:
                                    _b.trys.push([2, , 4, 7]);
                                    return [4 /*yield*/, queryRunner.query(countQuerySql, countQueryParameters)];
                                case 3:
                                    results = _b.sent();
                                    if (!results || !results[0] || !results[0]["cnt"])
                                        return [2 /*return*/, 0];
                                    return [2 /*return*/, parseInt(results[0]["cnt"])];
                                case 4:
                                    if (!this.hasOwnQueryRunner()) return [3 /*break*/, 6];
                                    return [4 /*yield*/, queryRunner.release()];
                                case 5:
                                    _b.sent();
                                    _b.label = 6;
                                case 6: return [7 /*endfinally*/];
                                case 7: return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Gets all raw results returned by execution of generated query builder sql.
                 */
                QueryBuilder.prototype.getRawMany = function () {
                    return this.execute();
                };
                /**
                 * Gets first raw result returned by execution of generated query builder sql.
                 */
                QueryBuilder.prototype.getRawOne = function () {
                    return this.getRawMany().then(function (results) { return results[0]; });
                };
                /**
                 * Gets entities and count returned by execution of generated query builder sql.
                 */
                QueryBuilder.prototype.getManyAndCount = function () {
                    // todo: share database connection and counter
                    return Promise.all([
                        this.getMany(),
                        this.getCount()
                    ]);
                };
                /**
                 * Gets entities returned by execution of generated query builder sql.
                 */
                QueryBuilder.prototype.getMany = function () {
                    return this.getEntitiesAndRawResults().then(function (results) {
                        return results.entities;
                    });
                };
                /**
                 * Gets single entity returned by execution of generated query builder sql.
                 */
                QueryBuilder.prototype.getOne = function () {
                    return this.getMany().then(function (entities) { return entities[0]; });
                };
                /**
                 * Clones query builder as it is.
                 */
                QueryBuilder.prototype.clone = function (options) {
                    var _this = this;
                    var qb = new QueryBuilder(this.connection, options ? options.queryRunnerProvider : undefined);
                    if (options && options.ignoreParentTablesJoins)
                        qb.ignoreParentTablesJoins = options.ignoreParentTablesJoins;
                    switch (this.type) {
                        case "select":
                            qb.select(this.selects);
                            break;
                        case "update":
                            qb.update(this.updateQuerySet);
                            break;
                        case "delete":
                            qb.delete();
                            break;
                    }
                    if (this.fromEntity && this.fromEntity.alias && this.fromEntity.alias.target) {
                        qb.from(this.fromEntity.alias.target, this.fromEntity.alias.name);
                    }
                    else if (this.fromTableName) {
                        qb.fromTable(this.fromTableName, this.fromTableAlias);
                    }
                    this.joins.forEach(function (join) {
                        var property = join.tableName || join.alias.target || (join.alias.parentAliasName + "." + join.alias.parentPropertyName);
                        qb.join(join.type, property, join.alias.name, join.condition || "", undefined, join.mapToProperty, join.isMappingMany);
                    });
                    this.groupBys.forEach(function (groupBy) { return qb.addGroupBy(groupBy); });
                    this.wheres.forEach(function (where) {
                        switch (where.type) {
                            case "simple":
                                qb.where(where.condition);
                                break;
                            case "and":
                                qb.andWhere(where.condition);
                                break;
                            case "or":
                                qb.orWhere(where.condition);
                                break;
                        }
                    });
                    this.havings.forEach(function (having) {
                        switch (having.type) {
                            case "simple":
                                qb.having(having.condition);
                                break;
                            case "and":
                                qb.andHaving(having.condition);
                                break;
                            case "or":
                                qb.orHaving(having.condition);
                                break;
                        }
                    });
                    if (!options || !options.skipOrderBys)
                        Object.keys(this.orderBys).forEach(function (columnName) { return qb.addOrderBy(columnName, _this.orderBys[columnName]); });
                    Object.keys(this.parameters).forEach(function (key) { return qb.setParameter(key, _this.parameters[key]); });
                    if (!options || !options.skipLimit)
                        qb.setLimit(this.limit);
                    if (!options || !options.skipOffset)
                        qb.setOffset(this.offset);
                    qb.setFirstResult(this.firstResult)
                        .setMaxResults(this.maxResults);
                    return qb;
                };
                /**
                 * Enables special query builder options.
                 */
                QueryBuilder.prototype.enableOption = function (option) {
                    switch (option) {
                        case "RELATION_ID_VALUES":
                            this.enableRelationIdValues = true;
                    }
                    return this;
                };
                // -------------------------------------------------------------------------
                // Protected Methods
                // -------------------------------------------------------------------------
                QueryBuilder.prototype.loadRelationCounts = function (queryRunner, results) {
                    var _this = this;
                    var promises = this.relationCountMetas.map(function (relationCountMeta) {
                        var parentAlias = relationCountMeta.alias.parentAliasName;
                        var foundAlias = _this.aliasMap.findAliasByName(parentAlias);
                        if (!foundAlias)
                            throw new Error("Alias \"" + parentAlias + "\" was not found");
                        var parentMetadata = _this.aliasMap.getEntityMetadataByAlias(foundAlias);
                        if (!parentMetadata)
                            throw new Error("Cannot get entity metadata for the given alias " + foundAlias.name);
                        var relation = parentMetadata.findRelationWithPropertyName(relationCountMeta.alias.parentPropertyName);
                        var queryBuilder = new QueryBuilder(_this.connection, _this.queryRunnerProvider);
                        var condition = "";
                        var metadata = _this.aliasMap.getEntityMetadataByAlias(relationCountMeta.alias);
                        if (!metadata)
                            throw new Error("Cannot get entity metadata for the given alias " + relationCountMeta.alias.name);
                        var joinTableName = metadata.table.name;
                        var junctionMetadata = relation.junctionEntityMetadata;
                        var appendedCondition = relationCountMeta.condition ? " AND " + _this.replacePropertyNames(relationCountMeta.condition) : "";
                        /*if (relation.isManyToMany) {
                         const junctionTable = junctionMetadata.table.name;
                         const junctionAlias = relationCountMeta.alias.parentAliasName + "_" + relationCountMeta.alias.name;
                         const joinAlias = relationCountMeta.alias.name;
                         const joinTable = relation.isOwning ? relation.joinTable : relation.inverseRelation.joinTable; // not sure if this is correct
                         const joinTableColumn = joinTable.referencedColumn.name; // not sure if this is correct
                         const inverseJoinColumnName = joinTable.inverseReferencedColumn.name; // not sure if this is correct
            
                         let condition1 = "", condition2 = "";
                         if (relation.isOwning) {
                         condition1 = junctionAlias + "." + junctionMetadata.columns[0].name + "=" + parentAlias + "." + joinTableColumn;
                         condition2 = joinAlias + "." + inverseJoinColumnName + "=" + junctionAlias + "." + junctionMetadata.columns[1].name;
                         } else {
                         condition1 = junctionAlias + "." + junctionMetadata.columns[1].name + "=" + parentAlias + "." + joinTableColumn;
                         condition2 = joinAlias + "." + inverseJoinColumnName + "=" + junctionAlias + "." + junctionMetadata.columns[0].name;
                         }
            
                         condition = " LEFT JOIN " + junctionTable + " " + junctionAlias + " " + relationCountMeta.conditionType + " " + condition1 +
                         " LEFT JOIN " + joinTableName + " " + joinAlias + " " + relationCountMeta.conditionType + " " + condition2 + appendedCondition;
            
                         } else if (relation.isManyToOne || (relation.isOneToOne && relation.isOwning)) {
                         const joinTableColumn = relation.joinColumn.referencedColumn.name;
                         const condition2 = relationCountMeta.alias.name + "." + joinTableColumn + "=" + parentAlias + "." + relation.name;
                         condition = " LEFT JOIN " + joinTableName + " " + relationCountMeta.alias.name + " " + relationCountMeta.conditionType + " " + condition2 + appendedCondition;
            
                         } else {
                         throw new Error(`Relation count can be applied only `); // this should be done on entity build
                         }*/
                        // if (relationCountMeta.condition)
                        //     condition += relationCountMeta.condition;
                        // relationCountMeta.alias.target;
                        // todo: FIX primaryColumn usages
                        var ids = relationCountMeta.entities
                            .map(function (entityWithMetadata) { return entityWithMetadata.metadata.getEntityIdMap(entityWithMetadata.entity); })
                            .filter(function (idMap) { return idMap !== undefined; })
                            .map(function (idMap) { return idMap[parentMetadata.primaryColumn.propertyName]; });
                        if (!ids || !ids.length)
                            return Promise.resolve(); // todo: need to set zero to relationCount column in this case?
                        return queryBuilder
                            .select(parentMetadata.name + "." + parentMetadata.primaryColumn.propertyName + " AS id")
                            .addSelect("COUNT(" + (_this.connection.driver.escapeAliasName(relation.propertyName) + "." + _this.connection.driver.escapeColumnName(relation.inverseEntityMetadata.primaryColumn.name)) + ") as cnt")
                            .from(parentMetadata.target, parentMetadata.name)
                            .leftJoin(parentMetadata.name + "." + relation.propertyName, relation.propertyName, relationCountMeta.condition)
                            .setParameters(_this.parameters)
                            .where(parentMetadata.name + "." + parentMetadata.primaryColumn.propertyName + " IN (:relationCountIds)", { relationCountIds: ids })
                            .groupBy(parentMetadata.name + "." + parentMetadata.primaryColumn.propertyName)
                            .getRawMany()
                            .then(function (results) {
                            // console.log(relationCountMeta.entities);
                            relationCountMeta.entities.forEach(function (entityWithMetadata) {
                                var entityId = entityWithMetadata.entity[entityWithMetadata.metadata.primaryColumn.propertyName];
                                var entityResult = results.find(function (result) {
                                    return entityId === _this.connection.driver.prepareHydratedValue(result.id, entityWithMetadata.metadata.primaryColumn);
                                });
                                if (entityResult) {
                                    if (relationCountMeta.mapToProperty) {
                                        var _a = relationCountMeta.mapToProperty.split("."), parentName = _a[0], propertyName = _a[1];
                                        // todo: right now mapping is working only on the currently countRelation class, but
                                        // different properties are working. make different classes to work too
                                        entityWithMetadata.entity[propertyName] = parseInt(entityResult.cnt);
                                    }
                                    else if (relation.countField) {
                                        entityWithMetadata.entity[relation.countField] = parseInt(entityResult.cnt);
                                    }
                                }
                            });
                        });
                    });
                    return Promise.all(promises);
                };
                QueryBuilder.prototype.rawResultsToEntities = function (results) {
                    var transformer = new RawSqlResultsToEntityTransformer_1.RawSqlResultsToEntityTransformer(this.connection.driver, this.aliasMap, this.extractJoinMappings(), this.relationCountMetas, this.enableRelationIdValues);
                    return transformer.transform(results);
                };
                QueryBuilder.prototype.createSelectExpression = function () {
                    // todo throw exception if selects or from is missing
                    var _this = this;
                    var alias = "", tableName;
                    var allSelects = [];
                    if (this.fromTableName) {
                        tableName = this.fromTableName;
                        alias = this.fromTableAlias;
                        // console.log("ALIAS F:", alias);
                    }
                    else if (this.fromEntity) {
                        var metadata = this.aliasMap.getEntityMetadataByAlias(this.fromEntity.alias);
                        if (!metadata)
                            throw new Error("Cannot get entity metadata for the given alias " + this.fromEntity.alias.name);
                        tableName = metadata.table.name;
                        alias = this.fromEntity.alias.name;
                        // console.log("ALIAS N:", this.fromEntity.alias);
                        // console.log("ALIAS N:", alias);
                        // add select from the main table
                        if (this.selects.indexOf(alias) !== -1) {
                            metadata.columns.forEach(function (column) {
                                allSelects.push(_this.connection.driver.escapeAliasName(alias) + "." + _this.connection.driver.escapeColumnName(column.name) + " AS " + _this.connection.driver.escapeAliasName(alias + "_" + column.name));
                            });
                        }
                    }
                    else {
                        throw new Error("No from given");
                    }
                    // add selects from joins
                    this.joins
                        .filter(function (join) { return _this.selects.indexOf(join.alias.name) !== -1; })
                        .forEach(function (join) {
                        var joinMetadata = _this.aliasMap.getEntityMetadataByAlias(join.alias);
                        if (joinMetadata) {
                            joinMetadata.columns.forEach(function (column) {
                                allSelects.push(_this.connection.driver.escapeAliasName(join.alias.name) + "." + _this.connection.driver.escapeColumnName(column.name) + " AS " + _this.connection.driver.escapeAliasName(join.alias.name + "_" + column.name));
                            });
                        }
                        else {
                            allSelects.push(_this.connection.driver.escapeAliasName(join.alias.name));
                        }
                    });
                    if (!this.ignoreParentTablesJoins && !this.fromTableName) {
                        var metadata = this.connection.getMetadata(this.aliasMap.mainAlias.target);
                        if (metadata.parentEntityMetadata && metadata.parentIdColumns) {
                            var alias_1 = "parentIdColumn_" + this.connection.driver.escapeAliasName(metadata.parentEntityMetadata.table.name);
                            metadata.parentEntityMetadata.columns.forEach(function (column) {
                                allSelects.push(alias_1 + "." + _this.connection.driver.escapeColumnName(column.name) + " AS " + alias_1 + "_" + _this.connection.driver.escapeAliasName(column.name));
                            });
                        }
                    }
                    // add selects from relation id joins
                    this.joinRelationIds.forEach(function (join) {
                        // const joinMetadata = this.aliasMap.getEntityMetadataByAlias(join.alias);
                        var parentAlias = join.alias.parentAliasName;
                        var foundAlias = _this.aliasMap.findAliasByName(parentAlias);
                        if (!foundAlias)
                            throw new Error("Alias \"" + parentAlias + "\" was not found");
                        var parentMetadata = _this.aliasMap.getEntityMetadataByAlias(foundAlias);
                        if (!parentMetadata)
                            throw new Error("Cannot get entity metadata for the given alias " + foundAlias.name);
                        var relation = parentMetadata.findRelationWithPropertyName(join.alias.parentPropertyName);
                        var junctionMetadata = relation.junctionEntityMetadata;
                        // const junctionTable = junctionMetadata.table.name;
                        junctionMetadata.columns.forEach(function (column) {
                            allSelects.push(_this.connection.driver.escapeAliasName(join.alias.name) + "." + _this.connection.driver.escapeColumnName(column.name) + " AS " + _this.connection.driver.escapeAliasName(join.alias.name + "_" + column.name));
                        });
                    });
                    //
                    /*if (this.enableRelationIdValues) {
                        const parentMetadata = this.aliasMap.getEntityMetadataByAlias(this.aliasMap.mainAlias);
                        if (!parentMetadata)
                            throw new Error("Cannot get entity metadata for the given alias " + this.aliasMap.mainAlias.name);
            
                        const metadata = this.connection.entityMetadatas.findByTarget(this.aliasMap.mainAlias.target);
                        metadata.manyToManyRelations.forEach(relation => {
            
                            const junctionMetadata = relation.junctionEntityMetadata;
                            junctionMetadata.columns.forEach(column => {
                                const select = this.connection.driver.escapeAliasName(this.aliasMap.mainAlias.name + "_" + junctionMetadata.table.name + "_ids") + "." +
                                    this.connection.driver.escapeColumnName(column.name) + " AS " +
                                    this.connection.driver.escapeAliasName(this.aliasMap.mainAlias.name + "_" + relation.name + "_ids_" + column.name);
                                allSelects.push(select);
                            });
                        });
                    }*/
                    // add all other selects
                    this.selects.filter(function (select) {
                        return select !== alias && !_this.joins.find(function (join) { return join.alias.name === select; });
                    }).forEach(function (select) { return allSelects.push(_this.replacePropertyNames(select)); });
                    // if still selection is empty, then simply set it to all (*)
                    if (allSelects.length === 0)
                        allSelects.push("*");
                    // create a selection query
                    switch (this.type) {
                        case "select":
                            return "SELECT " + allSelects.join(", ") + " FROM " + this.connection.driver.escapeTableName(tableName) + " " + this.connection.driver.escapeAliasName(alias);
                        case "delete":
                            return "DELETE FROM " + this.connection.driver.escapeTableName(tableName);
                        // return "DELETE " + (alias ? this.connection.driver.escapeAliasName(alias) : "") + " FROM " + this.connection.driver.escapeTableName(tableName) + " " + (alias ? this.connection.driver.escapeAliasName(alias) : ""); // TODO: only mysql supports aliasing, so what to do with aliases in DELETE queries? right now aliases are used however we are relaying that they will always match a table names
                        case "update":
                            var updateSet = Object.keys(this.updateQuerySet).map(function (key) { return key + "=:updateQuerySet_" + key; });
                            var params = Object.keys(this.updateQuerySet).reduce(function (object, key) {
                                // todo: map propertyNames to names ?
                                object["updateQuerySet_" + key] = _this.updateQuerySet[key];
                                return object;
                            }, {});
                            this.setParameters(params);
                            return "UPDATE " + tableName + " " + (alias ? this.connection.driver.escapeAliasName(alias) : "") + " SET " + updateSet;
                    }
                    throw new Error("No query builder type is specified.");
                };
                QueryBuilder.prototype.createWhereExpression = function () {
                    var _this = this;
                    var conditions = this.wheres.map(function (where, index) {
                        switch (where.type) {
                            case "and":
                                return (index > 0 ? "AND " : "") + _this.replacePropertyNames(where.condition);
                            case "or":
                                return (index > 0 ? "OR " : "") + _this.replacePropertyNames(where.condition);
                            default:
                                return _this.replacePropertyNames(where.condition);
                        }
                    }).join(" ");
                    if (!this.fromTableName) {
                        var mainMetadata = this.connection.getMetadata(this.aliasMap.mainAlias.target);
                        if (mainMetadata.hasDiscriminatorColumn)
                            return " WHERE " + (conditions.length ? "(" + conditions + ") AND" : "") + " " + mainMetadata.discriminatorColumn.name + "=:discriminatorColumnValue";
                    }
                    if (!conditions.length)
                        return "";
                    return " WHERE " + conditions;
                };
                /**
                 * Replaces all entity's propertyName to name in the given statement.
                 */
                QueryBuilder.prototype.replacePropertyNames = function (statement) {
                    var _this = this;
                    this.aliasMap.aliases.forEach(function (alias) {
                        var metadata = _this.aliasMap.getEntityMetadataByAlias(alias);
                        if (!metadata)
                            return;
                        metadata.embeddeds.forEach(function (embedded) {
                            embedded.columns.forEach(function (column) {
                                var expression = alias.name + "\\." + embedded.propertyName + "\\." + column.propertyName + "([ =]|.{0}$)";
                                statement = statement.replace(new RegExp(expression, "gm"), _this.connection.driver.escapeAliasName(alias.name) + "." + _this.connection.driver.escapeColumnName(column.name) + "$1");
                            });
                            // todo: what about embedded relations here?
                        });
                        metadata.columns.filter(function (column) { return !column.isInEmbedded; }).forEach(function (column) {
                            var expression = alias.name + "\\." + column.propertyName + "([ =]|.{0}$)";
                            statement = statement.replace(new RegExp(expression, "gm"), _this.connection.driver.escapeAliasName(alias.name) + "." + _this.connection.driver.escapeColumnName(column.name) + "$1");
                        });
                        metadata.relationsWithJoinColumns /*.filter(relation => !relation.isInEmbedded)*/.forEach(function (relation) {
                            var expression = alias.name + "\\." + relation.propertyName + "([ =]|.{0}$)";
                            statement = statement.replace(new RegExp(expression, "gm"), _this.connection.driver.escapeAliasName(alias.name) + "." + _this.connection.driver.escapeColumnName(relation.name) + "$1");
                        });
                    });
                    return statement;
                };
                QueryBuilder.prototype.createJoinRelationIdsExpression = function () {
                    var _this = this;
                    return this.joinRelationIds.map(function (join) {
                        var parentAlias = join.alias.parentAliasName;
                        var foundAlias = _this.aliasMap.findAliasByName(parentAlias);
                        if (!foundAlias)
                            throw new Error("Alias \"" + parentAlias + "\" was not found");
                        var parentMetadata = _this.aliasMap.getEntityMetadataByAlias(foundAlias);
                        if (!parentMetadata)
                            throw new Error("Cannot get entity metadata for the given alias " + foundAlias.name);
                        var relation = parentMetadata.findRelationWithPropertyName(join.alias.parentPropertyName);
                        var junctionMetadata = relation.junctionEntityMetadata;
                        var junctionTable = junctionMetadata.table.name;
                        var junctionAlias = join.alias.name;
                        var joinTable = relation.isOwning ? relation.joinTable : relation.inverseRelation.joinTable; // not sure if this is correct
                        var joinTableColumn = joinTable.referencedColumn.name; // not sure if this is correct
                        var condition1 = "";
                        if (relation.isOwning) {
                            condition1 = _this.connection.driver.escapeAliasName(junctionAlias) + "." + _this.connection.driver.escapeColumnName(junctionMetadata.columns[0].name) + "=" + _this.connection.driver.escapeAliasName(parentAlias) + "." + _this.connection.driver.escapeColumnName(joinTableColumn);
                            // condition2 = joinAlias + "." + inverseJoinColumnName + "=" + junctionAlias + "." + junctionMetadata.columns[1].name;
                        }
                        else {
                            condition1 = _this.connection.driver.escapeAliasName(junctionAlias) + "." + _this.connection.driver.escapeColumnName(junctionMetadata.columns[1].name) + "=" + _this.connection.driver.escapeAliasName(parentAlias) + "." + _this.connection.driver.escapeColumnName(joinTableColumn);
                            // condition2 = joinAlias + "." + inverseJoinColumnName + "=" + junctionAlias + "." + junctionMetadata.columns[0].name;
                        }
                        return " " + join.type + " JOIN " + junctionTable + " " + _this.connection.driver.escapeAliasName(junctionAlias) + " ON " + condition1;
                        // " " + joinType + " JOIN " + joinTableName + " " + joinAlias + " " + join.conditionType + " " + condition2 + appendedCondition;
                        // console.log(join);
                        // return " " + join.type + " JOIN " + joinTableName + " " + join.alias.name + " " + (join.condition ? (join.conditionType + " " + join.condition) : "");
                    });
                };
                QueryBuilder.prototype.createJoinExpression = function () {
                    var _this = this;
                    var joins = this.joins.map(function (join) {
                        var joinType = join.type; // === "INNER" ? "INNER" : "LEFT";
                        var joinTableName = join.tableName;
                        if (!joinTableName) {
                            var metadata = _this.aliasMap.getEntityMetadataByAlias(join.alias);
                            if (!metadata)
                                throw new Error("Cannot get entity metadata for the given alias " + join.alias.name);
                            joinTableName = metadata.table.name;
                        }
                        var parentAlias = join.alias.parentAliasName;
                        if (!parentAlias) {
                            return " " + joinType + " JOIN " + _this.connection.driver.escapeTableName(joinTableName) + " " + _this.connection.driver.escapeAliasName(join.alias.name) + " " + (join.condition ? ("ON " + _this.replacePropertyNames(join.condition)) : "");
                        }
                        var foundAlias = _this.aliasMap.findAliasByName(parentAlias);
                        if (!foundAlias)
                            throw new Error("Alias \"" + parentAlias + "\" was not found");
                        var parentMetadata = _this.aliasMap.getEntityMetadataByAlias(foundAlias);
                        if (!parentMetadata)
                            throw new Error("Cannot get entity metadata for the given alias " + foundAlias.name);
                        var relation = parentMetadata.findRelationWithPropertyName(join.alias.parentPropertyName);
                        var junctionMetadata = relation.junctionEntityMetadata;
                        var appendedCondition = join.condition ? " AND " + _this.replacePropertyNames(join.condition) : "";
                        if (relation.isManyToMany) {
                            var junctionTable = junctionMetadata.table.name;
                            var junctionAlias = join.alias.parentAliasName + "_" + join.alias.name;
                            var joinAlias = join.alias.name;
                            var joinTable = relation.isOwning ? relation.joinTable : relation.inverseRelation.joinTable;
                            var joinTableColumn = relation.isOwning ? joinTable.referencedColumn.name : joinTable.inverseReferencedColumn.name;
                            var inverseJoinColumnName = relation.isOwning ? joinTable.inverseReferencedColumn.name : joinTable.referencedColumn.name;
                            var condition1 = "", condition2 = "";
                            if (relation.isOwning) {
                                condition1 = _this.connection.driver.escapeAliasName(junctionAlias) + "." + _this.connection.driver.escapeColumnName(junctionMetadata.columns[0].name) + "=" + _this.connection.driver.escapeAliasName(parentAlias) + "." + _this.connection.driver.escapeColumnName(joinTableColumn);
                                condition2 = _this.connection.driver.escapeAliasName(joinAlias) + "." + _this.connection.driver.escapeColumnName(inverseJoinColumnName) + "=" + _this.connection.driver.escapeAliasName(junctionAlias) + "." + _this.connection.driver.escapeColumnName(junctionMetadata.columns[1].name);
                            }
                            else {
                                condition1 = _this.connection.driver.escapeAliasName(junctionAlias) + "." + _this.connection.driver.escapeColumnName(junctionMetadata.columns[1].name) + "=" + _this.connection.driver.escapeAliasName(parentAlias) + "." + _this.connection.driver.escapeColumnName(joinTableColumn);
                                condition2 = _this.connection.driver.escapeAliasName(joinAlias) + "." + _this.connection.driver.escapeColumnName(inverseJoinColumnName) + "=" + _this.connection.driver.escapeAliasName(junctionAlias) + "." + _this.connection.driver.escapeColumnName(junctionMetadata.columns[0].name);
                            }
                            return " " + joinType + " JOIN " + _this.connection.driver.escapeTableName(junctionTable) + " " + _this.connection.driver.escapeAliasName(junctionAlias) + " ON " + condition1 +
                                " " + joinType + " JOIN " + _this.connection.driver.escapeTableName(joinTableName) + " " + _this.connection.driver.escapeAliasName(joinAlias) + " ON " + condition2 + appendedCondition;
                        }
                        else if (relation.isManyToOne || (relation.isOneToOne && relation.isOwning)) {
                            var joinTableColumn = relation.joinColumn.referencedColumn.name;
                            var condition = _this.connection.driver.escapeAliasName(join.alias.name) + "." + _this.connection.driver.escapeColumnName(joinTableColumn) + "=" + _this.connection.driver.escapeAliasName(parentAlias) + "." + _this.connection.driver.escapeColumnName(relation.name);
                            return " " + joinType + " JOIN " + _this.connection.driver.escapeTableName(joinTableName) + " " + _this.connection.driver.escapeAliasName(join.alias.name) + " ON " + condition + appendedCondition;
                        }
                        else if (relation.isOneToMany || (relation.isOneToOne && !relation.isOwning)) {
                            var joinTableColumn = relation.inverseRelation.joinColumn.referencedColumn.name;
                            var condition = _this.connection.driver.escapeAliasName(join.alias.name) + "." + _this.connection.driver.escapeColumnName(relation.inverseRelation.name) + "=" + _this.connection.driver.escapeAliasName(parentAlias) + "." + _this.connection.driver.escapeColumnName(joinTableColumn);
                            return " " + joinType + " JOIN " + _this.connection.driver.escapeTableName(joinTableName) + " " + _this.connection.driver.escapeAliasName(join.alias.name) + " ON " + condition + appendedCondition;
                        }
                        else {
                            throw new Error("Unexpected relation type"); // this should not be possible
                        }
                    }).join(" ");
                    if (!this.ignoreParentTablesJoins && !this.fromTableName) {
                        var metadata = this.connection.getMetadata(this.aliasMap.mainAlias.target);
                        if (metadata.parentEntityMetadata && metadata.parentIdColumns) {
                            var alias_2 = this.connection.driver.escapeAliasName("parentIdColumn_" + metadata.parentEntityMetadata.table.name);
                            joins += " JOIN " + this.connection.driver.escapeTableName(metadata.parentEntityMetadata.table.name)
                                + " " + alias_2 + " ON ";
                            joins += metadata.parentIdColumns.map(function (parentIdColumn) {
                                return _this.aliasMap.mainAlias.name + "." + parentIdColumn.name + "=" + alias_2 + "." + parentIdColumn.propertyName;
                            });
                        }
                    }
                    /*if (this.enableRelationIdValues) {
                        const parentMetadata = this.aliasMap.getEntityMetadataByAlias(this.aliasMap.mainAlias);
                        if (!parentMetadata)
                            throw new Error("Cannot get entity metadata for the given alias " + this.aliasMap.mainAlias.name);
            
                        const metadata = this.connection.entityMetadatas.findByTarget(this.aliasMap.mainAlias.target);
                        joins += metadata.manyToManyRelations.map(relation => {
            
                            const junctionMetadata = relation.junctionEntityMetadata;
                            const junctionTable = junctionMetadata.table.name;
                            const junctionAlias = this.aliasMap.mainAlias.name + "_" + junctionTable + "_ids";
                            const joinTable = relation.isOwning ? relation.joinTable : relation.inverseRelation.joinTable; // not sure if this is correct
                            const joinTableColumn = joinTable.referencedColumn.name; // not sure if this is correct
            
                            let condition1 = "";
                            if (relation.isOwning) {
                                condition1 = this.connection.driver.escapeAliasName(junctionAlias) + "." +
                                    this.connection.driver.escapeColumnName(junctionMetadata.columns[0].name) + "=" +
                                    this.connection.driver.escapeAliasName(this.aliasMap.mainAlias.name) + "." +
                                    this.connection.driver.escapeColumnName(joinTableColumn);
                            } else {
                                condition1 = this.connection.driver.escapeAliasName(junctionAlias) + "." +
                                    this.connection.driver.escapeColumnName(junctionMetadata.columns[1].name) + "=" +
                                    this.connection.driver.escapeAliasName(this.aliasMap.mainAlias.name) + "." +
                                    this.connection.driver.escapeColumnName(joinTableColumn);
                            }
            
                            return " LEFT JOIN " + junctionTable + " " + this.connection.driver.escapeAliasName(junctionAlias) + " ON " + condition1;
                        }).join(" ");
                    }*/
                    return joins;
                };
                QueryBuilder.prototype.createGroupByExpression = function () {
                    if (!this.groupBys || !this.groupBys.length)
                        return "";
                    return " GROUP BY " + this.replacePropertyNames(this.groupBys.join(", "));
                };
                QueryBuilder.prototype.createHavingExpression = function () {
                    var _this = this;
                    if (!this.havings || !this.havings.length)
                        return "";
                    return " HAVING " + this.havings.map(function (having) {
                        switch (having.type) {
                            case "and":
                                return " AND " + _this.replacePropertyNames(having.condition);
                            case "or":
                                return " OR " + _this.replacePropertyNames(having.condition);
                            default:
                                return " " + _this.replacePropertyNames(having.condition);
                        }
                    }).join(" ");
                };
                QueryBuilder.prototype.createOrderByCombinedWithSelectExpression = function (parentAlias) {
                    var _this = this;
                    // if table has a default order then apply it
                    var orderBys = this.orderBys;
                    if (!Object.keys(orderBys).length && !this.fromTableName) {
                        var metadata = this.connection.getMetadata(this.aliasMap.mainAlias.target);
                        orderBys = metadata.table.orderBy || {};
                    }
                    var selectString = Object.keys(orderBys)
                        .map(function (columnName) {
                        var _a = columnName.split("."), alias = _a[0], column = _a[1], embeddedProperties = _a.slice(2);
                        return _this.connection.driver.escapeAliasName(parentAlias) + "." + _this.connection.driver.escapeColumnName(alias + "_" + column + embeddedProperties.join("_"));
                    })
                        .join(", ");
                    var orderByString = Object.keys(orderBys)
                        .map(function (columnName) {
                        var _a = columnName.split("."), alias = _a[0], column = _a[1], embeddedProperties = _a.slice(2);
                        return _this.connection.driver.escapeAliasName(parentAlias) + "." + _this.connection.driver.escapeColumnName(alias + "_" + column + embeddedProperties.join("_")) + " " + _this.orderBys[columnName];
                    })
                        .join(", ");
                    return [selectString, orderByString];
                };
                QueryBuilder.prototype.createOrderByExpression = function () {
                    var _this = this;
                    var orderBys = this.orderBys;
                    // if table has a default order then apply it
                    if (!Object.keys(orderBys).length && !this.fromTableName) {
                        var metadata = this.connection.getMetadata(this.aliasMap.mainAlias.target);
                        orderBys = metadata.table.orderBy || {};
                    }
                    // if user specified a custom order then apply it
                    if (Object.keys(orderBys).length > 0)
                        return " ORDER BY " + Object.keys(orderBys)
                            .map(function (columnName) {
                            return _this.replacePropertyNames(columnName) + " " + _this.orderBys[columnName];
                        })
                            .join(", ");
                    return "";
                };
                QueryBuilder.prototype.createLimitExpression = function () {
                    if (!this.limit)
                        return "";
                    return " LIMIT " + this.limit;
                };
                QueryBuilder.prototype.createOffsetExpression = function () {
                    if (!this.offset)
                        return "";
                    return " OFFSET " + this.offset;
                };
                QueryBuilder.prototype.extractJoinMappings = function () {
                    var mappings = [];
                    this.joins
                        .filter(function (join) { return !!join.mapToProperty; })
                        .forEach(function (join) {
                        var _a = join.mapToProperty.split("."), parentName = _a[0], propertyName = _a[1];
                        mappings.push({
                            type: "join",
                            alias: join.alias,
                            parentName: parentName,
                            propertyName: propertyName,
                            isMany: join.isMappingMany
                        });
                    });
                    this.joinRelationIds
                        .filter(function (join) { return !!join.mapToProperty; })
                        .forEach(function (join) {
                        var _a = join.mapToProperty.split("."), parentName = _a[0], propertyName = _a[1];
                        mappings.push({
                            type: "relationId",
                            alias: join.alias,
                            parentName: parentName,
                            propertyName: propertyName,
                            isMany: false
                        });
                    });
                    return mappings;
                };
                QueryBuilder.prototype.join = function (joinType, entityOrProperty, alias, condition, options, mapToProperty, isMappingMany) {
                    // todo: entityOrProperty can be a table name. implement if its a table
                    // todo: entityOrProperty can be target name. implement proper behaviour if it is.
                    if (condition === void 0) { condition = ""; }
                    if (isMappingMany === void 0) { isMappingMany = false; }
                    var tableName = "";
                    var aliasObj = new Alias_1.Alias(alias);
                    this.aliasMap.addAlias(aliasObj);
                    if (entityOrProperty instanceof Function) {
                        aliasObj.target = entityOrProperty;
                    }
                    else if (this.isPropertyAlias(entityOrProperty)) {
                        _a = entityOrProperty.split("."), aliasObj.parentAliasName = _a[0], aliasObj.parentPropertyName = _a[1];
                    }
                    else if (typeof entityOrProperty === "string") {
                        tableName = entityOrProperty;
                        if (!mapToProperty)
                            mapToProperty = entityOrProperty;
                    }
                    var join = {
                        type: joinType,
                        alias: aliasObj,
                        tableName: tableName,
                        condition: condition,
                        options: options,
                        mapToProperty: mapToProperty,
                        isMappingMany: isMappingMany
                    };
                    this.joins.push(join);
                    return this;
                    var _a;
                };
                QueryBuilder.prototype.joinRelationId = function (joinType, mapToProperty, property, condition) {
                    if (!this.isPropertyAlias(property))
                        throw new Error("Only entity relations are allowed in the leftJoinRelationId operation"); // todo: also check if that relation really has entityId
                    var _a = property.split("."), parentAliasName = _a[0], parentPropertyName = _a[1];
                    var alias = parentAliasName + "_" + parentPropertyName + "_relation_id";
                    var aliasObj = new Alias_1.Alias(alias);
                    this.aliasMap.addAlias(aliasObj);
                    aliasObj.parentAliasName = parentAliasName;
                    aliasObj.parentPropertyName = parentPropertyName;
                    this.joinRelationIds.push({
                        type: joinType,
                        mapToProperty: mapToProperty,
                        alias: aliasObj,
                        condition: condition
                    });
                    return this;
                };
                QueryBuilder.prototype.isValueSimpleString = function (str) {
                    return /^[A-Za-z0-9_-]+$/.test(str);
                };
                QueryBuilder.prototype.isPropertyAlias = function (str) {
                    if (!(typeof str === "string"))
                        return false;
                    if (str.indexOf(".") === -1)
                        return false;
                    var aliasName = str.split(".")[0];
                    var propertyName = str.split(".")[1];
                    if (!aliasName || !propertyName)
                        return false;
                    var aliasNameRegexp = /^[a-zA-Z0-9_-]+$/;
                    var propertyNameRegexp = aliasNameRegexp;
                    if (!aliasNameRegexp.test(aliasName) || !propertyNameRegexp.test(propertyName))
                        return false;
                    return true;
                };
                /**
                 * Creates "WHERE" expression and variables for the given "ids".
                 */
                QueryBuilder.prototype.createWhereIdsExpression = function (ids) {
                    var _this = this;
                    var metadata = this.connection.getMetadata(this.aliasMap.mainAlias.target);
                    // create shortcuts for better readability
                    var escapeAlias = function (alias) { return _this.connection.driver.escapeAliasName(alias); };
                    var escapeColumn = function (column) { return _this.connection.driver.escapeColumnName(column); };
                    var alias = this.aliasMap.mainAlias.name;
                    var parameters = {};
                    var whereStrings = ids.map(function (id, index) {
                        var whereSubStrings = [];
                        if (metadata.hasMultiplePrimaryKeys) {
                            metadata.primaryColumns.forEach(function (primaryColumn, secondIndex) {
                                whereSubStrings.push(escapeAlias(alias) + "." + escapeColumn(primaryColumn.name) + "=:id_" + index + "_" + secondIndex);
                                parameters["id_" + index + "_" + secondIndex] = id[primaryColumn.name];
                            });
                            metadata.parentIdColumns.forEach(function (primaryColumn, secondIndex) {
                                whereSubStrings.push(escapeAlias(alias) + "." + escapeColumn(id[primaryColumn.name]) + "=:parentId_" + index + "_" + secondIndex);
                                parameters["parentId_" + index + "_" + secondIndex] = id[primaryColumn.propertyName];
                            });
                        }
                        else {
                            if (metadata.primaryColumns.length > 0) {
                                whereSubStrings.push(escapeAlias(alias) + "." + escapeColumn(metadata.firstPrimaryColumn.name) + "=:id_" + index);
                                parameters["id_" + index] = id;
                            }
                            else if (metadata.parentIdColumns.length > 0) {
                                whereSubStrings.push(escapeAlias(alias) + "." + escapeColumn(metadata.parentIdColumns[0].name) + "=:parentId_" + index);
                                parameters["parentId_" + index] = id;
                            }
                        }
                        return whereSubStrings.join(" AND ");
                    });
                    var whereString = whereStrings.length > 1 ? "(" + whereStrings.join(" OR ") + ")" : whereStrings[0];
                    return [whereString, parameters];
                };
                QueryBuilder.prototype.getQueryRunner = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            if (this.queryRunnerProvider instanceof QueryRunnerProvider_1.QueryRunnerProvider) {
                                return [2 /*return*/, this.queryRunnerProvider.provide()];
                            }
                            else {
                                return [2 /*return*/, this.connection.driver.createQueryRunner()];
                            }
                            return [2 /*return*/];
                        });
                    });
                };
                QueryBuilder.prototype.hasOwnQueryRunner = function () {
                    return !this.queryRunnerProvider;
                };
                return QueryBuilder;
            }());
            exports_52("QueryBuilder", QueryBuilder);
        }
    };
});
System.register("typeorm/lazy-loading/LazyRelationsWrapper", ["typeorm/query-builder/QueryBuilder"], function (exports_53, context_53) {
    "use strict";
    var __moduleName = context_53 && context_53.id;
    var QueryBuilder_1, LazyRelationsWrapper;
    return {
        setters: [
            function (QueryBuilder_1_1) {
                QueryBuilder_1 = QueryBuilder_1_1;
            }
        ],
        execute: function () {
            /**
             * This class wraps entities and provides functions there to lazily load its relations.
             */
            LazyRelationsWrapper = (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function LazyRelationsWrapper(connection) {
                    this.connection = connection;
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                LazyRelationsWrapper.prototype.wrap = function (object, relation) {
                    var connection = this.connection;
                    var index = "__" + relation.propertyName + "__";
                    var promiseIndex = "__promise__" + relation.propertyName + "__";
                    var resolveIndex = "__has__" + relation.propertyName + "__";
                    Object.defineProperty(object, relation.propertyName, {
                        get: function () {
                            var _this = this;
                            if (this[resolveIndex] === true)
                                return Promise.resolve(this[index]);
                            if (this[promiseIndex])
                                return this[promiseIndex];
                            // create shortcuts for better readability
                            var escapeAlias = function (alias) { return connection.driver.escapeAliasName(alias); };
                            var escapeColumn = function (column) { return connection.driver.escapeColumnName(column); };
                            var qb = new QueryBuilder_1.QueryBuilder(connection);
                            if (relation.isManyToMany) {
                                if (relation.isManyToManyOwner) {
                                    qb.select(relation.propertyName)
                                        .from(relation.type, relation.propertyName)
                                        .innerJoin(relation.junctionEntityMetadata.table.name, relation.junctionEntityMetadata.table.name, escapeAlias(relation.junctionEntityMetadata.table.name) + "." + escapeColumn(relation.joinTable.joinColumnName) + "=:" + relation.propertyName + "Id AND " +
                                        (escapeAlias(relation.junctionEntityMetadata.table.name) + "." + escapeColumn(relation.joinTable.inverseJoinColumnName) + "=" + escapeAlias(relation.propertyName) + "." + escapeColumn(relation.joinTable.referencedColumn.propertyName)))
                                        .setParameter(relation.propertyName + "Id", this[relation.referencedColumn.propertyName]);
                                }
                                else {
                                    qb.select(relation.propertyName)
                                        .from(relation.type, relation.propertyName)
                                        .innerJoin(relation.junctionEntityMetadata.table.name, relation.junctionEntityMetadata.table.name, escapeAlias(relation.junctionEntityMetadata.table.name) + "." + escapeColumn(relation.inverseRelation.joinTable.inverseJoinColumnName) + "=:" + relation.propertyName + "Id AND " +
                                        (escapeAlias(relation.junctionEntityMetadata.table.name) + "." + escapeColumn(relation.inverseRelation.joinTable.joinColumnName) + "=" + escapeAlias(relation.propertyName) + "." + escapeColumn(relation.inverseRelation.joinTable.referencedColumn.propertyName)))
                                        .setParameter(relation.propertyName + "Id", this[relation.inverseRelation.referencedColumn.propertyName]);
                                }
                                this[promiseIndex] = qb.getMany().then(function (results) {
                                    _this[index] = results;
                                    _this[resolveIndex] = true;
                                    delete _this[promiseIndex];
                                    return _this[index];
                                }).catch(function (err) {
                                    throw err;
                                });
                                return this[promiseIndex];
                            }
                            else if (relation.isOneToMany) {
                                qb.select(relation.propertyName)
                                    .from(relation.inverseRelation.entityMetadata.target, relation.propertyName)
                                    .innerJoin(relation.propertyName + "." + relation.inverseRelation.propertyName, relation.entityMetadata.targetName)
                                    .where(relation.entityMetadata.targetName + "." + relation.inverseEntityMetadata.firstPrimaryColumn.propertyName + "=:id", { id: relation.entityMetadata.getEntityIdMixedMap(this) });
                                this[promiseIndex] = qb.getMany().then(function (results) {
                                    _this[index] = results;
                                    _this[resolveIndex] = true;
                                    delete _this[promiseIndex];
                                    return _this[index];
                                }).catch(function (err) {
                                    throw err;
                                });
                                return this[promiseIndex];
                            }
                            else {
                                if (relation.hasInverseSide) {
                                    qb.select(relation.propertyName)
                                        .from(relation.inverseRelation.entityMetadata.target, relation.propertyName)
                                        .innerJoin(relation.propertyName + "." + relation.inverseRelation.propertyName, relation.entityMetadata.targetName)
                                        .where(relation.entityMetadata.targetName + "." + relation.joinColumn.referencedColumn.name + "=:id", { id: relation.entityMetadata.getEntityIdMixedMap(this) }); // is referenced column usage is correct here?
                                }
                                else {
                                    // (ow) post.category<=>category.post
                                    // loaded: category from post
                                    // example: SELECT category.id AS category_id, category.name AS category_name FROM category category
                                    //              INNER JOIN post Post ON Post.category=category.id WHERE Post.id=1
                                    qb.select(relation.propertyName) // category
                                        .from(relation.type, relation.propertyName) // Category, category
                                        .innerJoin(relation.entityMetadata.target, relation.entityMetadata.name, escapeAlias(relation.entityMetadata.name) + "." + escapeColumn(relation.propertyName) + "=" + escapeAlias(relation.propertyName) + "." + escapeColumn(relation.referencedColumn.propertyName))
                                        .where(relation.entityMetadata.name + "." + relation.joinColumn.referencedColumn.name + "=:id", { id: relation.entityMetadata.getEntityIdMixedMap(this) }); // is referenced column usage is correct here?
                                }
                                this[promiseIndex] = qb.getOne().then(function (result) {
                                    _this[index] = result;
                                    _this[resolveIndex] = true;
                                    delete _this[promiseIndex];
                                    return _this[index];
                                }).catch(function (err) {
                                    throw err;
                                });
                                return this[promiseIndex];
                            }
                        },
                        set: function (promise) {
                            var _this = this;
                            if (promise instanceof Promise) {
                                promise.then(function (result) {
                                    _this[index] = result;
                                    _this[resolveIndex] = true;
                                });
                            }
                            else {
                                this[index] = promise;
                                this[resolveIndex] = true;
                            }
                        },
                        configurable: true
                    });
                };
                return LazyRelationsWrapper;
            }());
            exports_53("LazyRelationsWrapper", LazyRelationsWrapper);
        }
    };
});
System.register("typeorm/metadata/EntityMetadata", ["typeorm/metadata/types/RelationTypes"], function (exports_54, context_54) {
    "use strict";
    var __moduleName = context_54 && context_54.id;
    var RelationTypes_2, EntityMetadata;
    return {
        setters: [
            function (RelationTypes_2_1) {
                RelationTypes_2 = RelationTypes_2_1;
            }
        ],
        execute: function () {
            // todo: IDEA. store all entity metadata in the EntityMetadata too? (this will open more features for metadata objects + no need to access connection in lot of places)
            /**
             * Contains all entity metadata.
             */
            EntityMetadata = (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function EntityMetadata(args, lazyRelationsWrapper) {
                    var _this = this;
                    this.lazyRelationsWrapper = lazyRelationsWrapper;
                    /**
                     * Entity's foreign key metadatas.
                     */
                    this.foreignKeys = [];
                    this.target = args.target;
                    this.junction = args.junction;
                    this.tablesPrefix = args.tablesPrefix;
                    this.namingStrategy = args.namingStrategy;
                    this.table = args.tableMetadata;
                    this._columns = args.columnMetadatas || [];
                    this.relations = args.relationMetadatas || [];
                    this.indices = args.indexMetadatas || [];
                    this.foreignKeys = args.foreignKeyMetadatas || [];
                    this.embeddeds = args.embeddedMetadatas || [];
                    this.discriminatorValue = args.discriminatorValue;
                    this.inheritanceType = args.inheritanceType;
                    this.table.entityMetadata = this;
                    this._columns.forEach(function (column) { return column.entityMetadata = _this; });
                    this.relations.forEach(function (relation) { return relation.entityMetadata = _this; });
                    this.foreignKeys.forEach(function (foreignKey) { return foreignKey.entityMetadata = _this; });
                    this.indices.forEach(function (index) { return index.entityMetadata = _this; });
                    this.embeddeds.forEach(function (embedded) {
                        embedded.entityMetadata = _this;
                        embedded.columns.forEach(function (column) { return column.entityMetadata = _this; });
                    });
                }
                Object.defineProperty(EntityMetadata.prototype, "name", {
                    // -------------------------------------------------------------------------
                    // Accessors
                    // -------------------------------------------------------------------------
                    /**
                     * Entity's name. Equal to entity target class's name if target is set to table, or equals to table name if its set.
                     */
                    get: function () {
                        if (!this.table)
                            throw new Error("No table target set to the entity metadata.");
                        return this.targetName ? this.targetName : this.table.name;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(EntityMetadata.prototype, "columns", {
                    /**
                     * Columns of the entity, including columns that are coming from the embeddeds of this entity.
                     */
                    get: function () {
                        var allColumns = [].concat(this._columns);
                        this.embeddeds.forEach(function (embedded) {
                            allColumns = allColumns.concat(embedded.columns);
                        });
                        return allColumns;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(EntityMetadata.prototype, "allColumns", {
                    /**
                     * All columns of the entity, including columns that are coming from the embeddeds of this entity,
                     * and including columns from the parent entities.
                     */
                    get: function () {
                        var columns = this.columns;
                        if (this.parentEntityMetadata)
                            columns = columns.concat(this.parentEntityMetadata.columns);
                        return columns;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(EntityMetadata.prototype, "allRelations", {
                    /**
                     * All relations of the entity, including relations from the parent entities.
                     */
                    get: function () {
                        var relations = this.relations;
                        if (this.parentEntityMetadata)
                            relations = relations.concat(this.parentEntityMetadata.relations);
                        return relations;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(EntityMetadata.prototype, "targetName", {
                    /**
                     * Gets the name of the target.
                     */
                    get: function () {
                        if (typeof this.target === "string")
                            return this.target;
                        if (this.target instanceof Function)
                            return this.target.name;
                        return "";
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(EntityMetadata.prototype, "hasMultiplePrimaryKeys", {
                    /**
                     * Checks if entity's table has multiple primary columns.
                     */
                    get: function () {
                        return this.primaryColumns.length > 1;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(EntityMetadata.prototype, "primaryColumn", {
                    /**
                     * Gets the primary column.
                     *
                     * @deprecated
                     */
                    get: function () {
                        var primaryKey = this.primaryColumns[0];
                        if (!primaryKey)
                            throw new Error("Primary key is not set for the " + this.name + " entity.");
                        return primaryKey;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(EntityMetadata.prototype, "hasGeneratedColumn", {
                    /**
                     * Checks if table has generated column.
                     */
                    get: function () {
                        return !!this.generatedColumnIfExist;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(EntityMetadata.prototype, "generatedColumn", {
                    /**
                     * Gets the column with generated flag.
                     */
                    get: function () {
                        var generatedColumn = this.generatedColumnIfExist;
                        if (!generatedColumn)
                            throw new Error("Generated column was not found");
                        return generatedColumn;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(EntityMetadata.prototype, "generatedColumnIfExist", {
                    /**
                     * Gets the generated column if it exists, or returns undefined if it does not.
                     */
                    get: function () {
                        return this._columns.find(function (column) { return column.isGenerated; });
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(EntityMetadata.prototype, "firstPrimaryColumn", {
                    /**
                     * Gets first primary column. In the case if table contains multiple primary columns it
                     * throws error.
                     */
                    get: function () {
                        if (this.hasMultiplePrimaryKeys)
                            throw new Error("Entity " + this.name + " has multiple primary keys. This operation is not supported on entities with multiple primary keys");
                        return this.primaryColumns[0];
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(EntityMetadata.prototype, "primaryColumns", {
                    /**
                     * Gets the primary columns.
                     */
                    get: function () {
                        // const originalPrimaryColumns = this._columns.filter(column => column.isPrimary);
                        // const parentEntityPrimaryColumns = this.hasParentIdColumn ? [this.parentIdColumn] : [];
                        // return originalPrimaryColumns.concat(parentEntityPrimaryColumns);
                        return this._columns.filter(function (column) { return column.isPrimary; });
                        // const originalPrimaryColumns = this._columns.filter(column => column.isPrimary);
                        // const parentEntityPrimaryColumns = this.parentEntityMetadata ? this.parentEntityMetadata.primaryColumns : [];
                        // return originalPrimaryColumns.concat(parentEntityPrimaryColumns);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(EntityMetadata.prototype, "primaryColumnsWithParentIdColumns", {
                    get: function () {
                        return this.primaryColumns.concat(this.parentIdColumns);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(EntityMetadata.prototype, "allPrimaryColumns", {
                    /**
                     * Gets all primary columns including columns from the parent entities.
                     */
                    get: function () {
                        return this.primaryColumns.concat(this.parentPrimaryColumns);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(EntityMetadata.prototype, "parentPrimaryColumns", {
                    /**
                     * Gets the primary columns of the parent entity metadata.
                     * If parent entity metadata does not exist then it simply returns empty array.
                     */
                    get: function () {
                        if (this.parentEntityMetadata)
                            return this.parentEntityMetadata.primaryColumns;
                        return [];
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(EntityMetadata.prototype, "ownPimaryColumns", {
                    /**
                     * Gets only primary columns owned by this entity.
                     */
                    get: function () {
                        return this._columns.filter(function (column) { return column.isPrimary; });
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(EntityMetadata.prototype, "hasCreateDateColumn", {
                    /**
                     * Checks if entity has a create date column.
                     */
                    get: function () {
                        return !!this._columns.find(function (column) { return column.mode === "createDate"; });
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(EntityMetadata.prototype, "createDateColumn", {
                    /**
                     * Gets entity column which contains a create date value.
                     */
                    get: function () {
                        var column = this._columns.find(function (column) { return column.mode === "createDate"; });
                        if (!column)
                            throw new Error("CreateDateColumn was not found in entity " + this.name);
                        return column;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(EntityMetadata.prototype, "hasUpdateDateColumn", {
                    /**
                     * Checks if entity has an update date column.
                     */
                    get: function () {
                        return !!this._columns.find(function (column) { return column.mode === "updateDate"; });
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(EntityMetadata.prototype, "updateDateColumn", {
                    /**
                     * Gets entity column which contains an update date value.
                     */
                    get: function () {
                        var column = this._columns.find(function (column) { return column.mode === "updateDate"; });
                        if (!column)
                            throw new Error("UpdateDateColumn was not found in entity " + this.name);
                        return column;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(EntityMetadata.prototype, "hasVersionColumn", {
                    /**
                     * Checks if entity has a version column.
                     */
                    get: function () {
                        return !!this._columns.find(function (column) { return column.mode === "version"; });
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(EntityMetadata.prototype, "versionColumn", {
                    /**
                     * Gets entity column which contains an entity version.
                     */
                    get: function () {
                        var column = this._columns.find(function (column) { return column.mode === "version"; });
                        if (!column)
                            throw new Error("VersionColumn was not found in entity " + this.name);
                        return column;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(EntityMetadata.prototype, "hasDiscriminatorColumn", {
                    /**
                     * Checks if entity has a discriminator column.
                     */
                    get: function () {
                        return !!this._columns.find(function (column) { return column.mode === "discriminator"; });
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(EntityMetadata.prototype, "discriminatorColumn", {
                    /**
                     * Gets the discriminator column used to store entity identificator in single-table inheritance tables.
                     */
                    get: function () {
                        var column = this._columns.find(function (column) { return column.mode === "discriminator"; });
                        if (!column)
                            throw new Error("DiscriminatorColumn was not found in entity " + this.name);
                        return column;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(EntityMetadata.prototype, "hasTreeLevelColumn", {
                    /**
                     * Checks if entity has a tree level column.
                     */
                    get: function () {
                        return !!this._columns.find(function (column) { return column.mode === "treeLevel"; });
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(EntityMetadata.prototype, "treeLevelColumn", {
                    get: function () {
                        var column = this._columns.find(function (column) { return column.mode === "treeLevel"; });
                        if (!column)
                            throw new Error("TreeLevelColumn was not found in entity " + this.name);
                        return column;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(EntityMetadata.prototype, "hasParentIdColumn", {
                    /**
                     * Checks if entity has a tree level column.
                     */
                    get: function () {
                        return !!this._columns.find(function (column) { return column.mode === "parentId"; });
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(EntityMetadata.prototype, "parentIdColumn", {
                    get: function () {
                        var column = this._columns.find(function (column) { return column.mode === "parentId"; });
                        if (!column)
                            throw new Error("Parent id column was not found in entity " + this.name);
                        return column;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(EntityMetadata.prototype, "parentIdColumns", {
                    get: function () {
                        return this._columns.filter(function (column) { return column.mode === "parentId"; });
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(EntityMetadata.prototype, "singleValueRelations", {
                    /**
                     * Gets single (values of which does not contain arrays) relations.
                     */
                    get: function () {
                        return this.relations.filter(function (relation) {
                            return relation.relationType === RelationTypes_2.RelationTypes.ONE_TO_ONE || relation.relationType === RelationTypes_2.RelationTypes.ONE_TO_MANY;
                        });
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(EntityMetadata.prototype, "multiValueRelations", {
                    /**
                     * Gets single (values of which does not contain arrays) relations.
                     */
                    get: function () {
                        return this.relations.filter(function (relation) {
                            return relation.relationType === RelationTypes_2.RelationTypes.ONE_TO_ONE || relation.relationType === RelationTypes_2.RelationTypes.ONE_TO_MANY;
                        });
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(EntityMetadata.prototype, "oneToOneRelations", {
                    /**
                     * Gets only one-to-one relations of the entity.
                     */
                    get: function () {
                        return this.relations.filter(function (relation) { return relation.relationType === RelationTypes_2.RelationTypes.ONE_TO_ONE; });
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(EntityMetadata.prototype, "ownerOneToOneRelations", {
                    /**
                     * Gets only owner one-to-one relations of the entity.
                     */
                    get: function () {
                        return this.relations.filter(function (relation) { return relation.relationType === RelationTypes_2.RelationTypes.ONE_TO_ONE && relation.isOwning; });
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(EntityMetadata.prototype, "oneToManyRelations", {
                    /**
                     * Gets only one-to-many relations of the entity.
                     */
                    get: function () {
                        return this.relations.filter(function (relation) { return relation.relationType === RelationTypes_2.RelationTypes.ONE_TO_MANY; });
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(EntityMetadata.prototype, "manyToOneRelations", {
                    /**
                     * Gets only many-to-one relations of the entity.
                     */
                    get: function () {
                        return this.relations.filter(function (relation) { return relation.relationType === RelationTypes_2.RelationTypes.MANY_TO_ONE; });
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(EntityMetadata.prototype, "manyToManyRelations", {
                    /**
                     * Gets only many-to-many relations of the entity.
                     */
                    get: function () {
                        return this.relations.filter(function (relation) { return relation.relationType === RelationTypes_2.RelationTypes.MANY_TO_MANY; });
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(EntityMetadata.prototype, "ownerManyToManyRelations", {
                    /**
                     * Gets only owner many-to-many relations of the entity.
                     */
                    get: function () {
                        return this.relations.filter(function (relation) { return relation.relationType === RelationTypes_2.RelationTypes.MANY_TO_MANY && relation.isOwning; });
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(EntityMetadata.prototype, "relationsWithJoinColumns", {
                    /**
                     * Gets only owner one-to-one and many-to-one relations.
                     */
                    get: function () {
                        return this.ownerOneToOneRelations.concat(this.manyToOneRelations);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(EntityMetadata.prototype, "hasTreeParentRelation", {
                    /**
                     * Checks if there is a tree parent relation. Used only in tree-tables.
                     */
                    get: function () {
                        return !!this.relations.find(function (relation) { return relation.isTreeParent; });
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(EntityMetadata.prototype, "treeParentRelation", {
                    /**
                     * Tree parent relation. Used only in tree-tables.
                     */
                    get: function () {
                        var relation = this.relations.find(function (relation) { return relation.isTreeParent; });
                        if (!relation)
                            throw new Error("TreeParent relation was not found in entity " + this.name);
                        return relation;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(EntityMetadata.prototype, "hasTreeChildrenRelation", {
                    /**
                     * Checks if there is a tree children relation. Used only in tree-tables.
                     */
                    get: function () {
                        return !!this.relations.find(function (relation) { return relation.isTreeChildren; });
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(EntityMetadata.prototype, "treeChildrenRelation", {
                    /**
                     * Tree children relation. Used only in tree-tables.
                     */
                    get: function () {
                        var relation = this.relations.find(function (relation) { return relation.isTreeChildren; });
                        if (!relation)
                            throw new Error("TreeParent relation was not found in entity " + this.name);
                        return relation;
                    },
                    enumerable: true,
                    configurable: true
                });
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Creates a new entity.
                 */
                EntityMetadata.prototype.create = function () {
                    var _this = this;
                    // if target is set to a function (e.g. class) that can be created then create it
                    if (this.target instanceof Function)
                        return new this.target();
                    // otherwise simply return a new empty object
                    var newObject = {};
                    this.relations
                        .filter(function (relation) { return relation.isLazy; })
                        .forEach(function (relation) { return _this.lazyRelationsWrapper.wrap(newObject, relation); });
                    return newObject;
                };
                /**
                 * Creates an object - map of columns and relations of the entity.
                 */
                EntityMetadata.prototype.createPropertiesMap = function () {
                    var entity = {};
                    this._columns.forEach(function (column) { return entity[column.propertyName] = column.propertyName; });
                    this.relations.forEach(function (relation) { return entity[relation.propertyName] = relation.propertyName; });
                    return entity;
                };
                /**
                 * Computes property name of the entity using given PropertyTypeInFunction.
                 */
                EntityMetadata.prototype.computePropertyName = function (nameOrFn) {
                    return typeof nameOrFn === "string" ? nameOrFn : nameOrFn(this.createPropertiesMap());
                };
                /**
                 * todo: undefined entities should not go there
                 */
                EntityMetadata.prototype.getEntityIdMap = function (entity) {
                    var _this = this;
                    if (!entity)
                        return undefined;
                    var map = {};
                    if (this.parentEntityMetadata) {
                        this.primaryColumnsWithParentIdColumns.forEach(function (column) {
                            var entityValue = entity[column.propertyName];
                            if (entityValue === null || entityValue === undefined)
                                return;
                            // if entity id is a relation, then extract referenced column from that relation
                            var columnRelation = _this.relations.find(function (relation) { return relation.propertyName === column.propertyName; });
                            if (columnRelation && columnRelation.joinColumn) {
                                map[column.propertyName] = entityValue[columnRelation.joinColumn.referencedColumn.propertyName];
                            }
                            else if (columnRelation && columnRelation.inverseRelation.joinColumn) {
                                map[column.propertyName] = entityValue[columnRelation.inverseRelation.joinColumn.referencedColumn.propertyName];
                            }
                            else {
                                map[column.propertyName] = entityValue;
                            }
                        });
                    }
                    else {
                        this.primaryColumns.forEach(function (column) {
                            var entityValue = entity[column.propertyName];
                            if (entityValue === null || entityValue === undefined)
                                return;
                            // if entity id is a relation, then extract referenced column from that relation
                            var columnRelation = _this.relations.find(function (relation) { return relation.propertyName === column.propertyName; });
                            if (columnRelation && columnRelation.joinColumn) {
                                map[column.propertyName] = entityValue[columnRelation.joinColumn.referencedColumn.propertyName];
                            }
                            else if (columnRelation && columnRelation.inverseRelation.joinColumn) {
                                map[column.propertyName] = entityValue[columnRelation.inverseRelation.joinColumn.referencedColumn.propertyName];
                            }
                            else {
                                map[column.propertyName] = entityValue;
                            }
                        });
                    }
                    return Object.keys(map).length > 0 ? map : undefined;
                };
                /**
                 * Same as getEntityIdMap, but instead of id column property names it returns database column names.
                 */
                EntityMetadata.prototype.getDatabaseEntityIdMap = function (entity) {
                    var _this = this;
                    var map = {};
                    if (this.parentEntityMetadata) {
                        this.primaryColumnsWithParentIdColumns.forEach(function (column) {
                            var entityValue = entity[column.propertyName];
                            if (entityValue === null || entityValue === undefined)
                                return;
                            // if entity id is a relation, then extract referenced column from that relation
                            var columnRelation = _this.relations.find(function (relation) { return relation.propertyName === column.propertyName; });
                            if (columnRelation && columnRelation.joinColumn) {
                                map[column.name] = entityValue[columnRelation.joinColumn.referencedColumn.propertyName];
                            }
                            else if (columnRelation && columnRelation.inverseRelation.joinColumn) {
                                map[column.name] = entityValue[columnRelation.inverseRelation.joinColumn.referencedColumn.propertyName];
                            }
                            else {
                                map[column.name] = entityValue;
                            }
                        });
                    }
                    else {
                        this.primaryColumns.forEach(function (column) {
                            var entityValue = entity[column.propertyName];
                            if (entityValue === null || entityValue === undefined)
                                return;
                            // if entity id is a relation, then extract referenced column from that relation
                            var columnRelation = _this.relations.find(function (relation) { return relation.propertyName === column.propertyName; });
                            if (columnRelation && columnRelation.joinColumn) {
                                map[column.name] = entityValue[columnRelation.joinColumn.referencedColumn.propertyName];
                            }
                            else if (columnRelation && columnRelation.inverseRelation.joinColumn) {
                                map[column.name] = entityValue[columnRelation.inverseRelation.joinColumn.referencedColumn.propertyName];
                            }
                            else {
                                map[column.name] = entityValue;
                            }
                        });
                    }
                    var hasAllIds = Object.keys(map).every(function (key) {
                        return map[key] !== undefined && map[key] !== null;
                    });
                    return hasAllIds ? map : undefined;
                };
                /**
            
                createSimpleIdMap(id: any): ObjectLiteral {
                    const map: ObjectLiteral = {};
                    if (this.parentEntityMetadata) {
                        this.primaryColumnsWithParentIdColumns.forEach(column => {
                            map[column.propertyName] = id;
                        });
            
                    } else {
                        this.primaryColumns.forEach(column => {
                            map[column.propertyName] = id;
                        });
                    }
                    return map;
                } */
                /**
                 * Same as createSimpleIdMap, but instead of id column property names it returns database column names.
            
                createSimpleDatabaseIdMap(id: any): ObjectLiteral {
                    const map: ObjectLiteral = {};
                    if (this.parentEntityMetadata) {
                        this.primaryColumnsWithParentIdColumns.forEach(column => {
                            map[column.name] = id;
                        });
            
                    } else {
                        this.primaryColumns.forEach(column => {
                            map[column.name] = id;
                        });
                    }
                    return map;
                }*/
                /**
                 * todo: undefined entities should not go there??
                 * todo: shouldnt be entity ObjectLiteral here?
                 */
                EntityMetadata.prototype.getEntityIdMixedMap = function (entity) {
                    if (!entity)
                        return undefined;
                    var idMap = this.getEntityIdMap(entity);
                    if (this.hasMultiplePrimaryKeys) {
                        return idMap;
                    }
                    else if (idMap) {
                        return idMap[this.firstPrimaryColumn.propertyName]; // todo: what about parent primary column?
                    }
                    return idMap;
                };
                /**
                 * Same as `getEntityIdMap` but the key of the map will be the column names instead of the property names.
                 */
                EntityMetadata.prototype.getEntityIdColumnMap = function (entity) {
                    return this.transformIdMapToColumnNames(this.getEntityIdMap(entity));
                };
                EntityMetadata.prototype.transformIdMapToColumnNames = function (idMap) {
                    var _this = this;
                    if (!idMap) {
                        return idMap;
                    }
                    var map = {};
                    Object.keys(idMap).forEach(function (propertyName) {
                        var column = _this.getColumnByPropertyName(propertyName);
                        if (column) {
                            map[column.name] = idMap[propertyName];
                        }
                    });
                    return map;
                };
                EntityMetadata.prototype.getColumnByPropertyName = function (propertyName) {
                    return this._columns.find(function (column) { return column.propertyName === propertyName; });
                };
                /**
                 * Checks if column with the given property name exist.
                 */
                EntityMetadata.prototype.hasColumnWithPropertyName = function (propertyName) {
                    return !!this._columns.find(function (column) { return column.propertyName === propertyName; });
                };
                /**
                 * Checks if column with the given database name exist.
                 */
                EntityMetadata.prototype.hasColumnWithDbName = function (name) {
                    return !!this._columns.find(function (column) { return column.name === name; });
                };
                /**
                 * Checks if relation with the given property name exist.
                 */
                EntityMetadata.prototype.hasRelationWithPropertyName = function (propertyName) {
                    return !!this.relations.find(function (relation) { return relation.propertyName === propertyName; });
                };
                /**
                 * Finds relation with the given property name.
                 */
                EntityMetadata.prototype.findRelationWithPropertyName = function (propertyName) {
                    var relation = this.relations.find(function (relation) { return relation.propertyName === propertyName; });
                    if (!relation)
                        throw new Error("Relation with property name " + propertyName + " in " + this.name + " entity was not found.");
                    return relation;
                };
                /**
                 * Checks if relation with the given name exist.
                 */
                EntityMetadata.prototype.hasRelationWithDbName = function (dbName) {
                    return !!this.relationsWithJoinColumns.find(function (relation) { return relation.name === dbName; });
                };
                /**
                 * Finds relation with the given name.
                 */
                EntityMetadata.prototype.findRelationWithDbName = function (name) {
                    var relation = this.relationsWithJoinColumns.find(function (relation) { return relation.name === name; });
                    if (!relation)
                        throw new Error("Relation with name " + name + " in " + this.name + " entity was not found.");
                    return relation;
                };
                EntityMetadata.prototype.addColumn = function (column) {
                    this._columns.push(column);
                    column.entityMetadata = this;
                };
                EntityMetadata.prototype.extractNonEmptyColumns = function (object) {
                    return this.columns.filter(function (column) { return !!object[column.propertyName]; });
                };
                EntityMetadata.prototype.extractNonEmptySingleValueRelations = function (object) {
                    return this.relations.filter(function (relation) {
                        return (relation.relationType === RelationTypes_2.RelationTypes.ONE_TO_ONE || relation.relationType === RelationTypes_2.RelationTypes.MANY_TO_ONE)
                            && !!object[relation.propertyName];
                    });
                };
                EntityMetadata.prototype.extractNonEmptyMultiValueRelations = function (object) {
                    return this.relations.filter(function (relation) {
                        return (relation.relationType === RelationTypes_2.RelationTypes.MANY_TO_MANY || relation.relationType === RelationTypes_2.RelationTypes.ONE_TO_MANY)
                            && !!object[relation.propertyName];
                    });
                };
                EntityMetadata.prototype.extractExistSingleValueRelations = function (object) {
                    return this.relations.filter(function (relation) {
                        return (relation.relationType === RelationTypes_2.RelationTypes.ONE_TO_ONE || relation.relationType === RelationTypes_2.RelationTypes.MANY_TO_ONE)
                            && object.hasOwnProperty(relation.propertyName);
                    });
                };
                EntityMetadata.prototype.extractExistMultiValueRelations = function (object) {
                    return this.relations.filter(function (relation) {
                        return (relation.relationType === RelationTypes_2.RelationTypes.MANY_TO_MANY || relation.relationType === RelationTypes_2.RelationTypes.ONE_TO_MANY)
                            && object.hasOwnProperty(relation.propertyName);
                    });
                };
                EntityMetadata.prototype.checkIfObjectContainsAllPrimaryKeys = function (object) {
                    return this.primaryColumns.every(function (primaryColumn) {
                        return object.hasOwnProperty(primaryColumn.propertyName);
                    });
                };
                EntityMetadata.prototype.compareEntities = function (firstEntity, secondEntity) {
                    var firstEntityIds = this.getEntityIdMap(firstEntity);
                    var secondEntityIds = this.getEntityIdMap(secondEntity);
                    return this.compareIds(firstEntityIds, secondEntityIds);
                };
                EntityMetadata.prototype.compareIds = function (firstId, secondId) {
                    if (firstId === undefined || firstId === null || secondId === undefined || secondId === null)
                        return false;
                    return Object.keys(firstId).every(function (key) {
                        return firstId[key] === secondId[key];
                    });
                };
                /**
                 * Compares two entity ids.
                 * If any of the given value is empty then it will return false.
                 */
                EntityMetadata.prototype.compareEntityMixedIds = function (firstId, secondId) {
                    if (firstId === undefined || firstId === null || secondId === undefined || secondId === null)
                        return false;
                    if (this.hasMultiplePrimaryKeys) {
                        return Object.keys(firstId).every(function (key) {
                            return firstId[key] === secondId[key];
                        });
                    }
                    else {
                        return firstId === secondId;
                    }
                };
                /**
                 * Iterates throw entity and finds and extracts all values from relations in the entity.
                 * If relation value is an array its being flattened.
                 */
                EntityMetadata.prototype.extractRelationValuesFromEntity = function (entity, relations) {
                    var relationsAndValues = [];
                    relations.forEach(function (relation) {
                        var value = relation.getEntityValue(entity);
                        if (value instanceof Array) {
                            value.forEach(function (subValue) { return relationsAndValues.push([relation, subValue, relation.inverseEntityMetadata]); });
                        }
                        else if (value) {
                            relationsAndValues.push([relation, value, relation.inverseEntityMetadata]);
                        }
                    });
                    return relationsAndValues;
                };
                /**
                 * Checks if given entity has an id.
                 */
                EntityMetadata.prototype.hasId = function (entity) {
                    // if (this.metadata.parentEntityMetadata) {
                    //     return this.metadata.parentEntityMetadata.parentIdColumns.every(parentIdColumn => {
                    //         const columnName = parentIdColumn.propertyName;
                    //         return !!entity &&
                    //             entity.hasOwnProperty(columnName) &&
                    //             entity[columnName] !== null &&
                    //             entity[columnName] !== undefined &&
                    //             entity[columnName] !== "";
                    //     });
                    // } else {
                    return this.primaryColumns.every(function (primaryColumn) {
                        var columnName = primaryColumn.propertyName;
                        return !!entity &&
                            entity.hasOwnProperty(columnName) &&
                            entity[columnName] !== null &&
                            entity[columnName] !== undefined &&
                            entity[columnName] !== "";
                    });
                    // }
                };
                Object.defineProperty(EntityMetadata.prototype, "hasNonNullableColumns", {
                    /**
                     * Checks if there any non-nullable column exist in this entity.
                     */
                    get: function () {
                        return this.relationsWithJoinColumns.some(function (relation) { return !relation.isNullable || relation.isPrimary; });
                        // return this.relationsWithJoinColumns.some(relation => relation.isNullable || relation.isPrimary);
                    },
                    enumerable: true,
                    configurable: true
                });
                return EntityMetadata;
            }());
            exports_54("EntityMetadata", EntityMetadata);
        }
    };
});
System.register("typeorm/metadata/ColumnMetadata", [], function (exports_55, context_55) {
    "use strict";
    var __moduleName = context_55 && context_55.id;
    var ColumnMetadata;
    return {
        setters: [],
        execute: function () {
            /**
             * This metadata contains all information about entity's column.
             */
            ColumnMetadata = (function () {
                // ---------------------------------------------------------------------
                // Constructor
                // ---------------------------------------------------------------------
                function ColumnMetadata(args) {
                    /**
                     * Type's length in the database.
                     */
                    this.length = "";
                    /**
                     * Indicates if this column is a primary key.
                     */
                    this.isPrimary = false;
                    /**
                     * Indicates if this column is generated (auto increment or generated other way).
                     */
                    this.isGenerated = false;
                    /**
                     * Indicates if value in the database should be unique or not.
                     */
                    this.isUnique = false;
                    /**
                     * Indicates if column can contain nulls or not.
                     */
                    this.isNullable = false;
                    /**
                     * Column comment.
                     */
                    this.comment = "";
                    this.target = args.target;
                    this.propertyName = args.propertyName;
                    if (args.mode)
                        this.mode = args.mode;
                    // if (args.propertyType)
                    //     this.propertyType = args.propertyType.toLowerCase();
                    if (args.options.name)
                        this._name = args.options.name;
                    if (args.options.type)
                        this.type = args.options.type;
                    if (args.options.length)
                        this.length = String(args.options.length);
                    if (args.options.primary)
                        this.isPrimary = args.options.primary;
                    if (args.options.generated)
                        this.isGenerated = args.options.generated;
                    if (args.options.unique)
                        this.isUnique = args.options.unique;
                    if (args.options.nullable)
                        this.isNullable = args.options.nullable;
                    if (args.options.comment)
                        this.comment = args.options.comment;
                    if (args.options.default !== undefined && args.options.default !== null)
                        this.default = args.options.default;
                    if (args.options.scale)
                        this.scale = args.options.scale;
                    if (args.options.precision)
                        this.precision = args.options.precision;
                    if (args.options.timezone)
                        this.timezone = args.options.timezone;
                    if (args.options.localTimezone)
                        this.localTimezone = args.options.localTimezone;
                }
                Object.defineProperty(ColumnMetadata.prototype, "entityTarget", {
                    // ---------------------------------------------------------------------
                    // Accessors
                    // ---------------------------------------------------------------------
                    /**
                     * Gets column's entity target.
                     * Original target returns target of the class where column is.
                     * This class can be an abstract class, but column even is from that class,
                     * but its more related to a specific entity. That's why we need this field.
                     */
                    get: function () {
                        return this.entityMetadata.target;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ColumnMetadata.prototype, "name", {
                    /**
                     * Column name in the database.
                     */
                    get: function () {
                        // if this column is embedded's column then apply different entity
                        if (this.embeddedMetadata)
                            return this.embeddedMetadata.entityMetadata.namingStrategy.embeddedColumnName(this.embeddedMetadata.propertyName, this.propertyName, this._name);
                        // if there is a naming strategy then use it to normalize propertyName as column name
                        if (this.entityMetadata)
                            return this.entityMetadata.namingStrategy.columnName(this.propertyName, this._name);
                        throw new Error("Column " + (this._name ? this._name + " " : "") + "is not attached to any entity or embedded.");
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ColumnMetadata.prototype, "isInEmbedded", {
                    /**
                     * Indicates if this column is in embedded, not directly in the table.
                     */
                    get: function () {
                        return !!this.embeddedMetadata;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ColumnMetadata.prototype, "isVirtual", {
                    /**
                     * Indicates if column is virtual. Virtual columns are not mapped to the entity.
                     */
                    get: function () {
                        return this.mode === "virtual";
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ColumnMetadata.prototype, "isParentId", {
                    /**
                     * Indicates if column is a parent id. Parent id columns are not mapped to the entity.
                     */
                    get: function () {
                        return this.mode === "parentId";
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ColumnMetadata.prototype, "isDiscriminator", {
                    /**
                     * Indicates if column is discriminator. Discriminator columns are not mapped to the entity.
                     */
                    get: function () {
                        return this.mode === "discriminator";
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ColumnMetadata.prototype, "isCreateDate", {
                    /**
                     * Indicates if this column contains an entity creation date.
                     */
                    get: function () {
                        return this.mode === "createDate";
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ColumnMetadata.prototype, "isUpdateDate", {
                    /**
                     * Indicates if this column contains an entity update date.
                     */
                    get: function () {
                        return this.mode === "updateDate";
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ColumnMetadata.prototype, "isVersion", {
                    /**
                     * Indicates if this column contains an entity version.
                     */
                    get: function () {
                        return this.mode === "version";
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ColumnMetadata.prototype, "referencedColumn", {
                    /**
                     * If this column references some column, it gets the first referenced column of this column.
                     */
                    get: function () {
                        var _this = this;
                        var foreignKey = this.entityMetadata.foreignKeys.find(function (foreignKey) { return foreignKey.columns.indexOf(_this) !== -1; });
                        if (foreignKey) {
                            return foreignKey.referencedColumns[0];
                        }
                        return undefined;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ColumnMetadata.prototype, "embeddedProperty", {
                    /**
                     * Gets embedded property in which column is.
                     */
                    get: function () {
                        if (!this.embeddedMetadata)
                            throw new Error("This column" + (this._name ? this._name + " " : "") + " is not in embedded entity.");
                        return this.embeddedMetadata.propertyName;
                    },
                    enumerable: true,
                    configurable: true
                });
                // ---------------------------------------------------------------------
                // Public Methods
                // ---------------------------------------------------------------------
                ColumnMetadata.prototype.hasEntityValue = function (entity) {
                    if (!entity)
                        return false;
                    if (this.isInEmbedded) {
                        return entity[this.embeddedProperty] !== undefined &&
                            entity[this.embeddedProperty] !== null &&
                            entity[this.embeddedProperty][this.propertyName] !== undefined &&
                            entity[this.embeddedProperty][this.propertyName] !== null;
                    }
                    else {
                        return entity[this.propertyName] !== undefined &&
                            entity[this.propertyName] !== null;
                    }
                };
                ColumnMetadata.prototype.getEntityValue = function (entity) {
                    if (this.isInEmbedded) {
                        if (entity[this.embeddedProperty] === undefined ||
                            entity[this.embeddedProperty] === null)
                            return undefined;
                        return entity[this.embeddedProperty][this.propertyName];
                    }
                    else {
                        return entity[this.propertyName];
                    }
                };
                return ColumnMetadata;
            }());
            exports_55("ColumnMetadata", ColumnMetadata);
        }
    };
});
System.register("typeorm/schema-builder/schema/ColumnSchema", [], function (exports_56, context_56) {
    "use strict";
    var __moduleName = context_56 && context_56.id;
    var ColumnSchema;
    return {
        setters: [],
        execute: function () {
            /**
             * Table's column's schema in the database represented in this class.
             */
            ColumnSchema = (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function ColumnSchema(options) {
                    /**
                     * Indicates if column is NULL, or is NOT NULL in the database.
                     */
                    this.isNullable = false;
                    /**
                     * Indicates if column is auto-generated sequence.
                     */
                    this.isGenerated = false;
                    /**
                     * Indicates if column is a primary key.
                     */
                    this.isPrimary = false;
                    /**
                     * Indicates if column has unique value.
                     */
                    this.isUnique = false;
                    if (options) {
                        this.name = options.name || "";
                        this.type = options.type || "";
                        this.default = options.default;
                        this.isNullable = options.isNullable || false;
                        this.isGenerated = options.isGenerated || false;
                        this.isPrimary = options.isPrimary || false;
                        this.isUnique = options.isUnique || false;
                        this.comment = options.comment;
                    }
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Clones this column schema to a new column schema with exact same properties as this column schema has.
                 */
                ColumnSchema.prototype.clone = function () {
                    var newColumnSchema = new ColumnSchema();
                    newColumnSchema.name = this.name;
                    newColumnSchema.type = this.type;
                    newColumnSchema.default = this.default;
                    newColumnSchema.isNullable = this.isNullable;
                    newColumnSchema.isGenerated = this.isGenerated;
                    newColumnSchema.isPrimary = this.isPrimary;
                    newColumnSchema.isUnique = this.isUnique;
                    newColumnSchema.comment = this.comment;
                    return newColumnSchema;
                };
                // -------------------------------------------------------------------------
                // Static Methods
                // -------------------------------------------------------------------------
                /**
                 * Creates a new column based on the given column metadata.
                 */
                ColumnSchema.create = function (columnMetadata, normalizedType) {
                    var columnSchema = new ColumnSchema();
                    columnSchema.name = columnMetadata.name;
                    columnSchema.default = columnMetadata.default;
                    columnSchema.comment = columnMetadata.comment;
                    columnSchema.isGenerated = columnMetadata.isGenerated;
                    columnSchema.isNullable = columnMetadata.isNullable;
                    columnSchema.type = normalizedType;
                    columnSchema.isPrimary = columnMetadata.isPrimary;
                    columnSchema.isUnique = columnMetadata.isUnique;
                    return columnSchema;
                };
                return ColumnSchema;
            }());
            exports_56("ColumnSchema", ColumnSchema);
        }
    };
});
System.register("typeorm/query-runner/QueryRunner", [], function (exports_57, context_57) {
    "use strict";
    var __moduleName = context_57 && context_57.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/driver/Driver", [], function (exports_58, context_58) {
    "use strict";
    var __moduleName = context_58 && context_58.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/query-builder/transformer/PlainObjectToNewEntityTransformer", [], function (exports_59, context_59) {
    "use strict";
    var __moduleName = context_59 && context_59.id;
    var PlainObjectToNewEntityTransformer;
    return {
        setters: [],
        execute: function () {
            /**
             * Transforms plain old javascript object
             * Entity is constructed based on its entity metadata.
             */
            PlainObjectToNewEntityTransformer = (function () {
                function PlainObjectToNewEntityTransformer() {
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                PlainObjectToNewEntityTransformer.prototype.transform = function (newEntity, object, metadata) {
                    this.groupAndTransform(newEntity, object, metadata);
                    return newEntity;
                };
                // -------------------------------------------------------------------------
                // Private Methods
                // -------------------------------------------------------------------------
                /**
                 * Since db returns a duplicated rows of the data where accuracies of the same object can be duplicated
                 * we need to group our result and we must have some unique id (primary key in our case)
                 */
                PlainObjectToNewEntityTransformer.prototype.groupAndTransform = function (entity, object, metadata) {
                    var _this = this;
                    // copy regular column properties from the given object
                    metadata.allColumns
                        .filter(function (column) { return object.hasOwnProperty(column.propertyName); })
                        .forEach(function (column) { return entity[column.propertyName] = object[column.propertyName]; }); // todo: also need to be sure that type is correct
                    // if relation is loaded then go into it recursively and transform its values too
                    metadata.allRelations
                        .filter(function (relation) { return object.hasOwnProperty(relation.propertyName); })
                        .forEach(function (relation) {
                        var relationMetadata = relation.inverseEntityMetadata;
                        if (!relationMetadata)
                            throw new Error("Relation metadata for the relation " + metadata.name + "#" + relation.propertyName + " is missing");
                        if (relation.isManyToMany || relation.isOneToMany) {
                            if (object[relation.propertyName] instanceof Array) {
                                entity[relation.propertyName] = object[relation.propertyName].map(function (subObject) {
                                    var subEntity = relationMetadata.create();
                                    // todo: support custom initial fields here
                                    if (entity[relation.propertyName] instanceof Array) {
                                        var existRelation = entity[relation.propertyName].find(function (subEntity) {
                                            return subEntity[relation.referencedColumnName] === subObject[relation.referencedColumnName];
                                        });
                                        if (existRelation)
                                            _this.groupAndTransform(subEntity, existRelation, relationMetadata);
                                    }
                                    _this.groupAndTransform(subEntity, subObject, relationMetadata);
                                    return subEntity;
                                });
                            }
                            else {
                                entity[relation.propertyName] = object[relation.propertyName];
                            }
                        }
                        else {
                            if (object[relation.propertyName]) {
                                var subEntity = relationMetadata.create();
                                if (entity[relation.propertyName])
                                    _this.groupAndTransform(subEntity, entity[relation.propertyName], relationMetadata);
                                _this.groupAndTransform(subEntity, object[relation.propertyName], relationMetadata);
                                entity[relation.propertyName] = subEntity;
                            }
                            else {
                                entity[relation.propertyName] = object[relation.propertyName];
                            }
                        }
                    });
                };
                return PlainObjectToNewEntityTransformer;
            }());
            exports_59("PlainObjectToNewEntityTransformer", PlainObjectToNewEntityTransformer);
        }
    };
});
System.register("typeorm/query-builder/transformer/PlainObjectToDatabaseEntityTransformer", [], function (exports_60, context_60) {
    "use strict";
    var __moduleName = context_60 && context_60.id;
    var PlainObjectToDatabaseEntityTransformer;
    return {
        setters: [],
        execute: function () {
            /**
             * Transforms plain old javascript object
             * Entity is constructed based on its entity metadata.
             */
            PlainObjectToDatabaseEntityTransformer = (function () {
                function PlainObjectToDatabaseEntityTransformer() {
                }
                // constructor(protected namingStrategy: NamingStrategyInterface) {
                // }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                PlainObjectToDatabaseEntityTransformer.prototype.transform = function (plainObject, metadata, queryBuilder) {
                    return __awaiter(this, void 0, void 0, function () {
                        var alias, needToLoad;
                        return __generator(this, function (_a) {
                            // if plain object does not have id then nothing to load really
                            if (!metadata.checkIfObjectContainsAllPrimaryKeys(plainObject))
                                return [2 /*return*/, Promise.reject("Given object does not have a primary column, cannot transform it to database entity.")];
                            alias = queryBuilder.alias;
                            needToLoad = this.buildLoadMap(plainObject, metadata, true);
                            this.join(queryBuilder, needToLoad, alias);
                            metadata.primaryColumns.forEach(function (primaryColumn) {
                                queryBuilder
                                    .andWhere(alias + "." + primaryColumn.propertyName + "=:" + primaryColumn.propertyName)
                                    .setParameter(primaryColumn.propertyName, plainObject[primaryColumn.propertyName]);
                            });
                            if (metadata.parentEntityMetadata) {
                                metadata.parentEntityMetadata.primaryColumns.forEach(function (primaryColumn) {
                                    var parentIdColumn = metadata.parentIdColumns.find(function (parentIdColumn) {
                                        return parentIdColumn.propertyName === primaryColumn.propertyName;
                                    });
                                    if (!parentIdColumn)
                                        throw new Error("Prent id column for the given primary column was not found.");
                                    queryBuilder
                                        .andWhere(alias + "." + parentIdColumn.propertyName + "=:" + primaryColumn.propertyName)
                                        .setParameter(primaryColumn.propertyName, plainObject[primaryColumn.propertyName]);
                                });
                            }
                            return [2 /*return*/, queryBuilder.getOne()];
                        });
                    });
                };
                // -------------------------------------------------------------------------
                // Private Methods
                // -------------------------------------------------------------------------
                PlainObjectToDatabaseEntityTransformer.prototype.join = function (qb, needToLoad, parentAlias) {
                    var _this = this;
                    needToLoad.forEach(function (i) {
                        var alias = parentAlias + "_" + i.name;
                        qb.leftJoinAndSelect(parentAlias + "." + i.name, alias);
                        if (i.child && i.child.length)
                            _this.join(qb, i.child, alias);
                    });
                };
                PlainObjectToDatabaseEntityTransformer.prototype.buildLoadMap = function (object, metadata, isFirstLevelDepth) {
                    var _this = this;
                    if (isFirstLevelDepth === void 0) { isFirstLevelDepth = false; }
                    // todo: rething the way we are trying to load things using left joins cause there are situations when same
                    // todo: entities are loaded multiple times and become different objects (problem with duplicate entities in dbEntities)
                    return metadata.relations
                        .filter(function (relation) { return object.hasOwnProperty(relation.propertyName); })
                        .filter(function (relation) {
                        // we only need to load empty relations for first-level depth objects, otherwise removal can break
                        // this is not reliable, refactor this part later
                        var value = (object[relation.propertyName] instanceof Promise && relation.isLazy) ? object["__" + relation.propertyName + "__"] : object[relation.propertyName];
                        return isFirstLevelDepth || !(value instanceof Array) || value.length > 0;
                    })
                        .map(function (relation) {
                        var value = (object[relation.propertyName] instanceof Promise && relation.isLazy) ? object["__" + relation.propertyName + "__"] : object[relation.propertyName];
                        // let value = object[relation.propertyName];
                        if (value instanceof Array)
                            value = Object.assign.apply(Object, [{}].concat(value));
                        var child = value ? _this.buildLoadMap(value, relation.inverseEntityMetadata) : [];
                        return { name: relation.propertyName, child: child };
                    });
                };
                return PlainObjectToDatabaseEntityTransformer;
            }());
            exports_60("PlainObjectToDatabaseEntityTransformer", PlainObjectToDatabaseEntityTransformer);
        }
    };
});
System.register("typeorm/find-options/FindOptions", [], function (exports_61, context_61) {
    "use strict";
    var __moduleName = context_61 && context_61.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/find-options/FindOptionsUtils", [], function (exports_62, context_62) {
    "use strict";
    var __moduleName = context_62 && context_62.id;
    var FindOptionsUtils;
    return {
        setters: [],
        execute: function () {
            /**
             * Utilities to work with FindOptions.
             */
            FindOptionsUtils = (function () {
                function FindOptionsUtils() {
                }
                /**
                 * Checks if given object is really instance of FindOptions interface.
                 */
                FindOptionsUtils.isFindOptions = function (object) {
                    var possibleOptions = object;
                    return possibleOptions && !!possibleOptions.alias && typeof possibleOptions.alias === "string" && (!!possibleOptions.limit ||
                        !!possibleOptions.offset ||
                        !!possibleOptions.firstResult ||
                        !!possibleOptions.maxResults ||
                        !!possibleOptions.where ||
                        !!possibleOptions.having ||
                        !!possibleOptions.whereConditions ||
                        !!possibleOptions.havingConditions ||
                        !!possibleOptions.orderBy ||
                        !!possibleOptions.groupBy ||
                        !!possibleOptions.leftJoinAndSelect ||
                        !!possibleOptions.innerJoinAndSelect ||
                        !!possibleOptions.leftJoin ||
                        !!possibleOptions.innerJoin ||
                        !!possibleOptions.parameters ||
                        !!possibleOptions.enabledOptions);
                };
                /**
                 * Applies give find options to the given query builder.
                 */
                FindOptionsUtils.applyOptionsToQueryBuilder = function (qb, options) {
                    if (options.limit)
                        qb.setLimit(options.limit);
                    if (options.offset)
                        qb.setOffset(options.offset);
                    if (options.firstResult)
                        qb.setFirstResult(options.firstResult);
                    if (options.maxResults)
                        qb.setMaxResults(options.maxResults);
                    if (options.where)
                        qb.where(options.where);
                    if (options.having)
                        qb.having(options.having);
                    if (options.whereConditions) {
                        Object.keys(options.whereConditions).forEach(function (key, index) {
                            var name = key.indexOf(".") === -1 ? options.alias + "." + key : key;
                            if (options.whereConditions[key] === null) {
                                qb.andWhere(name + " IS NULL");
                            }
                            else {
                                var parameterName = "whereConditions_" + index;
                                qb.andWhere(name + "=:" + parameterName, (_a = {}, _a[parameterName] = options.whereConditions[key], _a));
                            }
                            var _a;
                        });
                    }
                    if (options.havingConditions) {
                        Object.keys(options.havingConditions).forEach(function (key, index) {
                            var name = key.indexOf(".") === -1 ? options.alias + "." + key : key;
                            if (options.havingConditions[key] === null) {
                                qb.andHaving(name + " IS NULL");
                            }
                            else {
                                var parameterName = "havingConditions_" + index;
                                qb.andHaving(name + "=:" + parameterName, (_a = {}, _a[parameterName] = options.whereConditions[key], _a));
                            }
                            var _a;
                        });
                    }
                    if (options.orderBy)
                        Object.keys(options.orderBy).forEach(function (columnName) { return qb.addOrderBy(columnName, options.orderBy[columnName]); });
                    if (options.groupBy)
                        options.groupBy.forEach(function (groupBy) { return qb.addGroupBy(groupBy); });
                    if (options.leftJoin)
                        Object.keys(options.leftJoin).forEach(function (key) {
                            if (options.leftJoin)
                                qb.leftJoin(options.leftJoin[key], key);
                        });
                    if (options.innerJoin)
                        Object.keys(options.innerJoin).forEach(function (key) {
                            if (options.innerJoin)
                                qb.innerJoin(options.innerJoin[key], key);
                        });
                    if (options.leftJoinAndSelect)
                        Object.keys(options.leftJoinAndSelect).forEach(function (key) {
                            if (options.leftJoinAndSelect)
                                qb.leftJoinAndSelect(options.leftJoinAndSelect[key], key);
                        });
                    if (options.innerJoinAndSelect)
                        Object.keys(options.innerJoinAndSelect).forEach(function (key) {
                            if (options.innerJoinAndSelect)
                                qb.innerJoinAndSelect(options.innerJoinAndSelect[key], key);
                        });
                    if (options.parameters)
                        qb.setParameters(options.parameters);
                    if (options.enabledOptions) {
                        options.enabledOptions.forEach(function (option) {
                            qb.enableOption(option);
                        });
                    }
                    return qb;
                };
                return FindOptionsUtils;
            }());
            exports_62("FindOptionsUtils", FindOptionsUtils);
        }
    };
});
System.register("typeorm/persistence/Subject", ["typeorm/metadata/types/ColumnTypes", "typeorm/util/DataTransformationUtils"], function (exports_63, context_63) {
    "use strict";
    var __moduleName = context_63 && context_63.id;
    var ColumnTypes_2, DataTransformationUtils_2, Subject;
    return {
        setters: [
            function (ColumnTypes_2_1) {
                ColumnTypes_2 = ColumnTypes_2_1;
            },
            function (DataTransformationUtils_2_1) {
                DataTransformationUtils_2 = DataTransformationUtils_2_1;
            }
        ],
        execute: function () {
            /**
             * Subject is a subject of persistence.
             * It holds information about each entity that needs to be persisted:
             * - what entity should be persisted
             * - what is database representation of the persisted entity
             * - what entity metadata of the persisted entity
             * - what is allowed to with persisted entity (insert/update/remove)
             *
             * Having this collection of subjects we can perform database queries.
             */
            Subject = (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function Subject(metadata, entity, databaseEntity) {
                    /**
                     * Date when this entity is persisted.
                     */
                    this.date = new Date();
                    // -------------------------------------------------------------------------
                    // Public Properties
                    // -------------------------------------------------------------------------
                    /**
                     * Indicates if this subject can be inserted into the database.
                     * This means that this subject either is newly persisted, either can be inserted by cascades.
                     */
                    this.canBeInserted = false;
                    /**
                     * Indicates if this subject can be updated in the database.
                     * This means that this subject either was persisted, either can be updated by cascades.
                     */
                    this.canBeUpdated = false;
                    /**
                     * Indicates if this subject MUST be removed from the database.
                     * This means that this subject either was removed, either was removed by cascades.
                     */
                    this.mustBeRemoved = false;
                    /**
                     * Differentiated columns between persisted and database entities.
                     */
                    this.diffColumns = [];
                    /**
                     * Differentiated relations between persisted and database entities.
                     */
                    this.diffRelations = [];
                    /**
                     * List of relations which need to be unset.
                     * This is used to update relation from inverse side.
                     */
                    this.relationUpdates = [];
                    /**
                     * Records that needs to be inserted into the junction tables of this subject.
                     */
                    this.junctionInserts = [];
                    /**
                     * Records that needs to be removed from the junction tables of this subject.
                     */
                    this.junctionRemoves = [];
                    this.metadata = metadata;
                    this._persistEntity = entity;
                    this._databaseEntity = databaseEntity;
                }
                Object.defineProperty(Subject.prototype, "entity", {
                    // -------------------------------------------------------------------------
                    // Accessors
                    // -------------------------------------------------------------------------
                    /**
                     * Gets entity sent to the persistence (e.g. changed entity).
                     * Throws error if persisted entity was not set.
                     */
                    get: function () {
                        if (!this._persistEntity)
                            throw new Error("Persistence entity is not set for the given subject.");
                        return this._persistEntity;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Subject.prototype, "hasEntity", {
                    /**
                     * Checks if subject has a persisted entity.
                     */
                    get: function () {
                        return !!this._persistEntity;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Subject.prototype, "databaseEntity", {
                    /**
                     * Gets entity from the database (e.g. original entity).
                     * Throws error if database entity was not set.
                     */
                    get: function () {
                        if (!this._databaseEntity)
                            throw new Error("Database entity is not set for the given subject.");
                        return this._databaseEntity;
                    },
                    /**
                     * Sets entity from the database (e.g. original entity).
                     * Once database entity set it calculates differentiated columns and relations
                     * between persistent entity and database entity.
                     */
                    set: function (databaseEntity) {
                        this._databaseEntity = databaseEntity;
                        this.recompute();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Subject.prototype, "hasDatabaseEntity", {
                    /**
                     * Checks if subject has a database entity.
                     */
                    get: function () {
                        return !!this._databaseEntity;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Subject.prototype, "entityTarget", {
                    /**
                     * Gets entity target from the entity metadata of this subject.
                     */
                    get: function () {
                        return this.metadata.target;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Subject.prototype, "mustBeInserted", {
                    /**
                     * Checks if this subject must be inserted into the database.
                     * Subject can be inserted into the database if it is allowed to be inserted (explicitly persisted or by cascades)
                     * and if it does not have database entity set.
                     */
                    get: function () {
                        return this.canBeInserted && !this.hasDatabaseEntity;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Subject.prototype, "mustBeUpdated", {
                    /**
                     * Checks if this subject must be updated into the database.
                     * Subject can be updated in the database if it is allowed to be updated (explicitly persisted or by cascades)
                     * and if it does have differentiated columns or relations.
                     */
                    get: function () {
                        return this.canBeUpdated && (this.diffColumns.length > 0 || this.diffRelations.length > 0);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Subject.prototype, "hasRelationUpdates", {
                    /**
                     * Checks if this subject has relations to be updated.
                     */
                    get: function () {
                        return this.relationUpdates.length > 0;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Gets id of the persisted entity.
                 * If entity is not set then it returns undefined.
                 * If entity itself has an id then it simply returns it.
                 * If entity does not have an id then it returns newly generated id.
            
                get getPersistedEntityIdMap(): any|undefined {
                    if (!this.hasEntity)
                        return undefined;
            
                    const entityIdMap = this.metadata.getDatabaseEntityIdMap(this.entity);
                    if (entityIdMap)
                        return entityIdMap;
            
                    if (this.newlyGeneratedId)
                        return this.metadata.createSimpleDatabaseIdMap(this.newlyGeneratedId);
            
                    return undefined;
                }*/
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Validates this subject for errors.
                 * Subject cannot be at the same time inserted and updated, removed and inserted, removed and updated.
                 */
                Subject.prototype.validate = function () {
                    if (this.mustBeInserted && this.mustBeRemoved)
                        throw new Error("Removed entity " + this.metadata.name + " is also scheduled for insert operation. This looks like ORM problem. Please report a github issue.");
                    if (this.mustBeUpdated && this.mustBeRemoved)
                        throw new Error("Removed entity \"" + this.metadata.name + "\" is also scheduled for update operation. " +
                            "Make sure you are not updating and removing same object (note that update or remove may be executed by cascade operations).");
                    if (this.mustBeInserted && this.mustBeUpdated)
                        throw new Error("Inserted entity " + this.metadata.name + " is also scheduled for updated operation. This looks like ORM problem. Please report a github issue.");
                };
                /**
                 * Performs entity re-computations.
                 */
                Subject.prototype.recompute = function () {
                    if (this.hasEntity && this._databaseEntity) {
                        this.computeDiffColumns();
                        this.computeDiffRelationalColumns();
                    }
                };
                // -------------------------------------------------------------------------
                // Protected Methods
                // -------------------------------------------------------------------------
                /**
                 * Differentiate columns from the updated entity and entity stored in the database.
                 */
                Subject.prototype.computeDiffColumns = function () {
                    var _this = this;
                    this.diffColumns = this.metadata.allColumns.filter(function (column) {
                        // prepare both entity and database values to make comparision
                        var entityValue = column.getEntityValue(_this.entity);
                        var databaseValue = column.getEntityValue(_this.databaseEntity);
                        // normalize special values to make proper comparision
                        if (entityValue !== null && entityValue !== undefined) {
                            if (column.type === ColumnTypes_2.ColumnTypes.DATE) {
                                entityValue = DataTransformationUtils_2.DataTransformationUtils.mixedDateToDateString(entityValue);
                            }
                            else if (column.type === ColumnTypes_2.ColumnTypes.TIME) {
                                entityValue = DataTransformationUtils_2.DataTransformationUtils.mixedDateToTimeString(entityValue);
                            }
                            else if (column.type === ColumnTypes_2.ColumnTypes.DATETIME) {
                                // if (column.loadInLocalTimezone) {
                                //     entityValue = DataTransformationUtils.mixedDateToDatetimeString(entityValue);
                                //     databaseValue = DataTransformationUtils.mixedDateToDatetimeString(databaseValue);
                                // } else {
                                entityValue = DataTransformationUtils_2.DataTransformationUtils.mixedDateToUtcDatetimeString(entityValue);
                                databaseValue = DataTransformationUtils_2.DataTransformationUtils.mixedDateToUtcDatetimeString(databaseValue);
                                // }
                            }
                            else if (column.type === ColumnTypes_2.ColumnTypes.JSON) {
                                entityValue = JSON.stringify(entityValue);
                                if (databaseValue !== null && databaseValue !== undefined)
                                    databaseValue = JSON.stringify(databaseValue);
                            }
                            else if (column.type === ColumnTypes_2.ColumnTypes.SIMPLE_ARRAY) {
                                entityValue = DataTransformationUtils_2.DataTransformationUtils.simpleArrayToString(entityValue);
                                databaseValue = DataTransformationUtils_2.DataTransformationUtils.simpleArrayToString(databaseValue);
                            }
                        }
                        // if value is not defined then no need to update it
                        if (!column.isInEmbedded && _this.entity[column.propertyName] === undefined)
                            return false;
                        // if value is in embedded and is not defined then no need to update it
                        if (column.isInEmbedded && (_this.entity[column.embeddedProperty] === undefined || _this.entity[column.embeddedProperty][column.propertyName] === undefined))
                            return false;
                        // if its a special column or value is not changed - then do nothing
                        if (column.isVirtual ||
                            column.isParentId ||
                            column.isDiscriminator ||
                            column.isUpdateDate ||
                            column.isVersion ||
                            column.isCreateDate ||
                            entityValue === databaseValue)
                            return false;
                        // filter out "relational columns" only in the case if there is a relation object in entity
                        if (!column.isInEmbedded && _this.metadata.hasRelationWithDbName(column.propertyName)) {
                            var relation = _this.metadata.findRelationWithDbName(column.propertyName); // todo: why with dbName ?
                            if (_this.entity[relation.propertyName] !== null && _this.entity[relation.propertyName] !== undefined)
                                return false;
                        }
                        return true;
                    });
                };
                /**
                 * Difference columns of the owning one-to-one and many-to-one columns.
                 */
                Subject.prototype.computeDiffRelationalColumns = function () {
                    var _this = this;
                    this.diffRelations = this.metadata.allRelations.filter(function (relation) {
                        if (!relation.isManyToOne && !(relation.isOneToOne && relation.isOwning))
                            return false;
                        // here we cover two scenarios:
                        // 1. related entity can be another entity which is natural way
                        // 2. related entity can be entity id which is hacked way of updating entity
                        // todo: what to do if there is a column with relationId? (cover this too?)
                        var updatedEntityRelationId = _this.entity[relation.propertyName] instanceof Object ?
                            relation.inverseEntityMetadata.getEntityIdMixedMap(_this.entity[relation.propertyName])
                            : _this.entity[relation.propertyName];
                        // here because we have enabled RELATION_ID_VALUES option in the QueryBuilder when we loaded db entities
                        // we have in the dbSubject only relationIds.
                        // this allows us to compare relation id in the updated subject with id in the database.
                        // note that we used relation.name instead of relation.propertyName because query builder with RELATION_ID_VALUES
                        // returns values in the relation.name column, not relation.propertyName column
                        var dbEntityRelationId = _this.databaseEntity[relation.name];
                        // todo: try to find if there is update by relation operation - we dont need to generate update relation operation for this
                        // todo: if (updatesByRelations.find(operation => operation.targetEntity === this && operation.updatedRelation === relation))
                        // todo:     return false;
                        // we don't perform operation over undefined properties
                        if (updatedEntityRelationId === undefined)
                            return false;
                        // if both are empty totally no need to do anything
                        if ((updatedEntityRelationId === undefined || updatedEntityRelationId === null) &&
                            (dbEntityRelationId === undefined || dbEntityRelationId === null))
                            return false;
                        // if relation ids aren't equal then we need to update them
                        return updatedEntityRelationId !== dbEntityRelationId;
                    });
                };
                return Subject;
            }());
            exports_63("Subject", Subject);
        }
    };
});
System.register("typeorm/common/ObjectType", [], function (exports_64, context_64) {
    "use strict";
    var __moduleName = context_64 && context_64.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/repository/TreeRepository", ["typeorm/repository/Repository"], function (exports_65, context_65) {
    "use strict";
    var __moduleName = context_65 && context_65.id;
    var Repository_1, TreeRepository;
    return {
        setters: [
            function (Repository_1_1) {
                Repository_1 = Repository_1_1;
            }
        ],
        execute: function () {
            /**
             * Repository with additional functions to work with trees.
             *
             * @see Repository
             */
            TreeRepository = (function (_super) {
                __extends(TreeRepository, _super);
                function TreeRepository() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                // todo: implement moving
                // todo: implement removing
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Gets complete trees for all roots in the table.
                 */
                TreeRepository.prototype.findTrees = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var roots;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.findRoots()];
                                case 1:
                                    roots = _a.sent();
                                    return [4 /*yield*/, Promise.all(roots.map(function (root) { return __awaiter(_this, void 0, void 0, function () {
                                            return __generator(this, function (_a) {
                                                switch (_a.label) {
                                                    case 0: return [4 /*yield*/, this.findDescendantsTree(root)];
                                                    case 1:
                                                        _a.sent();
                                                        return [2 /*return*/];
                                                }
                                            });
                                        }); }))];
                                case 2:
                                    _a.sent();
                                    return [2 /*return*/, roots];
                            }
                        });
                    });
                };
                /**
                 * Roots are entities that have no ancestors. Finds them all.
                 */
                TreeRepository.prototype.findRoots = function () {
                    var parentPropertyName = this.metadata.treeParentRelation.propertyName;
                    return this.createQueryBuilder("treeEntity")
                        .where("treeEntity." + parentPropertyName + " IS NULL")
                        .getMany();
                };
                /**
                 * Creates a query builder used to get descendants of the entities in a tree.
                 */
                TreeRepository.prototype.createDescendantsQueryBuilder = function (alias, closureTableAlias, entity) {
                    var _this = this;
                    // create shortcuts for better readability
                    var escapeAlias = function (alias) { return _this.connection.driver.escapeAliasName(alias); };
                    var escapeColumn = function (column) { return _this.connection.driver.escapeColumnName(column); };
                    var joinCondition = escapeAlias(alias) + "." + escapeColumn(this.metadata.firstPrimaryColumn.name) + "=" + escapeAlias(closureTableAlias) + "." + escapeColumn("descendant");
                    return this.createQueryBuilder(alias)
                        .innerJoin(this.metadata.closureJunctionTable.table.name, closureTableAlias, joinCondition)
                        .where(escapeAlias(closureTableAlias) + "." + escapeColumn("ancestor") + "=" + this.metadata.getEntityIdMap(entity)[this.metadata.firstPrimaryColumn.propertyName]);
                };
                /**
                 * Gets all children (descendants) of the given entity. Returns them all in a flat array.
                 */
                TreeRepository.prototype.findDescendants = function (entity) {
                    return this
                        .createDescendantsQueryBuilder("treeEntity", "treeClosure", entity)
                        .getMany();
                };
                /**
                 * Gets all children (descendants) of the given entity. Returns them in a tree - nested into each other.
                 */
                TreeRepository.prototype.findDescendantsTree = function (entity) {
                    var _this = this;
                    // todo: throw exception if there is no column of this relation?
                    return this
                        .createDescendantsQueryBuilder("treeEntity", "treeClosure", entity)
                        .getEntitiesAndRawResults()
                        .then(function (entitiesAndScalars) {
                        var relationMaps = _this.createRelationMaps("treeEntity", entitiesAndScalars.rawResults);
                        _this.buildChildrenEntityTree(entity, entitiesAndScalars.entities, relationMaps);
                        return entity;
                    });
                };
                /**
                 * Gets number of descendants of the entity.
                 */
                TreeRepository.prototype.countDescendants = function (entity) {
                    return this
                        .createDescendantsQueryBuilder("treeEntity", "treeClosure", entity)
                        .getCount();
                };
                /**
                 * Creates a query builder used to get ancestors of the entities in the tree.
                 */
                TreeRepository.prototype.createAncestorsQueryBuilder = function (alias, closureTableAlias, entity) {
                    var _this = this;
                    // create shortcuts for better readability
                    var escapeAlias = function (alias) { return _this.connection.driver.escapeAliasName(alias); };
                    var escapeColumn = function (column) { return _this.connection.driver.escapeColumnName(column); };
                    var joinCondition = escapeAlias(alias) + "." + escapeColumn(this.metadata.firstPrimaryColumn.name) + "=" + escapeAlias(closureTableAlias) + "." + escapeColumn("ancestor");
                    return this.createQueryBuilder(alias)
                        .innerJoin(this.metadata.closureJunctionTable.table.name, closureTableAlias, joinCondition)
                        .where(escapeAlias(closureTableAlias) + "." + escapeColumn("descendant") + "=" + this.metadata.getEntityIdMap(entity)[this.metadata.firstPrimaryColumn.propertyName]);
                };
                /**
                 * Gets all parents (ancestors) of the given entity. Returns them all in a flat array.
                 */
                TreeRepository.prototype.findAncestors = function (entity) {
                    return this
                        .createAncestorsQueryBuilder("treeEntity", "treeClosure", entity)
                        .getMany();
                };
                /**
                 * Gets all parents (ancestors) of the given entity. Returns them in a tree - nested into each other.
                 */
                TreeRepository.prototype.findAncestorsTree = function (entity) {
                    var _this = this;
                    // todo: throw exception if there is no column of this relation?
                    return this
                        .createAncestorsQueryBuilder("treeEntity", "treeClosure", entity)
                        .getEntitiesAndRawResults()
                        .then(function (entitiesAndScalars) {
                        var relationMaps = _this.createRelationMaps("treeEntity", entitiesAndScalars.rawResults);
                        _this.buildParentEntityTree(entity, entitiesAndScalars.entities, relationMaps);
                        return entity;
                    });
                };
                /**
                 * Gets number of ancestors of the entity.
                 */
                TreeRepository.prototype.countAncestors = function (entity) {
                    return this
                        .createAncestorsQueryBuilder("treeEntity", "treeClosure", entity)
                        .getCount();
                };
                /**
                 * Moves entity to the children of then given entity.
                 *
                move(entity: Entity, to: Entity): Promise<void> {
                    return Promise.resolve();
                } */
                // -------------------------------------------------------------------------
                // Protected Methods
                // -------------------------------------------------------------------------
                TreeRepository.prototype.createRelationMaps = function (alias, rawResults) {
                    var _this = this;
                    return rawResults.map(function (rawResult) {
                        return {
                            id: rawResult[alias + "_" + _this.metadata.firstPrimaryColumn.name],
                            parentId: rawResult[alias + "_" + _this.metadata.treeParentRelation.name]
                        };
                    });
                };
                TreeRepository.prototype.buildChildrenEntityTree = function (entity, entities, relationMaps) {
                    var _this = this;
                    var childProperty = this.metadata.treeChildrenRelation.propertyName;
                    var parentEntityId = entity[this.metadata.firstPrimaryColumn.propertyName];
                    var childRelationMaps = relationMaps.filter(function (relationMap) { return relationMap.parentId === parentEntityId; });
                    var childIds = childRelationMaps.map(function (relationMap) { return relationMap.id; });
                    entity[childProperty] = entities.filter(function (entity) { return childIds.indexOf(entity[_this.metadata.firstPrimaryColumn.propertyName]) !== -1; });
                    entity[childProperty].forEach(function (childEntity) {
                        _this.buildChildrenEntityTree(childEntity, entities, relationMaps);
                    });
                };
                TreeRepository.prototype.buildParentEntityTree = function (entity, entities, relationMaps) {
                    var _this = this;
                    var parentProperty = this.metadata.treeParentRelation.propertyName;
                    var entityId = entity[this.metadata.firstPrimaryColumn.propertyName];
                    var parentRelationMap = relationMaps.find(function (relationMap) { return relationMap.id === entityId; });
                    var parentEntity = entities.find(function (entity) {
                        if (!parentRelationMap)
                            return false;
                        return entity[_this.metadata.firstPrimaryColumn.propertyName] === parentRelationMap.parentId;
                    });
                    if (parentEntity) {
                        entity[parentProperty] = parentEntity;
                        this.buildParentEntityTree(entity[parentProperty], entities, relationMaps);
                    }
                };
                return TreeRepository;
            }(Repository_1.Repository));
            exports_65("TreeRepository", TreeRepository);
        }
    };
});
System.register("typeorm/repository/SpecificRepository", ["typeorm/query-runner/QueryRunnerProvider", "typeorm/persistence/Subject", "typeorm/metadata/RelationMetadata", "typeorm/query-builder/QueryBuilder"], function (exports_66, context_66) {
    "use strict";
    var __moduleName = context_66 && context_66.id;
    var QueryRunnerProvider_2, Subject_1, RelationMetadata_1, QueryBuilder_2, SpecificRepository;
    return {
        setters: [
            function (QueryRunnerProvider_2_1) {
                QueryRunnerProvider_2 = QueryRunnerProvider_2_1;
            },
            function (Subject_1_1) {
                Subject_1 = Subject_1_1;
            },
            function (RelationMetadata_1_1) {
                RelationMetadata_1 = RelationMetadata_1_1;
            },
            function (QueryBuilder_2_1) {
                QueryBuilder_2 = QueryBuilder_2_1;
            }
        ],
        execute: function () {
            /**
             * Repository for more specific operations.
             */
            SpecificRepository = (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function SpecificRepository(connection, metadata, queryRunnerProvider) {
                    this.connection = connection;
                    this.metadata = metadata;
                    this.queryRunnerProvider = queryRunnerProvider;
                }
                /**
                 * Sets given relatedEntityId to the value of the relation of the entity with entityId id.
                 * Should be used when you want quickly and efficiently set a relation (for many-to-one and one-to-many) to some entity.
                 * Note that event listeners and event subscribers won't work (and will not send any events) when using this operation.
                 */
                SpecificRepository.prototype.setRelation = function (relationName, entityId, relatedEntityId) {
                    return __awaiter(this, void 0, void 0, function () {
                        var propertyName, relation, table, values, conditions, queryRunnerProvider, queryRunner;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    propertyName = this.metadata.computePropertyName(relationName);
                                    if (!this.metadata.hasRelationWithPropertyName(propertyName))
                                        throw new Error("Relation " + propertyName + " was not found in the " + this.metadata.name + " entity.");
                                    relation = this.metadata.findRelationWithPropertyName(propertyName);
                                    // if (relation.isManyToMany || relation.isOneToMany || relation.isOneToOneNotOwner)
                                    //     throw new Error(`Only many-to-one and one-to-one with join column are supported for this operation. ${this.metadata.name}#${propertyName} relation type is ${relation.relationType}`);
                                    if (relation.isManyToMany)
                                        throw new Error("Many-to-many relation is not supported for this operation. Use #addToRelation method for many-to-many relations.");
                                    values = {}, conditions = {};
                                    if (relation.isOwning) {
                                        table = relation.entityMetadata.table.name;
                                        values[relation.name] = relatedEntityId;
                                        conditions[relation.joinColumn.referencedColumn.name] = entityId;
                                    }
                                    else {
                                        table = relation.inverseEntityMetadata.table.name;
                                        values[relation.inverseRelation.name] = relatedEntityId;
                                        conditions[relation.inverseRelation.joinColumn.referencedColumn.name] = entityId;
                                    }
                                    queryRunnerProvider = this.queryRunnerProvider ? this.queryRunnerProvider : new QueryRunnerProvider_2.QueryRunnerProvider(this.connection.driver);
                                    return [4 /*yield*/, queryRunnerProvider.provide()];
                                case 1:
                                    queryRunner = _a.sent();
                                    return [4 /*yield*/, queryRunner.update(table, values, conditions)];
                                case 2:
                                    _a.sent();
                                    if (!!this.queryRunnerProvider) return [3 /*break*/, 4];
                                    return [4 /*yield*/, queryRunnerProvider.release(queryRunner)];
                                case 3:
                                    _a.sent();
                                    _a.label = 4;
                                case 4: return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Sets given relatedEntityId to the value of the relation of the entity with entityId id.
                 * Should be used when you want quickly and efficiently set a relation (for many-to-one and one-to-many) to some entity.
                 * Note that event listeners and event subscribers won't work (and will not send any events) when using this operation.
                 */
                SpecificRepository.prototype.setInverseRelation = function (relationName, relatedEntityId, entityId) {
                    return __awaiter(this, void 0, void 0, function () {
                        var propertyName, relation, table, values, conditions, queryRunnerProvider, queryRunner;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    propertyName = this.metadata.computePropertyName(relationName);
                                    if (!this.metadata.hasRelationWithPropertyName(propertyName))
                                        throw new Error("Relation " + propertyName + " was not found in the " + this.metadata.name + " entity.");
                                    relation = this.metadata.findRelationWithPropertyName(propertyName);
                                    // if (relation.isManyToMany || relation.isOneToMany || relation.isOneToOneNotOwner)
                                    //     throw new Error(`Only many-to-one and one-to-one with join column are supported for this operation. ${this.metadata.name}#${propertyName} relation type is ${relation.relationType}`);
                                    if (relation.isManyToMany)
                                        throw new Error("Many-to-many relation is not supported for this operation. Use #addToRelation method for many-to-many relations.");
                                    values = {}, conditions = {};
                                    if (relation.isOwning) {
                                        table = relation.inverseEntityMetadata.table.name;
                                        values[relation.inverseRelation.name] = relatedEntityId;
                                        conditions[relation.inverseRelation.joinColumn.referencedColumn.name] = entityId;
                                    }
                                    else {
                                        table = relation.entityMetadata.table.name;
                                        values[relation.name] = relatedEntityId;
                                        conditions[relation.joinColumn.referencedColumn.name] = entityId;
                                    }
                                    queryRunnerProvider = this.queryRunnerProvider ? this.queryRunnerProvider : new QueryRunnerProvider_2.QueryRunnerProvider(this.connection.driver);
                                    return [4 /*yield*/, queryRunnerProvider.provide()];
                                case 1:
                                    queryRunner = _a.sent();
                                    return [4 /*yield*/, queryRunner.update(table, values, conditions)];
                                case 2:
                                    _a.sent();
                                    if (!!this.queryRunnerProvider) return [3 /*break*/, 4];
                                    return [4 /*yield*/, queryRunnerProvider.release(queryRunner)];
                                case 3:
                                    _a.sent();
                                    _a.label = 4;
                                case 4: return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Adds a new relation between two entities into relation's many-to-many table.
                 * Should be used when you want quickly and efficiently add a relation between two entities.
                 * Note that event listeners and event subscribers won't work (and will not send any events) when using this operation.
                 */
                SpecificRepository.prototype.addToRelation = function (relationName, entityId, relatedEntityIds) {
                    return __awaiter(this, void 0, void 0, function () {
                        var propertyName, relation, queryRunnerProvider, queryRunner, insertPromises;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    propertyName = this.metadata.computePropertyName(relationName);
                                    if (!this.metadata.hasRelationWithPropertyName(propertyName))
                                        throw new Error("Relation " + propertyName + " was not found in the " + this.metadata.name + " entity.");
                                    relation = this.metadata.findRelationWithPropertyName(propertyName);
                                    if (!relation.isManyToMany)
                                        throw new Error("Only many-to-many relation supported for this operation. However " + this.metadata.name + "#" + propertyName + " relation type is " + relation.relationType);
                                    queryRunnerProvider = this.queryRunnerProvider ? this.queryRunnerProvider : new QueryRunnerProvider_2.QueryRunnerProvider(this.connection.driver);
                                    return [4 /*yield*/, queryRunnerProvider.provide()];
                                case 1:
                                    queryRunner = _a.sent();
                                    insertPromises = relatedEntityIds.map(function (relatedEntityId) {
                                        var values = {};
                                        if (relation.isOwning) {
                                            values[relation.junctionEntityMetadata.columns[0].name] = entityId;
                                            values[relation.junctionEntityMetadata.columns[1].name] = relatedEntityId;
                                        }
                                        else {
                                            values[relation.junctionEntityMetadata.columns[1].name] = entityId;
                                            values[relation.junctionEntityMetadata.columns[0].name] = relatedEntityId;
                                        }
                                        return queryRunner.insert(relation.junctionEntityMetadata.table.name, values);
                                    });
                                    return [4 /*yield*/, Promise.all(insertPromises)];
                                case 2:
                                    _a.sent();
                                    if (!!this.queryRunnerProvider) return [3 /*break*/, 4];
                                    return [4 /*yield*/, queryRunnerProvider.release(queryRunner)];
                                case 3:
                                    _a.sent();
                                    _a.label = 4;
                                case 4: return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Adds a new relation between two entities into relation's many-to-many table from inverse side of the given relation.
                 * Should be used when you want quickly and efficiently add a relation between two entities.
                 * Note that event listeners and event subscribers won't work (and will not send any events) when using this operation.
                 */
                SpecificRepository.prototype.addToInverseRelation = function (relationName, relatedEntityId, entityIds) {
                    return __awaiter(this, void 0, void 0, function () {
                        var propertyName, relation, queryRunnerProvider, queryRunner, insertPromises;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    propertyName = this.metadata.computePropertyName(relationName);
                                    if (!this.metadata.hasRelationWithPropertyName(propertyName))
                                        throw new Error("Relation " + propertyName + " was not found in the " + this.metadata.name + " entity.");
                                    relation = this.metadata.findRelationWithPropertyName(propertyName);
                                    if (!relation.isManyToMany)
                                        throw new Error("Only many-to-many relation supported for this operation. However " + this.metadata.name + "#" + propertyName + " relation type is " + relation.relationType);
                                    queryRunnerProvider = this.queryRunnerProvider ? this.queryRunnerProvider : new QueryRunnerProvider_2.QueryRunnerProvider(this.connection.driver);
                                    return [4 /*yield*/, queryRunnerProvider.provide()];
                                case 1:
                                    queryRunner = _a.sent();
                                    _a.label = 2;
                                case 2:
                                    _a.trys.push([2, , 4, 7]);
                                    insertPromises = entityIds.map(function (entityId) {
                                        var values = {};
                                        if (relation.isOwning) {
                                            values[relation.junctionEntityMetadata.columns[0].name] = entityId;
                                            values[relation.junctionEntityMetadata.columns[1].name] = relatedEntityId;
                                        }
                                        else {
                                            values[relation.junctionEntityMetadata.columns[1].name] = entityId;
                                            values[relation.junctionEntityMetadata.columns[0].name] = relatedEntityId;
                                        }
                                        return queryRunner.insert(relation.junctionEntityMetadata.table.name, values);
                                    });
                                    return [4 /*yield*/, Promise.all(insertPromises)];
                                case 3:
                                    _a.sent();
                                    return [3 /*break*/, 7];
                                case 4:
                                    if (!!this.queryRunnerProvider) return [3 /*break*/, 6];
                                    return [4 /*yield*/, queryRunnerProvider.release(queryRunner)];
                                case 5:
                                    _a.sent();
                                    _a.label = 6;
                                case 6: return [7 /*endfinally*/];
                                case 7: return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Removes a relation between two entities from relation's many-to-many table.
                 * Should be used when you want quickly and efficiently remove a many-to-many relation between two entities.
                 * Note that event listeners and event subscribers won't work (and will not send any events) when using this operation.
                 */
                SpecificRepository.prototype.removeFromRelation = function (relationName, entityId, relatedEntityIds) {
                    return __awaiter(this, void 0, void 0, function () {
                        var propertyName, relation, qb, firstColumnName, secondColumnName;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    propertyName = this.metadata.computePropertyName(relationName);
                                    if (!this.metadata.hasRelationWithPropertyName(propertyName))
                                        throw new Error("Relation " + propertyName + " was not found in the " + this.metadata.name + " entity.");
                                    relation = this.metadata.findRelationWithPropertyName(propertyName);
                                    if (!relation.isManyToMany)
                                        throw new Error("Only many-to-many relation supported for this operation. However " + this.metadata.name + "#" + propertyName + " relation type is " + relation.relationType);
                                    // check if given relation entity ids is empty - then nothing to do here (otherwise next code will remove all ids)
                                    if (!relatedEntityIds || !relatedEntityIds.length)
                                        return [2 /*return*/, Promise.resolve()];
                                    qb = new QueryBuilder_2.QueryBuilder(this.connection, this.queryRunnerProvider)
                                        .delete()
                                        .fromTable(relation.junctionEntityMetadata.table.name, "junctionEntity");
                                    firstColumnName = this.connection.driver.escapeColumnName(relation.isOwning ? relation.junctionEntityMetadata.columns[0].name : relation.junctionEntityMetadata.columns[1].name);
                                    secondColumnName = this.connection.driver.escapeColumnName(relation.isOwning ? relation.junctionEntityMetadata.columns[1].name : relation.junctionEntityMetadata.columns[0].name);
                                    relatedEntityIds.forEach(function (relatedEntityId, index) {
                                        qb.orWhere("(" + firstColumnName + "=:entityId AND " + secondColumnName + "=:relatedEntity_" + index + ")")
                                            .setParameter("relatedEntity_" + index, relatedEntityId);
                                    });
                                    return [4 /*yield*/, qb
                                            .setParameter("entityId", entityId)
                                            .execute()];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Removes a relation between two entities from relation's many-to-many table.
                 * Should be used when you want quickly and efficiently remove a many-to-many relation between two entities.
                 * Note that event listeners and event subscribers won't work (and will not send any events) when using this operation.
                 */
                SpecificRepository.prototype.removeFromInverseRelation = function (relationName, relatedEntityId, entityIds) {
                    return __awaiter(this, void 0, void 0, function () {
                        var propertyName, relation, qb, firstColumnName, secondColumnName;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    propertyName = this.metadata.computePropertyName(relationName);
                                    if (!this.metadata.hasRelationWithPropertyName(propertyName))
                                        throw new Error("Relation " + propertyName + " was not found in the " + this.metadata.name + " entity.");
                                    relation = this.metadata.findRelationWithPropertyName(propertyName);
                                    if (!relation.isManyToMany)
                                        throw new Error("Only many-to-many relation supported for this operation. However " + this.metadata.name + "#" + propertyName + " relation type is " + relation.relationType);
                                    // check if given entity ids is empty - then nothing to do here (otherwise next code will remove all ids)
                                    if (!entityIds || !entityIds.length)
                                        return [2 /*return*/, Promise.resolve()];
                                    qb = new QueryBuilder_2.QueryBuilder(this.connection, this.queryRunnerProvider)
                                        .delete()
                                        .from(relation.junctionEntityMetadata.table.name, "junctionEntity");
                                    firstColumnName = relation.isOwning ? relation.junctionEntityMetadata.columns[1].name : relation.junctionEntityMetadata.columns[0].name;
                                    secondColumnName = relation.isOwning ? relation.junctionEntityMetadata.columns[0].name : relation.junctionEntityMetadata.columns[1].name;
                                    entityIds.forEach(function (entityId, index) {
                                        qb.orWhere("(" + firstColumnName + "=:relatedEntityId AND " + secondColumnName + "=:entity_" + index + ")")
                                            .setParameter("entity_" + index, entityId);
                                    });
                                    return [4 /*yield*/, qb.setParameter("relatedEntityId", relatedEntityId).execute()];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Performs both #addToRelation and #removeFromRelation operations.
                 * Should be used when you want quickly and efficiently and and remove a many-to-many relation between two entities.
                 * Note that event listeners and event subscribers won't work (and will not send any events) when using this operation.
                 */
                SpecificRepository.prototype.addAndRemoveFromRelation = function (relation, entityId, addRelatedEntityIds, removeRelatedEntityIds) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, Promise.all([
                                        this.addToRelation(relation, entityId, addRelatedEntityIds),
                                        this.removeFromRelation(relation, entityId, removeRelatedEntityIds)
                                    ])];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Performs both #addToRelation and #removeFromRelation operations.
                 * Should be used when you want quickly and efficiently and and remove a many-to-many relation between two entities.
                 * Note that event listeners and event subscribers won't work (and will not send any events) when using this operation.
                 */
                SpecificRepository.prototype.addAndRemoveFromInverseRelation = function (relation, relatedEntityId, addEntityIds, removeEntityIds) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, Promise.all([
                                        this.addToInverseRelation(relation, relatedEntityId, addEntityIds),
                                        this.removeFromInverseRelation(relation, relatedEntityId, removeEntityIds)
                                    ])];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Removes entity with the given id.
                 * Note that event listeners and event subscribers won't work (and will not send any events) when using this operation.
                 */
                SpecificRepository.prototype.removeById = function (id) {
                    return __awaiter(this, void 0, void 0, function () {
                        var alias, parameters, condition;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    alias = this.metadata.table.name;
                                    parameters = {};
                                    condition = "";
                                    if (this.metadata.hasMultiplePrimaryKeys) {
                                        condition = this.metadata.primaryColumns.map(function (primaryColumn) {
                                            parameters[primaryColumn.propertyName] = id[primaryColumn.propertyName];
                                            return alias + "." + primaryColumn.propertyName + "=:" + primaryColumn.propertyName;
                                        }).join(" AND ");
                                    }
                                    else {
                                        condition = alias + "." + this.metadata.firstPrimaryColumn.propertyName + "=:id";
                                        parameters["id"] = id;
                                    }
                                    return [4 /*yield*/, new QueryBuilder_2.QueryBuilder(this.connection, this.queryRunnerProvider)
                                            .delete()
                                            .from(this.metadata.target, alias)
                                            .where(condition, parameters)
                                            .execute()];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Removes all entities with the given ids.
                 * Note that event listeners and event subscribers won't work (and will not send any events) when using this operation.
                 */
                SpecificRepository.prototype.removeByIds = function (ids) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var alias, parameters, condition;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    alias = this.metadata.table.name;
                                    parameters = {};
                                    condition = "";
                                    if (this.metadata.hasMultiplePrimaryKeys) {
                                        condition = ids.map(function (id, idIndex) {
                                            _this.metadata.primaryColumns.map(function (primaryColumn) {
                                                parameters[primaryColumn.propertyName + "_" + idIndex] = id[primaryColumn.propertyName];
                                                return alias + "." + primaryColumn.propertyName + "=:" + primaryColumn.propertyName + "_" + idIndex;
                                            }).join(" AND ");
                                        }).join(" OR ");
                                    }
                                    else {
                                        condition = alias + "." + this.metadata.firstPrimaryColumn.propertyName + " IN (:ids)";
                                        parameters["ids"] = ids;
                                    }
                                    return [4 /*yield*/, new QueryBuilder_2.QueryBuilder(this.connection, this.queryRunnerProvider)
                                            .delete()
                                            .from(this.metadata.target, alias)
                                            .where(condition, parameters)
                                            .execute()];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Finds all relation ids in the given entities.
                 */
                SpecificRepository.prototype.findRelationIds = function (relationOrName, entityOrEntities, inIds, notInIds) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var relation, entityReferencedColumn, ownerEntityColumn, inverseEntityColumn, entityIds, escapeAlias, escapeColumn, ids, promises;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    relation = this.convertMixedRelationToMetadata(relationOrName);
                                    if (!(entityOrEntities instanceof Array))
                                        entityOrEntities = [entityOrEntities];
                                    entityReferencedColumn = relation.isOwning ? relation.joinTable.referencedColumn : relation.inverseRelation.joinTable.inverseReferencedColumn;
                                    ownerEntityColumn = relation.isOwning ? relation.junctionEntityMetadata.columns[0] : relation.junctionEntityMetadata.columns[1];
                                    inverseEntityColumn = relation.isOwning ? relation.junctionEntityMetadata.columns[1] : relation.junctionEntityMetadata.columns[0];
                                    entityIds = this.convertEntityOrEntitiesToIdOrIds(entityReferencedColumn, entityOrEntities);
                                    if (!(entityIds instanceof Array))
                                        entityIds = [entityIds];
                                    // filter out empty entity ids
                                    entityIds = entityIds.filter(function (entityId) { return entityId !== null && entityId !== undefined; });
                                    // if no entity ids at the end, then we don't need to load anything
                                    if (entityIds.length === 0)
                                        return [2 /*return*/, []];
                                    escapeAlias = function (alias) { return _this.connection.driver.escapeAliasName(alias); };
                                    escapeColumn = function (column) { return _this.connection.driver.escapeColumnName(column); };
                                    ids = [];
                                    promises = entityIds.map(function (entityId) {
                                        var qb = new QueryBuilder_2.QueryBuilder(_this.connection, _this.queryRunnerProvider)
                                            .select(escapeAlias("junction") + "." + escapeColumn(inverseEntityColumn.name) + " AS id")
                                            .fromTable(relation.junctionEntityMetadata.table.name, "junction")
                                            .andWhere(escapeAlias("junction") + "." + escapeColumn(ownerEntityColumn.name) + "=:entityId", { entityId: entityId });
                                        if (inIds && inIds.length > 0)
                                            qb.andWhere(escapeAlias("junction") + "." + escapeColumn(inverseEntityColumn.name) + " IN (:inIds)", { inIds: inIds });
                                        if (notInIds && notInIds.length > 0)
                                            qb.andWhere(escapeAlias("junction") + "." + escapeColumn(inverseEntityColumn.name) + " NOT IN (:notInIds)", { notInIds: notInIds });
                                        return qb.getRawMany()
                                            .then(function (results) {
                                            results.forEach(function (result) { return ids.push(result.id); }); // todo: prepare result?
                                        });
                                    });
                                    return [4 /*yield*/, Promise.all(promises)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/, ids];
                            }
                        });
                    });
                };
                // -------------------------------------------------------------------------
                // Protected Methods
                // -------------------------------------------------------------------------
                /**
                 * Converts entity or entities to id or ids map.
                 */
                SpecificRepository.prototype.convertEntityOrEntitiesToIdOrIds = function (column, entityOrEntities) {
                    var _this = this;
                    if (entityOrEntities instanceof Array) {
                        return entityOrEntities.map(function (entity) { return _this.convertEntityOrEntitiesToIdOrIds(column, entity); });
                    }
                    else {
                        if (entityOrEntities instanceof Object) {
                            return entityOrEntities[column.propertyName];
                        }
                        else {
                            return entityOrEntities;
                        }
                    }
                };
                /**
                 * Converts relation name, relation name in function into RelationMetadata.
                 */
                SpecificRepository.prototype.convertMixedRelationToMetadata = function (relationOrName) {
                    if (relationOrName instanceof RelationMetadata_1.RelationMetadata)
                        return relationOrName;
                    var relationName = relationOrName instanceof Function ? relationOrName(this.metadata.createPropertiesMap()) : relationOrName;
                    return this.metadata.findRelationWithPropertyName(relationName);
                };
                /**
                 * Extracts unique objects from given entity and all its downside relations.
                 */
                SpecificRepository.prototype.extractObjectsById = function (entity, metadata, entityWithIds) {
                    var _this = this;
                    if (entityWithIds === void 0) { entityWithIds = []; }
                    var promises = metadata.relations.map(function (relation) {
                        var relMetadata = relation.inverseEntityMetadata;
                        var value = relation.isLazy ? entity["__" + relation.propertyName + "__"] : entity[relation.propertyName];
                        if (!value)
                            return undefined;
                        if (value instanceof Array) {
                            var subPromises = value.map(function (subEntity) {
                                return _this.extractObjectsById(subEntity, relMetadata, entityWithIds);
                            });
                            return Promise.all(subPromises);
                        }
                        else {
                            return _this.extractObjectsById(value, relMetadata, entityWithIds);
                        }
                    });
                    return Promise.all(promises.filter(function (result) { return !!result; })).then(function () {
                        if (!entityWithIds.find(function (entityWithId) { return entityWithId.entity === entity; })) {
                            var entityWithId = new Subject_1.Subject(metadata, entity);
                            entityWithIds.push(entityWithId);
                        }
                        return entityWithIds;
                    });
                };
                return SpecificRepository;
            }());
            exports_66("SpecificRepository", SpecificRepository);
        }
    };
});
System.register("typeorm/repository/RepositoryFactory", ["typeorm/repository/TreeRepository", "typeorm/repository/Repository", "typeorm/repository/SpecificRepository"], function (exports_67, context_67) {
    "use strict";
    var __moduleName = context_67 && context_67.id;
    var TreeRepository_1, Repository_2, SpecificRepository_1, RepositoryFactory;
    return {
        setters: [
            function (TreeRepository_1_1) {
                TreeRepository_1 = TreeRepository_1_1;
            },
            function (Repository_2_1) {
                Repository_2 = Repository_2_1;
            },
            function (SpecificRepository_1_1) {
                SpecificRepository_1 = SpecificRepository_1_1;
            }
        ],
        execute: function () {
            /**
             * Factory used to create different types of repositories.
             */
            RepositoryFactory = (function () {
                function RepositoryFactory() {
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Creates a regular repository.
                 */
                RepositoryFactory.prototype.createRepository = function (connection, metadata, queryRunnerProvider) {
                    // NOTE: dynamic access to protected properties. We need this to prevent unwanted properties in those classes to be exposed,
                    // however we need these properties for internal work of the class
                    var repository = new Repository_2.Repository();
                    repository["connection"] = connection;
                    repository["metadata"] = metadata;
                    repository["queryRunnerProvider"] = queryRunnerProvider;
                    return repository;
                };
                /**
                 * Creates a tree repository.
                 */
                RepositoryFactory.prototype.createTreeRepository = function (connection, metadata, queryRunnerProvider) {
                    // NOTE: dynamic access to protected properties. We need this to prevent unwanted properties in those classes to be exposed,
                    // however we need these properties for internal work of the class
                    var repository = new TreeRepository_1.TreeRepository();
                    repository["connection"] = connection;
                    repository["metadata"] = metadata;
                    repository["queryRunnerProvider"] = queryRunnerProvider;
                    return repository;
                };
                /**
                 * Creates a specific repository.
                 */
                RepositoryFactory.prototype.createSpecificRepository = function (connection, metadata, repository, queryRunnerProvider) {
                    return new SpecificRepository_1.SpecificRepository(connection, metadata, queryRunnerProvider);
                };
                return RepositoryFactory;
            }());
            exports_67("RepositoryFactory", RepositoryFactory);
        }
    };
});
System.register("typeorm/repository/RepositoryAggregator", ["typeorm/index", "typeorm/repository/RepositoryFactory"], function (exports_68, context_68) {
    "use strict";
    var __moduleName = context_68 && context_68.id;
    var index_1, RepositoryFactory_1, RepositoryAggregator;
    return {
        setters: [
            function (index_1_1) {
                index_1 = index_1_1;
            },
            function (RepositoryFactory_1_1) {
                RepositoryFactory_1 = RepositoryFactory_1_1;
            }
        ],
        execute: function () {
            /**
             * Aggregates all repositories of the specific metadata.
             */
            RepositoryAggregator = (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function RepositoryAggregator(connection, metadata, queryRunnerProvider) {
                    var repositoryFactory = index_1.getFromContainer(RepositoryFactory_1.RepositoryFactory);
                    this.metadata = metadata;
                    if (metadata.table.isClosure) {
                        this.repository = this.treeRepository = repositoryFactory.createTreeRepository(connection, metadata, queryRunnerProvider);
                    }
                    else {
                        this.repository = repositoryFactory.createRepository(connection, metadata, queryRunnerProvider);
                    }
                    this.specificRepository = repositoryFactory.createSpecificRepository(connection, metadata, this.repository, queryRunnerProvider);
                }
                return RepositoryAggregator;
            }());
            exports_68("RepositoryAggregator", RepositoryAggregator);
        }
    };
});
System.register("typeorm/connection/error/RepositoryNotTreeError", [], function (exports_69, context_69) {
    "use strict";
    var __moduleName = context_69 && context_69.id;
    var RepositoryNotTreeError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown when repository for the given class is not found.
             */
            RepositoryNotTreeError = (function (_super) {
                __extends(RepositoryNotTreeError, _super);
                function RepositoryNotTreeError(entityClass) {
                    var _this = _super.call(this) || this;
                    _this.name = "RepositoryNotTreeError";
                    var targetName = typeof entityClass === "function" && entityClass.name ? entityClass.name : entityClass;
                    _this.message = "Repository of the \"" + targetName + "\" class is not a TreeRepository. Try to use @ClosureTable decorator instead of @Table.";
                    _this.stack = new Error().stack;
                    return _this;
                }
                return RepositoryNotTreeError;
            }(Error));
            exports_69("RepositoryNotTreeError", RepositoryNotTreeError);
        }
    };
});
System.register("typeorm/entity-manager/error/NoNeedToReleaseEntityManagerError", [], function (exports_70, context_70) {
    "use strict";
    var __moduleName = context_70 && context_70.id;
    var NoNeedToReleaseEntityManagerError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown when consumer tries to release entity manager that does not use single database connection.
             */
            NoNeedToReleaseEntityManagerError = (function (_super) {
                __extends(NoNeedToReleaseEntityManagerError, _super);
                function NoNeedToReleaseEntityManagerError() {
                    var _this = _super.call(this) || this;
                    _this.name = "NoNeedToReleaseEntityManagerError";
                    _this.message = "Entity manager is not using single database connection and cannot be released. " +
                        "Only entity managers created by connection#createEntityManagerWithSingleDatabaseConnection " +
                        "methods have a single database connection and they should be released.";
                    _this.stack = new Error().stack;
                    return _this;
                }
                return NoNeedToReleaseEntityManagerError;
            }(Error));
            exports_70("NoNeedToReleaseEntityManagerError", NoNeedToReleaseEntityManagerError);
        }
    };
});
System.register("typeorm/query-runner/error/QueryRunnerProviderAlreadyReleasedError", [], function (exports_71, context_71) {
    "use strict";
    var __moduleName = context_71 && context_71.id;
    var QueryRunnerProviderAlreadyReleasedError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown when consumer tries to use query runner from query runner provider after it was released.
             */
            QueryRunnerProviderAlreadyReleasedError = (function (_super) {
                __extends(QueryRunnerProviderAlreadyReleasedError, _super);
                function QueryRunnerProviderAlreadyReleasedError() {
                    var _this = _super.call(this) || this;
                    _this.name = "QueryRunnerProviderAlreadyReleasedError";
                    _this.message = "Database connection provided by a query runner was already released, cannot continue to use its querying methods anymore.";
                    _this.stack = new Error().stack;
                    return _this;
                }
                return QueryRunnerProviderAlreadyReleasedError;
            }(Error));
            exports_71("QueryRunnerProviderAlreadyReleasedError", QueryRunnerProviderAlreadyReleasedError);
        }
    };
});
System.register("typeorm/entity-manager/BaseEntityManager", ["typeorm/repository/RepositoryAggregator", "typeorm/connection/error/RepositoryNotTreeError", "typeorm/entity-manager/error/NoNeedToReleaseEntityManagerError", "typeorm/query-runner/error/QueryRunnerProviderAlreadyReleasedError"], function (exports_72, context_72) {
    "use strict";
    var __moduleName = context_72 && context_72.id;
    var RepositoryAggregator_1, RepositoryNotTreeError_1, NoNeedToReleaseEntityManagerError_1, QueryRunnerProviderAlreadyReleasedError_1, BaseEntityManager;
    return {
        setters: [
            function (RepositoryAggregator_1_1) {
                RepositoryAggregator_1 = RepositoryAggregator_1_1;
            },
            function (RepositoryNotTreeError_1_1) {
                RepositoryNotTreeError_1 = RepositoryNotTreeError_1_1;
            },
            function (NoNeedToReleaseEntityManagerError_1_1) {
                NoNeedToReleaseEntityManagerError_1 = NoNeedToReleaseEntityManagerError_1_1;
            },
            function (QueryRunnerProviderAlreadyReleasedError_1_1) {
                QueryRunnerProviderAlreadyReleasedError_1 = QueryRunnerProviderAlreadyReleasedError_1_1;
            }
        ],
        execute: function () {
            /**
             * Common functions shared between different entity manager types.
             */
            BaseEntityManager = (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                /**
                 * @param connection Connection to be used in this entity manager
                 * @param queryRunnerProvider Custom query runner to be used for operations in this entity manager
                 */
                function BaseEntityManager(connection, queryRunnerProvider) {
                    this.connection = connection;
                    this.queryRunnerProvider = queryRunnerProvider;
                    // -------------------------------------------------------------------------
                    // Private Properties
                    // -------------------------------------------------------------------------
                    /**
                     * Stores all registered repositories.
                     * Used when custom queryRunnerProvider is provided.
                     */
                    this.repositoryAggregators = [];
                }
                /**
                 * Gets repository for the given entity class or name.
                 * If single database connection mode is used, then repository is obtained from the
                 * repository aggregator, where each repository is individually created for this entity manager.
                 * When single database connection is not used, repository is being obtained from the connection.
                 */
                BaseEntityManager.prototype.getRepository = function (entityClassOrName) {
                    // if single db connection is used then create its own repository with reused query runner
                    if (this.queryRunnerProvider)
                        return this.obtainRepositoryAggregator(entityClassOrName).repository;
                    return this.connection.getRepository(entityClassOrName);
                };
                /**
                 * Gets tree repository for the given entity class or name.
                 * If single database connection mode is used, then repository is obtained from the
                 * repository aggregator, where each repository is individually created for this entity manager.
                 * When single database connection is not used, repository is being obtained from the connection.
                 */
                BaseEntityManager.prototype.getTreeRepository = function (entityClassOrName) {
                    // if single db connection is used then create its own repository with reused query runner
                    if (this.queryRunnerProvider) {
                        var treeRepository = this.obtainRepositoryAggregator(entityClassOrName).treeRepository;
                        if (!treeRepository)
                            throw new RepositoryNotTreeError_1.RepositoryNotTreeError(entityClassOrName);
                        return treeRepository;
                    }
                    return this.connection.getTreeRepository(entityClassOrName);
                };
                /**
                 * Gets specific repository for the given entity class or name.
                 * If single database connection mode is used, then repository is obtained from the
                 * repository aggregator, where each repository is individually created for this entity manager.
                 * When single database connection is not used, repository is being obtained from the connection.
                 */
                BaseEntityManager.prototype.getSpecificRepository = function (entityClassOrName) {
                    // if single db connection is used then create its own repository with reused query runner
                    if (this.queryRunnerProvider)
                        return this.obtainRepositoryAggregator(entityClassOrName).specificRepository;
                    return this.connection.getSpecificRepository(entityClassOrName);
                };
                /**
                 * Gets custom entity repository marked with @EntityRepository decorator.
                 */
                BaseEntityManager.prototype.getCustomRepository = function (customRepository) {
                    return this.connection.getCustomRepository(customRepository);
                };
                /**
                 * Checks if entity has an id by its Function type or schema name.
                 */
                BaseEntityManager.prototype.hasId = function (targetOrEntity, maybeEntity) {
                    var target = arguments.length === 2 ? targetOrEntity : targetOrEntity.constructor;
                    var entity = arguments.length === 2 ? maybeEntity : targetOrEntity;
                    return this.getRepository(target).hasId(entity);
                };
                /**
                 * Creates a new query builder that can be used to build an sql query.
                 */
                BaseEntityManager.prototype.createQueryBuilder = function (entityClass, alias) {
                    return this.getRepository(entityClass).createQueryBuilder(alias);
                };
                /**
                 * Creates a new entity instance or instances.
                 * Can copy properties from the given object into new entities.
                 */
                BaseEntityManager.prototype.create = function (entityClass, plainObjectOrObjects) {
                    if (plainObjectOrObjects instanceof Array) {
                        return this.getRepository(entityClass).create(plainObjectOrObjects);
                    }
                    else if (plainObjectOrObjects) {
                        return this.getRepository(entityClass).create(plainObjectOrObjects);
                    }
                    else {
                        return this.getRepository(entityClass).create();
                    }
                };
                /**
                 * Creates a new entity from the given plan javascript object. If entity already exist in the database, then
                 * it loads it (and everything related to it), replaces all values with the new ones from the given object
                 * and returns this new entity. This new entity is actually a loaded from the db entity with all properties
                 * replaced from the new object.
                 */
                BaseEntityManager.prototype.preload = function (entityClass, object) {
                    return this.getRepository(entityClass).preload(object);
                };
                /**
                 * Merges two entities into one new entity.
                 */
                BaseEntityManager.prototype.merge = function (entityClass) {
                    var objects = [];
                    for (var _i = 1; _i < arguments.length; _i++) {
                        objects[_i - 1] = arguments[_i];
                    }
                    return (_a = this.getRepository(entityClass)).merge.apply(_a, objects);
                    var _a;
                };
                /**
                 * Releases all resources used by entity manager.
                 * This is used when entity manager is created with a single query runner,
                 * and this single query runner needs to be released after job with entity manager is done.
                 */
                BaseEntityManager.prototype.release = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            if (!this.queryRunnerProvider)
                                throw new NoNeedToReleaseEntityManagerError_1.NoNeedToReleaseEntityManagerError();
                            return [2 /*return*/, this.queryRunnerProvider.releaseReused()];
                        });
                    });
                };
                // -------------------------------------------------------------------------
                // Protected Methods
                // -------------------------------------------------------------------------
                /**
                 * Gets, or if does not exist yet, creates and returns a repository aggregator for a particular entity target.
                 */
                BaseEntityManager.prototype.obtainRepositoryAggregator = function (entityClassOrName) {
                    if (this.queryRunnerProvider && this.queryRunnerProvider.isReleased)
                        throw new QueryRunnerProviderAlreadyReleasedError_1.QueryRunnerProviderAlreadyReleasedError();
                    var metadata = this.connection.getMetadata(entityClassOrName);
                    var repositoryAggregator = this.repositoryAggregators.find(function (repositoryAggregate) { return repositoryAggregate.metadata === metadata; });
                    if (!repositoryAggregator) {
                        repositoryAggregator = new RepositoryAggregator_1.RepositoryAggregator(this.connection, this.connection.getMetadata(entityClassOrName), this.queryRunnerProvider);
                        this.repositoryAggregators.push(repositoryAggregator); // todo: check isnt memory leak here?
                    }
                    return repositoryAggregator;
                };
                return BaseEntityManager;
            }());
            exports_72("BaseEntityManager", BaseEntityManager);
        }
    };
});
System.register("typeorm/entity-manager/EntityManager", ["typeorm/entity-manager/BaseEntityManager", "typeorm/query-runner/error/QueryRunnerProviderAlreadyReleasedError", "typeorm/query-runner/QueryRunnerProvider"], function (exports_73, context_73) {
    "use strict";
    var __moduleName = context_73 && context_73.id;
    var BaseEntityManager_1, QueryRunnerProviderAlreadyReleasedError_2, QueryRunnerProvider_3, EntityManager;
    return {
        setters: [
            function (BaseEntityManager_1_1) {
                BaseEntityManager_1 = BaseEntityManager_1_1;
            },
            function (QueryRunnerProviderAlreadyReleasedError_2_1) {
                QueryRunnerProviderAlreadyReleasedError_2 = QueryRunnerProviderAlreadyReleasedError_2_1;
            },
            function (QueryRunnerProvider_3_1) {
                QueryRunnerProvider_3 = QueryRunnerProvider_3_1;
            }
        ],
        execute: function () {
            /**
             * Entity manager supposed to work with any entity, automatically find its repository and call its methods,
             * whatever entity type are you passing.
             */
            EntityManager = (function (_super) {
                __extends(EntityManager, _super);
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function EntityManager(connection, queryRunnerProvider) {
                    return _super.call(this, connection, queryRunnerProvider) || this;
                }
                /**
                 * Persists (saves) a given entity in the database.
                 */
                EntityManager.prototype.persist = function (targetOrEntity, maybeEntity) {
                    var _this = this;
                    var target = arguments.length === 2 ? maybeEntity : targetOrEntity;
                    var entity = arguments.length === 2 ? maybeEntity : targetOrEntity;
                    return Promise.resolve().then(function () {
                        if (typeof target === "string") {
                            return _this.getRepository(target).persist(entity);
                        }
                        else {
                            if (target instanceof Array) {
                                if (target.length === 0)
                                    return Promise.resolve(target);
                                return Promise.all(target.map(function (t, i) {
                                    return _this.getRepository(t.constructor).persist(entity[i]);
                                }));
                            }
                            else {
                                return _this.getRepository(target.constructor).persist(entity);
                            }
                        }
                    });
                };
                /**
                 * Removes a given entity from the database.
                 */
                EntityManager.prototype.remove = function (targetOrEntity, maybeEntity) {
                    var _this = this;
                    var target = arguments.length === 2 ? maybeEntity : targetOrEntity;
                    var entity = arguments.length === 2 ? maybeEntity : targetOrEntity;
                    if (typeof target === "string") {
                        return this.getRepository(target).remove(entity);
                    }
                    else {
                        if (target instanceof Array) {
                            return Promise.all(target.map(function (t, i) {
                                return _this.getRepository(t.constructor).remove(entity[i]);
                            }));
                        }
                        else {
                            return this.getRepository(target.constructor).remove(entity);
                        }
                    }
                };
                /**
                 * Counts entities that match given conditions.
                 */
                EntityManager.prototype.count = function (entityClass, conditionsOrFindOptions, options) {
                    if (conditionsOrFindOptions && options) {
                        return this.getRepository(entityClass).count(conditionsOrFindOptions, options);
                    }
                    else if (conditionsOrFindOptions) {
                        return this.getRepository(entityClass).count(conditionsOrFindOptions);
                    }
                    else {
                        return this.getRepository(entityClass).count();
                    }
                };
                /**
                 * Finds entities that match given conditions.
                 */
                EntityManager.prototype.find = function (entityClass, conditionsOrFindOptions, options) {
                    if (conditionsOrFindOptions && options) {
                        return this.getRepository(entityClass).find(conditionsOrFindOptions, options);
                    }
                    else if (conditionsOrFindOptions) {
                        return this.getRepository(entityClass).find(conditionsOrFindOptions);
                    }
                    else {
                        return this.getRepository(entityClass).find();
                    }
                };
                /**
                 * Finds entities that match given conditions.
                 * Also counts all entities that match given conditions,
                 * but ignores pagination settings (maxResults, firstResult) options.
                 */
                EntityManager.prototype.findAndCount = function (entityClass, conditionsOrFindOptions, options) {
                    if (conditionsOrFindOptions && options) {
                        return this.getRepository(entityClass).findAndCount(conditionsOrFindOptions, options);
                    }
                    else if (conditionsOrFindOptions) {
                        return this.getRepository(entityClass).findAndCount(conditionsOrFindOptions);
                    }
                    else {
                        return this.getRepository(entityClass).findAndCount();
                    }
                };
                /**
                 * Finds first entity that matches given conditions.
                 */
                EntityManager.prototype.findOne = function (entityClass, conditionsOrFindOptions, options) {
                    if (conditionsOrFindOptions && options) {
                        return this.getRepository(entityClass).findOne(conditionsOrFindOptions, options);
                    }
                    else if (conditionsOrFindOptions) {
                        return this.getRepository(entityClass).findOne(conditionsOrFindOptions);
                    }
                    else {
                        return this.getRepository(entityClass).findOne();
                    }
                };
                /**
                 * Finds entities with ids.
                 * Optionally find options can be applied.
                 */
                EntityManager.prototype.findByIds = function (entityClass, ids, options) {
                    return this.getRepository(entityClass).findByIds(ids, options);
                };
                /**
                 * Finds entity with given id.
                 */
                EntityManager.prototype.findOneById = function (entityClass, id, options) {
                    return this.getRepository(entityClass).findOneById(id, options);
                };
                /**
                 * Executes raw SQL query and returns raw database results.
                 */
                EntityManager.prototype.query = function (query, parameters) {
                    return __awaiter(this, void 0, void 0, function () {
                        var queryRunnerProvider, queryRunner;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.queryRunnerProvider && this.queryRunnerProvider.isReleased)
                                        throw new QueryRunnerProviderAlreadyReleasedError_2.QueryRunnerProviderAlreadyReleasedError();
                                    queryRunnerProvider = this.queryRunnerProvider || new QueryRunnerProvider_3.QueryRunnerProvider(this.connection.driver);
                                    return [4 /*yield*/, queryRunnerProvider.provide()];
                                case 1:
                                    queryRunner = _a.sent();
                                    _a.label = 2;
                                case 2:
                                    _a.trys.push([2, , 4, 6]);
                                    return [4 /*yield*/, queryRunner.query(query, parameters)];
                                case 3: return [2 /*return*/, _a.sent()]; // await is needed here because we are using finally
                                case 4: return [4 /*yield*/, queryRunnerProvider.release(queryRunner)];
                                case 5:
                                    _a.sent();
                                    return [7 /*endfinally*/];
                                case 6: return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Wraps given function execution (and all operations made there) in a transaction.
                 * All database operations must be executed using provided entity manager.
                 */
                EntityManager.prototype.transaction = function (runInTransaction) {
                    return __awaiter(this, void 0, void 0, function () {
                        var queryRunnerProvider, queryRunner, transactionEntityManager, result, err_1;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.queryRunnerProvider && this.queryRunnerProvider.isReleased)
                                        throw new QueryRunnerProviderAlreadyReleasedError_2.QueryRunnerProviderAlreadyReleasedError();
                                    queryRunnerProvider = this.queryRunnerProvider || new QueryRunnerProvider_3.QueryRunnerProvider(this.connection.driver, true);
                                    return [4 /*yield*/, queryRunnerProvider.provide()];
                                case 1:
                                    queryRunner = _a.sent();
                                    transactionEntityManager = new EntityManager(this.connection, queryRunnerProvider);
                                    _a.label = 2;
                                case 2:
                                    _a.trys.push([2, 6, 8, 12]);
                                    return [4 /*yield*/, queryRunner.beginTransaction()];
                                case 3:
                                    _a.sent();
                                    return [4 /*yield*/, runInTransaction(transactionEntityManager)];
                                case 4:
                                    result = _a.sent();
                                    return [4 /*yield*/, queryRunner.commitTransaction()];
                                case 5:
                                    _a.sent();
                                    return [2 /*return*/, result];
                                case 6:
                                    err_1 = _a.sent();
                                    return [4 /*yield*/, queryRunner.rollbackTransaction()];
                                case 7:
                                    _a.sent();
                                    throw err_1;
                                case 8: return [4 /*yield*/, queryRunnerProvider.release(queryRunner)];
                                case 9:
                                    _a.sent();
                                    if (!!this.queryRunnerProvider) return [3 /*break*/, 11];
                                    return [4 /*yield*/, queryRunnerProvider.releaseReused()];
                                case 10:
                                    _a.sent();
                                    _a.label = 11;
                                case 11: return [7 /*endfinally*/];
                                case 12: return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Clears all the data from the given table (truncates/drops it).
                 */
                EntityManager.prototype.clear = function (entityClass) {
                    return this.getRepository(entityClass).clear();
                };
                return EntityManager;
            }(BaseEntityManager_1.BaseEntityManager));
            exports_73("EntityManager", EntityManager);
        }
    };
});
System.register("typeorm/util/PromiseUtils", [], function (exports_74, context_74) {
    "use strict";
    var __moduleName = context_74 && context_74.id;
    var PromiseUtils;
    return {
        setters: [],
        execute: function () {
            /**
             * Utils to help to work with Promise objects.
             */
            PromiseUtils = (function () {
                function PromiseUtils() {
                }
                /**
                 * Runs given callback that returns promise for each item in the given collection in order.
                 * Operations executed after each other, right after previous promise being resolved.
                 */
                PromiseUtils.runInSequence = function (collection, callback) {
                    var results = [];
                    return collection.reduce(function (promise, item) {
                        return promise.then(function () {
                            return callback(item);
                        }).then(function (result) {
                            results.push(result);
                        });
                    }, Promise.resolve()).then(function () {
                        return results;
                    });
                };
                return PromiseUtils;
            }());
            exports_74("PromiseUtils", PromiseUtils);
        }
    };
});
System.register("typeorm/persistence/SubjectOperationExecutor", ["typeorm/util/OrmUtils", "typeorm/util/PromiseUtils"], function (exports_75, context_75) {
    "use strict";
    var __moduleName = context_75 && context_75.id;
    var OrmUtils_2, PromiseUtils_1, SubjectOperationExecutor;
    return {
        setters: [
            function (OrmUtils_2_1) {
                OrmUtils_2 = OrmUtils_2_1;
            },
            function (PromiseUtils_1_1) {
                PromiseUtils_1 = PromiseUtils_1_1;
            }
        ],
        execute: function () {
            /**
             * Executes all database operations (inserts, updated, deletes) that must be executed
             * with given persistence subjects.
             */
            SubjectOperationExecutor = (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function SubjectOperationExecutor(connection, transactionEntityManager, queryRunnerProvider) {
                    this.connection = connection;
                    this.transactionEntityManager = transactionEntityManager;
                    this.queryRunnerProvider = queryRunnerProvider;
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Executes all operations over given array of subjects.
                 * Executes queries using given query runner.
                 */
                SubjectOperationExecutor.prototype.execute = function (subjects) {
                    return __awaiter(this, void 0, void 0, function () {
                        var isTransactionStartedByItself, _a, error_2, secondaryError_1;
                        return __generator(this, function (_b) {
                            switch (_b.label) {
                                case 0:
                                    /*subjects.forEach(subject => {
                                        console.log(subject.entity);
                                        console.log("mustBeInserted: ", subject.mustBeInserted);
                                        console.log("mustBeUpdated: ", subject.mustBeUpdated);
                                        console.log("mustBeRemoved: ", subject.mustBeRemoved);
                                    });*/
                                    // validate all subjects first
                                    subjects.forEach(function (subject) { return subject.validate(); });
                                    // set class properties for easy use
                                    this.allSubjects = subjects;
                                    this.insertSubjects = subjects.filter(function (subject) { return subject.mustBeInserted; });
                                    this.updateSubjects = subjects.filter(function (subject) { return subject.mustBeUpdated; });
                                    this.removeSubjects = subjects.filter(function (subject) { return subject.mustBeRemoved; });
                                    this.relationUpdateSubjects = subjects.filter(function (subject) { return subject.hasRelationUpdates; });
                                    // if there are no operations to execute then don't need to do something including opening a transaction
                                    if (!this.insertSubjects.length &&
                                        !this.updateSubjects.length &&
                                        !this.removeSubjects.length &&
                                        !this.relationUpdateSubjects.length &&
                                        subjects.every(function (subject) { return !subject.junctionInserts.length; }) &&
                                        subjects.every(function (subject) { return !subject.junctionRemoves.length; }))
                                        return [2 /*return*/];
                                    isTransactionStartedByItself = false;
                                    _b.label = 1;
                                case 1:
                                    _b.trys.push([1, 17, , 22]);
                                    _a = this;
                                    return [4 /*yield*/, this.queryRunnerProvider.provide()];
                                case 2:
                                    _a.queryRunner = _b.sent();
                                    if (!!this.queryRunner.isTransactionActive()) return [3 /*break*/, 4];
                                    isTransactionStartedByItself = true;
                                    return [4 /*yield*/, this.queryRunner.beginTransaction()];
                                case 3:
                                    _b.sent();
                                    _b.label = 4;
                                case 4: 
                                // broadcast "before" events before we start updating
                                return [4 /*yield*/, this.connection.broadcaster.broadcastBeforeEventsForAll(this.transactionEntityManager, this.insertSubjects, this.updateSubjects, this.removeSubjects)];
                                case 5:
                                    // broadcast "before" events before we start updating
                                    _b.sent();
                                    // since events can trigger some internal changes (for example update depend property) we need to perform some re-computations here
                                    this.updateSubjects.forEach(function (subject) { return subject.recompute(); });
                                    return [4 /*yield*/, this.executeInsertOperations()];
                                case 6:
                                    _b.sent();
                                    return [4 /*yield*/, this.executeInsertClosureTableOperations()];
                                case 7:
                                    _b.sent();
                                    return [4 /*yield*/, this.executeInsertJunctionsOperations()];
                                case 8:
                                    _b.sent();
                                    return [4 /*yield*/, this.executeRemoveJunctionsOperations()];
                                case 9:
                                    _b.sent();
                                    return [4 /*yield*/, this.executeUpdateOperations()];
                                case 10:
                                    _b.sent();
                                    return [4 /*yield*/, this.executeUpdateRelations()];
                                case 11:
                                    _b.sent();
                                    return [4 /*yield*/, this.executeRemoveOperations()];
                                case 12:
                                    _b.sent();
                                    if (!(isTransactionStartedByItself === true)) return [3 /*break*/, 14];
                                    return [4 /*yield*/, this.queryRunner.commitTransaction()];
                                case 13:
                                    _b.sent();
                                    _b.label = 14;
                                case 14: 
                                // update all special columns in persisted entities, like inserted id or remove ids from the removed entities
                                return [4 /*yield*/, this.updateSpecialColumnsInPersistedEntities()];
                                case 15:
                                    // update all special columns in persisted entities, like inserted id or remove ids from the removed entities
                                    _b.sent();
                                    // finally broadcast "after" events
                                    // note that we are broadcasting events after commit because we want to have ids of the entities inside them to be available in subscribers
                                    return [4 /*yield*/, this.connection.broadcaster.broadcastAfterEventsForAll(this.transactionEntityManager, this.insertSubjects, this.updateSubjects, this.removeSubjects)];
                                case 16:
                                    // finally broadcast "after" events
                                    // note that we are broadcasting events after commit because we want to have ids of the entities inside them to be available in subscribers
                                    _b.sent();
                                    return [3 /*break*/, 22];
                                case 17:
                                    error_2 = _b.sent();
                                    if (!isTransactionStartedByItself) return [3 /*break*/, 21];
                                    _b.label = 18;
                                case 18:
                                    _b.trys.push([18, 20, , 21]);
                                    return [4 /*yield*/, this.queryRunner.rollbackTransaction()];
                                case 19:
                                    _b.sent();
                                    return [3 /*break*/, 21];
                                case 20:
                                    secondaryError_1 = _b.sent();
                                    return [3 /*break*/, 21];
                                case 21: throw error_2;
                                case 22: return [2 /*return*/];
                            }
                        });
                    });
                };
                // -------------------------------------------------------------------------
                // Private Methods: Insertion
                // -------------------------------------------------------------------------
                /**
                 * Executes insert operations.
                 *
                 * For insertion we separate two groups of entities:
                 * - first group of entities are entities which do not have any relations
                 *      or entities which do not have any non-nullable relation
                 * - second group of entities are entities which does have non-nullable relations
                 *
                 * Insert process of the entities from the first group which can only have nullable relations are actually a two-step process:
                 * - first we insert entities without their relations, explicitly left them NULL
                 * - later we update inserted entity once again with id of the object inserted with it
                 *
                 * Yes, two queries are being executed, but this is by design.
                 * There is no better way to solve this problem and others at the same time.
                 *
                 * Insert process of the entities from the second group which can have only non nullable relations is a single-step process:
                 * - we simply insert all entities and get into attention all its dependencies which were inserted in the first group
                 */
                SubjectOperationExecutor.prototype.executeInsertOperations = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var firstInsertSubjects, secondInsertSubjects, updatePromises;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    firstInsertSubjects = this.insertSubjects.filter(function (subject) { return !subject.metadata.hasNonNullableColumns; });
                                    secondInsertSubjects = this.insertSubjects.filter(function (subject) { return subject.metadata.hasNonNullableColumns; });
                                    // note: these operations should be executed in sequence, not in parallel
                                    // because second group depend of obtained data from the first group
                                    return [4 /*yield*/, Promise.all(firstInsertSubjects.map(function (subject) { return _this.insert(subject, []); }))];
                                case 1:
                                    // note: these operations should be executed in sequence, not in parallel
                                    // because second group depend of obtained data from the first group
                                    _a.sent();
                                    return [4 /*yield*/, Promise.all(secondInsertSubjects.map(function (subject) { return _this.insert(subject, firstInsertSubjects); }))];
                                case 2:
                                    _a.sent();
                                    updatePromises = [];
                                    firstInsertSubjects.forEach(function (subject) {
                                        // first update relations with join columns (one-to-one owner and many-to-one relations)
                                        var updateOptions = {};
                                        subject.metadata.relationsWithJoinColumns.forEach(function (relation) {
                                            var referencedColumn = relation.joinColumn.referencedColumn;
                                            var relatedEntity = relation.getEntityValue(subject.entity);
                                            // if relation value is not set then nothing to do here
                                            if (!relatedEntity)
                                                return;
                                            // check if relation reference column is a relation
                                            var relationId;
                                            var columnRelation = relation.inverseEntityMetadata.relations.find(function (rel) { return rel.propertyName === relation.joinColumn.referencedColumn.propertyName; });
                                            if (columnRelation) {
                                                var insertSubject = _this.insertSubjects.find(function (insertedSubject) { return insertedSubject.entity === relatedEntity[referencedColumn.propertyName]; });
                                                // if this relation was just inserted
                                                if (insertSubject) {
                                                    // check if we have this relation id already
                                                    relationId = relatedEntity[referencedColumn.propertyName][columnRelation.propertyName];
                                                    if (!relationId) {
                                                        // if we don't have relation id then use special values
                                                        if (referencedColumn.isGenerated) {
                                                            relationId = insertSubject.newlyGeneratedId;
                                                        }
                                                        // todo: handle other special types too
                                                    }
                                                }
                                            }
                                            else {
                                                var insertSubject = _this.insertSubjects.find(function (insertedSubject) { return insertedSubject.entity === relatedEntity; });
                                                // if this relation was just inserted
                                                if (insertSubject) {
                                                    // check if we have this relation id already
                                                    relationId = relatedEntity[referencedColumn.propertyName];
                                                    if (!relationId) {
                                                        // if we don't have relation id then use special values
                                                        if (referencedColumn.isGenerated) {
                                                            relationId = insertSubject.newlyGeneratedId;
                                                        }
                                                        // todo: handle other special types too
                                                    }
                                                }
                                            }
                                            if (relationId) {
                                                updateOptions[relation.name] = relationId;
                                            }
                                        });
                                        // if we found relations which we can update - then update them
                                        if (Object.keys(updateOptions).length > 0 /*&& subject.hasEntity*/) {
                                            // const relatedEntityIdMap = subject.getPersistedEntityIdMap; // todo: this works incorrectly
                                            var columns = subject.metadata.parentEntityMetadata ? subject.metadata.primaryColumnsWithParentIdColumns : subject.metadata.primaryColumns;
                                            var conditions_1 = {};
                                            columns.forEach(function (column) {
                                                var entityValue = subject.entity[column.propertyName];
                                                // if entity id is a relation, then extract referenced column from that relation
                                                var columnRelation = subject.metadata.relations.find(function (relation) { return relation.propertyName === column.propertyName; });
                                                if (entityValue && columnRelation && columnRelation.joinColumn) {
                                                    var relationIdOfEntityValue = entityValue[columnRelation.joinColumn.referencedColumn.propertyName];
                                                    if (!relationIdOfEntityValue) {
                                                        var entityValueInsertSubject = _this.insertSubjects.find(function (subject) { return subject.entity === entityValue; });
                                                        if (entityValueInsertSubject && columnRelation.joinColumn.referencedColumn.isGenerated) {
                                                            relationIdOfEntityValue = entityValueInsertSubject.newlyGeneratedId;
                                                        }
                                                    }
                                                    if (relationIdOfEntityValue) {
                                                        conditions_1[column.name] = relationIdOfEntityValue;
                                                    }
                                                }
                                                else {
                                                    if (entityValue) {
                                                        conditions_1[column.name] = entityValue;
                                                    }
                                                    else {
                                                        if (subject.newlyGeneratedId) {
                                                            conditions_1[column.name] = subject.newlyGeneratedId;
                                                        }
                                                    }
                                                }
                                            });
                                            if (!Object.keys(conditions_1).length)
                                                return;
                                            var updatePromise = _this.queryRunner.update(subject.metadata.table.name, updateOptions, conditions_1);
                                            updatePromises.push(updatePromise);
                                        }
                                        // we need to update relation ids if newly inserted objects are used from inverse side in one-to-many inverse relation
                                        // we also need to update relation ids if newly inserted objects are used from inverse side in one-to-one inverse relation
                                        var oneToManyAndOneToOneNonOwnerRelations = subject.metadata.oneToManyRelations.concat(subject.metadata.oneToOneRelations.filter(function (relation) { return !relation.isOwning; }));
                                        subject.metadata.extractRelationValuesFromEntity(subject.entity, oneToManyAndOneToOneNonOwnerRelations)
                                            .forEach(function (_a) {
                                            var relation = _a[0], subRelatedEntity = _a[1], inverseEntityMetadata = _a[2];
                                            var referencedColumn = relation.inverseRelation.joinColumn.referencedColumn;
                                            var columns = inverseEntityMetadata.parentEntityMetadata ? inverseEntityMetadata.primaryColumnsWithParentIdColumns : inverseEntityMetadata.primaryColumns;
                                            var conditions = {};
                                            columns.forEach(function (column) {
                                                var entityValue = subRelatedEntity[column.propertyName];
                                                // if entity id is a relation, then extract referenced column from that relation
                                                var columnRelation = inverseEntityMetadata.relations.find(function (relation) { return relation.propertyName === column.propertyName; });
                                                if (entityValue && columnRelation && columnRelation.joinColumn) {
                                                    var relationIdOfEntityValue = entityValue[columnRelation.joinColumn.referencedColumn.propertyName];
                                                    if (!relationIdOfEntityValue) {
                                                        var entityValueInsertSubject = _this.insertSubjects.find(function (subject) { return subject.entity === entityValue; });
                                                        if (entityValueInsertSubject && columnRelation.joinColumn.referencedColumn.isGenerated) {
                                                            relationIdOfEntityValue = entityValueInsertSubject.newlyGeneratedId;
                                                        }
                                                    }
                                                    if (relationIdOfEntityValue) {
                                                        conditions[column.name] = relationIdOfEntityValue;
                                                    }
                                                }
                                                else {
                                                    var entityValueInsertSubject = _this.insertSubjects.find(function (subject) { return subject.entity === subRelatedEntity; });
                                                    if (entityValue) {
                                                        conditions[column.name] = entityValue;
                                                    }
                                                    else {
                                                        if (entityValueInsertSubject && entityValueInsertSubject.newlyGeneratedId) {
                                                            conditions[column.name] = entityValueInsertSubject.newlyGeneratedId;
                                                        }
                                                    }
                                                }
                                            });
                                            if (!Object.keys(conditions).length)
                                                return;
                                            var updateOptions = {};
                                            var columnRelation = relation.inverseEntityMetadata.relations.find(function (rel) { return rel.propertyName === referencedColumn.propertyName; });
                                            if (columnRelation) {
                                                var id = subject.entity[referencedColumn.propertyName][columnRelation.propertyName];
                                                if (!id) {
                                                    var insertSubject = _this.insertSubjects.find(function (subject) { return subject.entity === subject.entity[referencedColumn.propertyName]; });
                                                    if (insertSubject) {
                                                        id = insertSubject.newlyGeneratedId;
                                                    }
                                                }
                                                updateOptions[relation.inverseRelation.joinColumn.name] = id;
                                            }
                                            else {
                                                updateOptions[relation.inverseRelation.joinColumn.name] = subject.entity[referencedColumn.propertyName] || subject.newlyGeneratedId;
                                            }
                                            var updatePromise = _this.queryRunner.update(relation.inverseEntityMetadata.table.name, updateOptions, conditions);
                                            updatePromises.push(updatePromise);
                                        });
                                    });
                                    return [4 /*yield*/, Promise.all(updatePromises)];
                                case 3:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Inserts an entity from the given insert operation into the database.
                 * If entity has an generated column, then after saving new generated value will be stored to the InsertOperation.
                 * If entity uses class-table-inheritance, then multiple inserts may by performed to save all entities.
                 */
                SubjectOperationExecutor.prototype.insert = function (subject, alreadyInsertedSubjects) {
                    return __awaiter(this, void 0, void 0, function () {
                        var parentEntityMetadata, metadata, entity, newlyGeneratedId, parentGeneratedId, parentValuesMap, childValuesMap, secondGeneratedId, valuesMap;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    parentEntityMetadata = subject.metadata.parentEntityMetadata;
                                    metadata = subject.metadata;
                                    entity = subject.entity;
                                    if (!metadata.table.isClassTableChild) return [3 /*break*/, 3];
                                    parentValuesMap = this.collectColumnsAndValues(parentEntityMetadata, entity, subject.date, undefined, metadata.discriminatorValue, alreadyInsertedSubjects);
                                    return [4 /*yield*/, this.queryRunner.insert(parentEntityMetadata.table.name, parentValuesMap, parentEntityMetadata.generatedColumnIfExist)];
                                case 1:
                                    newlyGeneratedId = parentGeneratedId = _a.sent();
                                    childValuesMap = this.collectColumnsAndValues(metadata, entity, subject.date, newlyGeneratedId, undefined, alreadyInsertedSubjects);
                                    return [4 /*yield*/, this.queryRunner.insert(metadata.table.name, childValuesMap, metadata.generatedColumnIfExist)];
                                case 2:
                                    secondGeneratedId = _a.sent();
                                    if (!newlyGeneratedId && secondGeneratedId)
                                        newlyGeneratedId = secondGeneratedId;
                                    return [3 /*break*/, 5];
                                case 3:
                                    valuesMap = this.collectColumnsAndValues(metadata, entity, subject.date, undefined, undefined, alreadyInsertedSubjects);
                                    return [4 /*yield*/, this.queryRunner.insert(metadata.table.name, valuesMap, metadata.generatedColumnIfExist)];
                                case 4:
                                    newlyGeneratedId = _a.sent();
                                    _a.label = 5;
                                case 5:
                                    if (parentGeneratedId)
                                        subject.parentGeneratedId = parentGeneratedId;
                                    if (newlyGeneratedId && metadata.hasGeneratedColumn)
                                        subject.newlyGeneratedId = newlyGeneratedId;
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Collects columns and values for the insert operation.
                 */
                SubjectOperationExecutor.prototype.collectColumnsAndValues = function (metadata, entity, date, parentIdColumnValue, discriminatorValue, alreadyInsertedSubjects) {
                    var _this = this;
                    // extract all columns
                    var columns = metadata.columns.filter(function (column) {
                        return !column.isVirtual && !column.isParentId && !column.isDiscriminator && column.hasEntityValue(entity);
                    });
                    var relationColumns = [];
                    var relationValues = [];
                    metadata.relationsWithJoinColumns.forEach(function (relation) {
                        var relationValue;
                        var value = relation.getEntityValue(entity);
                        if (value) {
                            // if relation value is stored in the entity itself then use it from there
                            var relationId = relation.getInverseEntityRelationId(value); // todo: check it
                            if (relationId) {
                                relationValue = relationId;
                            }
                            // otherwise try to find relational value from just inserted subjects
                            var alreadyInsertedSubject = alreadyInsertedSubjects.find(function (insertedSubject) {
                                return insertedSubject.entity === value;
                            });
                            if (alreadyInsertedSubject) {
                                var referencedColumn = relation.joinColumn.referencedColumn;
                                // if join column references to the primary generated column then seek in the newEntityId of the insertedSubject
                                if (referencedColumn.referencedColumn && referencedColumn.referencedColumn.isGenerated) {
                                    if (referencedColumn.isParentId) {
                                        relationValue = alreadyInsertedSubject.parentGeneratedId;
                                    }
                                    // todo: what if reference column is not generated?
                                    // todo: what if reference column is not related to table inheritance?
                                }
                                if (referencedColumn.isGenerated)
                                    relationValue = alreadyInsertedSubject.newlyGeneratedId;
                                // if it references to create or update date columns
                                if (referencedColumn.isCreateDate || referencedColumn.isUpdateDate)
                                    relationValue = _this.connection.driver.preparePersistentValue(alreadyInsertedSubject.date, referencedColumn);
                                // if it references to version column
                                if (referencedColumn.isVersion)
                                    relationValue = _this.connection.driver.preparePersistentValue(1, referencedColumn);
                            }
                        }
                        else if (relation.hasInverseSide) {
                            var inverseSubject = _this.allSubjects.find(function (subject) {
                                if (!subject.hasEntity || subject.entityTarget !== relation.inverseRelation.target)
                                    return false;
                                var inverseRelationValue = subject.entity[relation.inverseRelation.propertyName];
                                if (inverseRelationValue) {
                                    if (inverseRelationValue instanceof Array) {
                                        return inverseRelationValue.find(function (subValue) { return subValue === subValue; });
                                    }
                                    else {
                                        return inverseRelationValue === entity;
                                    }
                                }
                            });
                            if (inverseSubject && inverseSubject.entity[relation.joinColumn.referencedColumn.propertyName]) {
                                relationValue = inverseSubject.entity[relation.joinColumn.referencedColumn.propertyName];
                            }
                        }
                        if (relationValue) {
                            relationColumns.push(relation);
                            relationValues.push(relationValue);
                        }
                    });
                    var columnNames = columns.map(function (column) { return column.name; });
                    var relationColumnNames = relationColumns.map(function (relation) { return relation.name; });
                    var allColumnNames = columnNames.concat(relationColumnNames);
                    var columnValues = columns.map(function (column) {
                        return _this.connection.driver.preparePersistentValue(column.getEntityValue(entity), column);
                    });
                    var allValues = columnValues.concat(relationValues);
                    // add special column and value - date of creation
                    if (metadata.hasCreateDateColumn) {
                        allColumnNames.push(metadata.createDateColumn.name);
                        allValues.push(this.connection.driver.preparePersistentValue(date, metadata.createDateColumn));
                    }
                    // add special column and value - date of updating
                    if (metadata.hasUpdateDateColumn) {
                        allColumnNames.push(metadata.updateDateColumn.name);
                        allValues.push(this.connection.driver.preparePersistentValue(date, metadata.updateDateColumn));
                    }
                    // add special column and value - version column
                    if (metadata.hasVersionColumn) {
                        allColumnNames.push(metadata.versionColumn.name);
                        allValues.push(this.connection.driver.preparePersistentValue(1, metadata.versionColumn));
                    }
                    // add special column and value - discriminator value (for tables using table inheritance)
                    if (metadata.hasDiscriminatorColumn) {
                        allColumnNames.push(metadata.discriminatorColumn.name);
                        allValues.push(this.connection.driver.preparePersistentValue(discriminatorValue || metadata.discriminatorValue, metadata.discriminatorColumn));
                    }
                    // add special column and value - tree level and tree parents (for tree-type tables)
                    if (metadata.hasTreeLevelColumn && metadata.hasTreeParentRelation) {
                        var parentEntity = entity[metadata.treeParentRelation.propertyName];
                        var parentLevel = parentEntity ? (parentEntity[metadata.treeLevelColumn.propertyName] || 0) : 0;
                        allColumnNames.push(metadata.treeLevelColumn.name);
                        allValues.push(parentLevel + 1);
                    }
                    // add special column and value - parent id column (for tables using table inheritance)
                    if (metadata.parentEntityMetadata && metadata.hasParentIdColumn) {
                        allColumnNames.push(metadata.parentIdColumn.name); // todo: should be array of primary keys
                        allValues.push(parentIdColumnValue || entity[metadata.parentEntityMetadata.firstPrimaryColumn.propertyName]); // todo: should be array of primary keys
                    }
                    return OrmUtils_2.OrmUtils.zipObject(allColumnNames, allValues);
                };
                // -------------------------------------------------------------------------
                // Private Methods: Insertion into closure tables
                // -------------------------------------------------------------------------
                /**
                 * Inserts all given subjects into closure table.
                 */
                SubjectOperationExecutor.prototype.executeInsertClosureTableOperations = function () {
                    var _this = this;
                    var promises = this.insertSubjects
                        .filter(function (subject) { return subject.metadata.table.isClosure; })
                        .map(function (subject) { return __awaiter(_this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: 
                                // const relationsUpdateMap = this.findUpdateOperationForEntity(updatesByRelations, insertSubjects, subject.entity);
                                // subject.treeLevel = await this.insertIntoClosureTable(subject, relationsUpdateMap);
                                return [4 /*yield*/, this.insertClosureTableValues(subject)];
                                case 1:
                                    // const relationsUpdateMap = this.findUpdateOperationForEntity(updatesByRelations, insertSubjects, subject.entity);
                                    // subject.treeLevel = await this.insertIntoClosureTable(subject, relationsUpdateMap);
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    }); });
                    return Promise.all(promises);
                };
                /**
                 * Inserts given subject into closure table.
                 */
                SubjectOperationExecutor.prototype.insertClosureTableValues = function (subject) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableName, referencedColumn, newEntityId, parentEntity, parentEntityId, parentInsertedSubject, parentSubject, _a, values, _b, _c;
                        return __generator(this, function (_d) {
                            switch (_d.label) {
                                case 0:
                                    tableName = subject.metadata.closureJunctionTable.table.name;
                                    referencedColumn = subject.metadata.treeParentRelation.joinColumn.referencedColumn;
                                    newEntityId = subject.entity[referencedColumn.propertyName];
                                    if (!newEntityId && referencedColumn.isGenerated) {
                                        newEntityId = subject.newlyGeneratedId;
                                    } // todo: implement other special column types too
                                    parentEntity = subject.entity[subject.metadata.treeParentRelation.propertyName];
                                    parentEntityId = 0;
                                    if (parentEntity) {
                                        parentEntityId = parentEntity[referencedColumn.propertyName];
                                        if (!parentEntityId && referencedColumn.isGenerated) {
                                            parentInsertedSubject = this.insertSubjects.find(function (subject) { return subject.entity === parentEntity; });
                                            // todo: throw exception if parentInsertedSubject is not set
                                            parentEntityId = parentInsertedSubject.newlyGeneratedId;
                                        } // todo: implement other special column types too
                                    }
                                    // try to find parent entity id in some other entity that has this entity in its children
                                    if (!parentEntityId) {
                                        parentSubject = this.allSubjects.find(function (allSubject) {
                                            if (!allSubject.hasEntity || !allSubject.metadata.table.isClosure || !allSubject.metadata.hasTreeChildrenRelation)
                                                return false;
                                            var children = allSubject.entity[subject.metadata.treeChildrenRelation.propertyName];
                                            return children instanceof Array ? children.indexOf(subject.entity) !== -1 : false;
                                        });
                                        if (parentSubject) {
                                            parentEntityId = parentSubject.entity[referencedColumn.propertyName];
                                            if (!parentEntityId && parentSubject.newlyGeneratedId) {
                                                parentEntityId = parentSubject.newlyGeneratedId;
                                            }
                                        }
                                    }
                                    // if parent entity exist then insert a new row into closure table
                                    _a = subject;
                                    return [4 /*yield*/, this.queryRunner.insertIntoClosureTable(tableName, newEntityId, parentEntityId, subject.metadata.hasTreeLevelColumn)];
                                case 1:
                                    // if parent entity exist then insert a new row into closure table
                                    _a.treeLevel = _d.sent();
                                    if (!subject.metadata.hasTreeLevelColumn) return [3 /*break*/, 3];
                                    values = (_b = {}, _b[subject.metadata.treeLevelColumn.name] = subject.treeLevel, _b);
                                    return [4 /*yield*/, this.queryRunner.update(subject.metadata.table.name, values, (_c = {}, _c[referencedColumn.name] = newEntityId, _c))];
                                case 2:
                                    _d.sent();
                                    _d.label = 3;
                                case 3: return [2 /*return*/];
                            }
                        });
                    });
                };
                // -------------------------------------------------------------------------
                // Private Methods: Update
                // -------------------------------------------------------------------------
                /**
                 * Updates all given subjects in the database.
                 */
                SubjectOperationExecutor.prototype.executeUpdateOperations = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, Promise.all(this.updateSubjects.map(function (subject) { return _this.update(subject); }))];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Updates given subject in the database.
                 */
                SubjectOperationExecutor.prototype.update = function (subject) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var entity, valueMaps, valueMap, valueMap, valueMap, valueMap;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    entity = subject.entity;
                                    valueMaps = [];
                                    subject.diffColumns.forEach(function (column) {
                                        if (!column.entityTarget)
                                            return; // todo: how this can be possible?
                                        var metadata = _this.connection.getMetadata(column.entityTarget);
                                        var valueMap = valueMaps.find(function (valueMap) { return valueMap.tableName === metadata.table.name; });
                                        if (!valueMap) {
                                            valueMap = { tableName: metadata.table.name, metadata: metadata, values: {} };
                                            valueMaps.push(valueMap);
                                        }
                                        valueMap.values[column.name] = _this.connection.driver.preparePersistentValue(column.getEntityValue(entity), column);
                                    });
                                    subject.diffRelations.forEach(function (relation) {
                                        var metadata = _this.connection.getMetadata(relation.entityTarget);
                                        var valueMap = valueMaps.find(function (valueMap) { return valueMap.tableName === metadata.table.name; });
                                        if (!valueMap) {
                                            valueMap = { tableName: metadata.table.name, metadata: metadata, values: {} };
                                            valueMaps.push(valueMap);
                                        }
                                        var value = relation.getEntityValue(entity);
                                        valueMap.values[relation.name] = value !== null && value !== undefined ? value[relation.inverseEntityMetadata.firstPrimaryColumn.propertyName] : null; // todo: should not have a call to primaryColumn, instead join column metadata should be used
                                    });
                                    // if number of updated columns = 0 no need to update updated date and version columns
                                    if (Object.keys(valueMaps).length === 0)
                                        return [2 /*return*/];
                                    if (subject.metadata.hasUpdateDateColumn) {
                                        valueMap = valueMaps.find(function (valueMap) { return valueMap.tableName === subject.metadata.table.name; });
                                        if (!valueMap) {
                                            valueMap = { tableName: subject.metadata.table.name, metadata: subject.metadata, values: {} };
                                            valueMaps.push(valueMap);
                                        }
                                        valueMap.values[subject.metadata.updateDateColumn.name] = this.connection.driver.preparePersistentValue(new Date(), subject.metadata.updateDateColumn);
                                    }
                                    if (subject.metadata.hasVersionColumn) {
                                        valueMap = valueMaps.find(function (valueMap) { return valueMap.tableName === subject.metadata.table.name; });
                                        if (!valueMap) {
                                            valueMap = { tableName: subject.metadata.table.name, metadata: subject.metadata, values: {} };
                                            valueMaps.push(valueMap);
                                        }
                                        valueMap.values[subject.metadata.versionColumn.name] = this.connection.driver.preparePersistentValue(entity[subject.metadata.versionColumn.propertyName] + 1, subject.metadata.versionColumn);
                                    }
                                    if (subject.metadata.parentEntityMetadata) {
                                        if (subject.metadata.parentEntityMetadata.hasUpdateDateColumn) {
                                            valueMap = valueMaps.find(function (valueMap) { return valueMap.tableName === subject.metadata.parentEntityMetadata.table.name; });
                                            if (!valueMap) {
                                                valueMap = {
                                                    tableName: subject.metadata.parentEntityMetadata.table.name,
                                                    metadata: subject.metadata.parentEntityMetadata,
                                                    values: {}
                                                };
                                                valueMaps.push(valueMap);
                                            }
                                            valueMap.values[subject.metadata.parentEntityMetadata.updateDateColumn.name] = this.connection.driver.preparePersistentValue(new Date(), subject.metadata.parentEntityMetadata.updateDateColumn);
                                        }
                                        if (subject.metadata.parentEntityMetadata.hasVersionColumn) {
                                            valueMap = valueMaps.find(function (valueMap) { return valueMap.tableName === subject.metadata.parentEntityMetadata.table.name; });
                                            if (!valueMap) {
                                                valueMap = {
                                                    tableName: subject.metadata.parentEntityMetadata.table.name,
                                                    metadata: subject.metadata.parentEntityMetadata,
                                                    values: {}
                                                };
                                                valueMaps.push(valueMap);
                                            }
                                            valueMap.values[subject.metadata.parentEntityMetadata.versionColumn.name] = this.connection.driver.preparePersistentValue(entity[subject.metadata.parentEntityMetadata.versionColumn.propertyName] + 1, subject.metadata.parentEntityMetadata.versionColumn);
                                        }
                                    }
                                    return [4 /*yield*/, Promise.all(valueMaps.map(function (valueMap) {
                                            var idMap = valueMap.metadata.getDatabaseEntityIdMap(entity);
                                            if (!idMap)
                                                throw new Error("Internal error. Cannot get id of the updating entity.");
                                            return _this.queryRunner.update(valueMap.tableName, valueMap.values, idMap);
                                        }))];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                // -------------------------------------------------------------------------
                // Private Methods: Update only relations
                // -------------------------------------------------------------------------
                /**
                 * Updates relations of all given subjects in the database.
                 */
                SubjectOperationExecutor.prototype.executeUpdateRelations = function () {
                    var _this = this;
                    return Promise.all(this.relationUpdateSubjects.map(function (subject) { return _this.updateRelations(subject); }));
                };
                /**
                 * Updates relations of the given subject in the database.
                 */
                SubjectOperationExecutor.prototype.updateRelations = function (subject) {
                    return __awaiter(this, void 0, void 0, function () {
                        var values, idMap;
                        return __generator(this, function (_a) {
                            values = {};
                            subject.relationUpdates.forEach(function (setRelation) {
                                var value = setRelation.value ? setRelation.value[setRelation.relation.joinColumn.referencedColumn.propertyName] : null;
                                values[setRelation.relation.name] = value; // todo: || fromInsertedSubjects ??
                            });
                            idMap = subject.metadata.getDatabaseEntityIdMap(subject.databaseEntity);
                            if (!idMap)
                                throw new Error("Internal error. Cannot get id of the updating entity.");
                            return [2 /*return*/, this.queryRunner.update(subject.metadata.table.name, values, idMap)];
                        });
                    });
                };
                // -------------------------------------------------------------------------
                // Private Methods: Remove
                // -------------------------------------------------------------------------
                /**
                 * Removes all given subjects from the database.
                 */
                SubjectOperationExecutor.prototype.executeRemoveOperations = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, PromiseUtils_1.PromiseUtils.runInSequence(this.removeSubjects, function (subject) { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {
                                        switch (_a.label) {
                                            case 0: return [4 /*yield*/, this.remove(subject)];
                                            case 1: return [2 /*return*/, _a.sent()];
                                        }
                                    }); }); })];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Updates given subject from the database.
                 */
                SubjectOperationExecutor.prototype.remove = function (subject) {
                    return __awaiter(this, void 0, void 0, function () {
                        var parentConditions_1, childConditions_1;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!subject.metadata.parentEntityMetadata) return [3 /*break*/, 3];
                                    parentConditions_1 = {};
                                    subject.metadata.parentPrimaryColumns.forEach(function (column) {
                                        parentConditions_1[column.name] = subject.databaseEntity[column.propertyName];
                                    });
                                    return [4 /*yield*/, this.queryRunner.delete(subject.metadata.parentEntityMetadata.table.name, parentConditions_1)];
                                case 1:
                                    _a.sent();
                                    childConditions_1 = {};
                                    subject.metadata.primaryColumnsWithParentIdColumns.forEach(function (column) {
                                        childConditions_1[column.name] = subject.databaseEntity[column.propertyName];
                                    });
                                    return [4 /*yield*/, this.queryRunner.delete(subject.metadata.table.name, childConditions_1)];
                                case 2:
                                    _a.sent();
                                    return [3 /*break*/, 5];
                                case 3: return [4 /*yield*/, this.queryRunner.delete(subject.metadata.table.name, subject.metadata.getEntityIdColumnMap(subject.databaseEntity))];
                                case 4:
                                    _a.sent();
                                    _a.label = 5;
                                case 5: return [2 /*return*/];
                            }
                        });
                    });
                };
                // -------------------------------------------------------------------------
                // Private Methods: Insertion into junction tables
                // -------------------------------------------------------------------------
                /**
                 * Inserts into database junction tables all given array of subjects junction data.
                 */
                SubjectOperationExecutor.prototype.executeInsertJunctionsOperations = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var promises;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    promises = [];
                                    this.allSubjects.forEach(function (subject) {
                                        subject.junctionInserts.forEach(function (junctionInsert) {
                                            promises.push(_this.insertJunctions(subject, junctionInsert));
                                        });
                                    });
                                    return [4 /*yield*/, Promise.all(promises)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Inserts into database junction table given subject's junction insert data.
                 */
                SubjectOperationExecutor.prototype.insertJunctions = function (subject, junctionInsert) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var relation, joinTable, firstColumn, secondColumn, ownId, promises;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    relation = junctionInsert.relation;
                                    joinTable = relation.isOwning ? relation.joinTable : relation.inverseRelation.joinTable;
                                    firstColumn = relation.isOwning ? joinTable.referencedColumn : joinTable.inverseReferencedColumn;
                                    secondColumn = relation.isOwning ? joinTable.inverseReferencedColumn : joinTable.referencedColumn;
                                    ownId = relation.getOwnEntityRelationId(subject.entity);
                                    if (!ownId) {
                                        if (firstColumn.isGenerated) {
                                            ownId = subject.newlyGeneratedId;
                                        }
                                        // todo: implement other special referenced column types (update date, create date, version, discriminator column, etc.)
                                    }
                                    if (!ownId)
                                        throw new Error("Cannot insert object of " + subject.entityTarget + " type. Looks like its not persisted yet, or cascades are not set on the relation."); // todo: better error message
                                    promises = junctionInsert.junctionEntities.map(function (newBindEntity) {
                                        // get relation id from the newly bind entity
                                        var relationId;
                                        if (relation.isManyToManyOwner) {
                                            relationId = newBindEntity[relation.joinTable.inverseReferencedColumn.propertyName];
                                        }
                                        else if (relation.isManyToManyNotOwner) {
                                            relationId = newBindEntity[relation.inverseRelation.joinTable.referencedColumn.propertyName];
                                        }
                                        // if relation id is missing in the newly bind entity then check maybe it was just persisted
                                        // and we can use special newly generated value
                                        if (!relationId) {
                                            var insertSubject = _this.insertSubjects.find(function (subject) { return subject.entity === newBindEntity; });
                                            if (insertSubject) {
                                                if (secondColumn.isGenerated) {
                                                    relationId = insertSubject.newlyGeneratedId;
                                                }
                                                // todo: implement other special values too
                                            }
                                        }
                                        // if relation id still does not exist - we arise an error
                                        if (!relationId)
                                            throw new Error("Cannot insert object of " + newBindEntity.constructor.name + " type. Looks like its not persisted yet, or cascades are not set on the relation."); // todo: better error message
                                        var columns = relation.junctionEntityMetadata.columns.map(function (column) { return column.name; });
                                        var values = relation.isOwning ? [ownId, relationId] : [relationId, ownId];
                                        return _this.queryRunner.insert(relation.junctionEntityMetadata.table.name, OrmUtils_2.OrmUtils.zipObject(columns, values));
                                    });
                                    return [4 /*yield*/, Promise.all(promises)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                // -------------------------------------------------------------------------
                // Private Methods: Remove from junction tables
                // -------------------------------------------------------------------------
                /**
                 * Removes from database junction tables all given array of subjects removal junction data.
                 */
                SubjectOperationExecutor.prototype.executeRemoveJunctionsOperations = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var promises;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    promises = [];
                                    this.allSubjects.forEach(function (subject) {
                                        subject.junctionRemoves.forEach(function (junctionRemove) {
                                            promises.push(_this.removeJunctions(subject, junctionRemove));
                                        });
                                    });
                                    return [4 /*yield*/, Promise.all(promises)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Removes from database junction table all given subject's removal junction data.
                 */
                SubjectOperationExecutor.prototype.removeJunctions = function (subject, junctionRemove) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var junctionMetadata, entity, ownId, ownColumn, relateColumn, removePromises;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    junctionMetadata = junctionRemove.relation.junctionEntityMetadata;
                                    entity = subject.hasEntity ? subject.entity : subject.databaseEntity;
                                    ownId = junctionRemove.relation.getOwnEntityRelationId(entity);
                                    ownColumn = junctionRemove.relation.isOwning ? junctionMetadata.columns[0] : junctionMetadata.columns[1];
                                    relateColumn = junctionRemove.relation.isOwning ? junctionMetadata.columns[1] : junctionMetadata.columns[0];
                                    removePromises = junctionRemove.junctionRelationIds.map(function (relationId) {
                                        return _this.queryRunner.delete(junctionMetadata.table.name, (_a = {},
                                            _a[ownColumn.name] = ownId,
                                            _a[relateColumn.name] = relationId,
                                            _a));
                                        var _a;
                                    });
                                    return [4 /*yield*/, Promise.all(removePromises)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                // -------------------------------------------------------------------------
                // Private Methods: Refresh entity values after persistence
                // -------------------------------------------------------------------------
                /**
                 * Updates all special columns of the saving entities (create date, update date, versioning).
                 */
                SubjectOperationExecutor.prototype.updateSpecialColumnsInPersistedEntities = function () {
                    // update entity columns that gets updated on each entity insert
                    this.insertSubjects.forEach(function (subject) {
                        subject.metadata.primaryColumns.forEach(function (primaryColumn) {
                            if (subject.newlyGeneratedId)
                                subject.entity[primaryColumn.propertyName] = subject.newlyGeneratedId;
                        });
                        subject.metadata.parentPrimaryColumns.forEach(function (primaryColumn) {
                            if (subject.parentGeneratedId)
                                subject.entity[primaryColumn.propertyName] = subject.parentGeneratedId;
                        });
                        if (subject.metadata.hasUpdateDateColumn)
                            subject.entity[subject.metadata.updateDateColumn.propertyName] = subject.date;
                        if (subject.metadata.hasCreateDateColumn)
                            subject.entity[subject.metadata.createDateColumn.propertyName] = subject.date;
                        if (subject.metadata.hasVersionColumn)
                            subject.entity[subject.metadata.versionColumn.propertyName]++;
                        if (subject.metadata.hasTreeLevelColumn) {
                            // const parentEntity = insertOperation.entity[metadata.treeParentMetadata.propertyName];
                            // const parentLevel = parentEntity ? (parentEntity[metadata.treeLevelColumn.propertyName] || 0) : 0;
                            subject.entity[subject.metadata.treeLevelColumn.propertyName] = subject.treeLevel;
                        }
                        /*if (subject.metadata.hasTreeChildrenCountColumn) {
                             subject.entity[subject.metadata.treeChildrenCountColumn.propertyName] = 0;
                        }*/
                    });
                    // update special columns that gets updated on each entity update
                    this.updateSubjects.forEach(function (subject) {
                        if (subject.metadata.hasUpdateDateColumn)
                            subject.entity[subject.metadata.updateDateColumn.propertyName] = subject.date;
                        if (subject.metadata.hasVersionColumn)
                            subject.entity[subject.metadata.versionColumn.propertyName]++;
                    });
                    // remove ids from the entities that were removed
                    this.removeSubjects
                        .filter(function (subject) { return subject.hasEntity; })
                        .forEach(function (subject) {
                        subject.metadata.primaryColumns.forEach(function (primaryColumn) {
                            subject.entity[primaryColumn.propertyName] = undefined;
                        });
                    });
                };
                return SubjectOperationExecutor;
            }());
            exports_75("SubjectOperationExecutor", SubjectOperationExecutor);
        }
    };
});
System.register("typeorm/persistence/SubjectBuilder", ["typeorm/persistence/Subject", "typeorm/repository/SpecificRepository"], function (exports_76, context_76) {
    "use strict";
    var __moduleName = context_76 && context_76.id;
    var Subject_2, SpecificRepository_2, SubjectBuilder;
    return {
        setters: [
            function (Subject_2_1) {
                Subject_2 = Subject_2_1;
            },
            function (SpecificRepository_2_1) {
                SpecificRepository_2 = SpecificRepository_2_1;
            }
        ],
        execute: function () {
            /**
             * To be able to execute persistence operations we need to load all entities from the database we need.
             * Loading should be efficient - we need to load entities in as few queries as possible + load as less data as we can.
             * This is how we determine which entities needs to be loaded from db:
             *
             * 1. example with cascade updates and inserts:
             *
             * [Y] - means "yes, we load"
             * [N] - means "no, we don't load"
             * in {} braces we specify what cascade options are set between relations
             *
             * if Post is new, author is not set in the post
             *
             * [Y] Post -> {all} // yes because of "update" and "insert" cascades, no because of "remove"
             *   [Y] Author -> {all} // no because author is not set
             *     [Y] Photo -> {all} // no because author and its photo are not set
             *       [Y] Tag -> {all} // no because author and its photo and its tag are not set
             *
             * if Post is new, author is new (or anything else is new)
             * if Post is updated
             * if Post and/or Author are updated
             *
             * [Y] Post -> {all} // yes because of "update" and "insert" cascades, no because of "remove"
             *   [Y] Author -> {all} // yes because of "update" and "insert" cascades, no because of "remove"
             *     [Y] Photo -> {all} // yes because of "update" and "insert" cascades, no because of "remove"
             *       [Y] Tag -> {all} // yes because of "update" and "insert" cascades, no because of "remove"
             *
             * Here we load post, author, photo, tag to check if they are new or not to persist insert or update operation.
             * We load post, author, photo, tag only if they exist in the relation.
             * From these examples we can see that we always load entity relations when it has "update" or "insert" cascades.
             *
             * 2. example with cascade removes
             *
             * if entity is new its remove operations by cascades should not be executed
             * if entity is updated then values that are null or missing in array (not undefined!, undefined means skip - don't do anything) are treated as removed
             * if entity is removed then all its downside relations which has cascade remove should be removed
             *
             * Once we find removed entity - we load it, and every downside entity which has "remove" cascade set.
             *
             * At the end we have all entities we need to operate with.
             * Next step is to store all loaded entities to manipulate them efficiently.
             *
             * Rules of updating by cascades.
             * Insert operation can lead to:
             *  - insert operations
             *  - update operations
             * Update operation can lead to:
             *  - insert operations
             *  - update operations
             *  - remove operations
             * Remove operation can lead to:
             *  - remove operation
             */
            SubjectBuilder = (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function SubjectBuilder(connection, queryRunnerProvider) {
                    this.connection = connection;
                    this.queryRunnerProvider = queryRunnerProvider;
                    // -------------------------------------------------------------------------
                    // Protected properties
                    // -------------------------------------------------------------------------
                    /**
                     * If this gonna be reused then what to do with marked flags?
                     * One of solution can be clone this object and reset all marked states for this persistence.
                     * Or from reused just extract databaseEntities from their subjects? (looks better)
                     */
                    this.operateSubjects = [];
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Builds operations for entity that is being inserted/updated.
                 */
                SubjectBuilder.prototype.persist = function (entity, metadata) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var mainPersistedSubject, operateSubjectsWithDatabaseEntities;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    mainPersistedSubject = new Subject_2.Subject(metadata, entity);
                                    mainPersistedSubject.canBeInserted = true;
                                    mainPersistedSubject.canBeUpdated = true;
                                    this.operateSubjects.push(mainPersistedSubject);
                                    // next step we build list of subjects we will operate with
                                    // these subjects are subjects that we need to insert or update alongside with main persisted entity
                                    this.buildCascadeUpdateAndInsertOperateSubjects(mainPersistedSubject);
                                    // next step is to load database entities of all operate subjects
                                    return [4 /*yield*/, this.loadOperateSubjectsDatabaseEntities()];
                                case 1:
                                    // next step is to load database entities of all operate subjects
                                    _a.sent();
                                    operateSubjectsWithDatabaseEntities = this.operateSubjects.filter(function (subject) { return subject.hasDatabaseEntity; });
                                    return [4 /*yield*/, Promise.all(operateSubjectsWithDatabaseEntities.map(function (subject) {
                                            return _this.buildCascadeRemovedAndRelationUpdateOperateSubjects(subject);
                                        }))];
                                case 2:
                                    _a.sent();
                                    // finally find which operate subjects have insert and remove operations in their junction tables
                                    return [4 /*yield*/, this.buildJunctionOperations({ insert: true, remove: true })];
                                case 3:
                                    // finally find which operate subjects have insert and remove operations in their junction tables
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Builds only remove operations for entity that is being removed.
                 */
                SubjectBuilder.prototype.remove = function (entity, metadata) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var mainRemovedSubject, operateSubjectsWithDatabaseEntities;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    mainRemovedSubject = new Subject_2.Subject(metadata, entity);
                                    mainRemovedSubject.mustBeRemoved = true;
                                    this.operateSubjects.push(mainRemovedSubject);
                                    // next step we build list of subjects we will operate with
                                    // these subjects are subjects that we need to remove alongside with main removed entity
                                    this.buildCascadeRemoveOperateSubjects(mainRemovedSubject);
                                    // next step is to load database entities for all operate subjects
                                    return [4 /*yield*/, this.loadOperateSubjectsDatabaseEntities()];
                                case 1:
                                    // next step is to load database entities for all operate subjects
                                    _a.sent();
                                    operateSubjectsWithDatabaseEntities = this.operateSubjects.filter(function (subject) { return subject.hasDatabaseEntity; });
                                    return [4 /*yield*/, Promise.all(operateSubjectsWithDatabaseEntities.map(function (subject) {
                                            return _this.buildCascadeRemovedAndRelationUpdateOperateSubjects(subject);
                                        }))];
                                case 2:
                                    _a.sent();
                                    // finally find which operate subjects have remove operations in their junction tables
                                    return [4 /*yield*/, this.buildJunctionOperations({ insert: false, remove: true })];
                                case 3:
                                    // finally find which operate subjects have remove operations in their junction tables
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                // -------------------------------------------------------------------------
                // Protected Methods
                // -------------------------------------------------------------------------
                /**
                 * Builds and pushes to array of operate entities all entities that we will work with.
                 * These are only relational entities which has insert and update cascades.
                 * All such entities will be loaded from the database, because they can be inserted or updated.
                 * That's why we load them - to understand if they should be inserted or updated, or which columns we need to update.
                 * We can't add removed entities here, because to know which entity was removed we need first to
                 * load original entity (particularly its id) from the database.
                 * That's why we first need to load all changed entities, then extract ids of the removed entities from them,
                 * and only then load removed entities by extracted ids.
                 */
                SubjectBuilder.prototype.buildCascadeUpdateAndInsertOperateSubjects = function (subject) {
                    var _this = this;
                    subject.metadata
                        .extractRelationValuesFromEntity(subject.entity, subject.metadata.relations)
                        .filter(function (_a) {
                        var relation = _a[0], value = _a[1], valueMetadata = _a[2];
                        // we need only defined values and insert or update cascades of the relation should be set
                        return value !== undefined && value !== null && (relation.isCascadeInsert || relation.isCascadeUpdate);
                    })
                        .forEach(function (_a) {
                        var relation = _a[0], value = _a[1], valueMetadata = _a[2];
                        // if we already has this entity in list of operated subjects then skip it to avoid recursion
                        var alreadyExistValueSubject = _this.findByEntityLike(valueMetadata.target, value);
                        if (alreadyExistValueSubject) {
                            if (alreadyExistValueSubject.canBeInserted === false)
                                alreadyExistValueSubject.canBeInserted = relation.isCascadeInsert === true;
                            if (alreadyExistValueSubject.canBeUpdated === false)
                                alreadyExistValueSubject.canBeUpdated = relation.isCascadeUpdate === true;
                            return;
                        }
                        // mark subject with what we can do with it
                        // and add to the array of subjects to load only if there is no same entity there already
                        var valueSubject = new Subject_2.Subject(valueMetadata, value);
                        valueSubject.canBeInserted = relation.isCascadeInsert === true;
                        valueSubject.canBeUpdated = relation.isCascadeUpdate === true;
                        _this.operateSubjects.push(valueSubject);
                        // go recursively and find other entities we need to operate with
                        _this.buildCascadeUpdateAndInsertOperateSubjects(valueSubject);
                    });
                };
                /**
                 * Builds and pushes to array of operate entities all entities that must be removed.
                 */
                SubjectBuilder.prototype.buildCascadeRemoveOperateSubjects = function (subject) {
                    var _this = this;
                    subject.metadata
                        .extractRelationValuesFromEntity(subject.entity, subject.metadata.relations)
                        .filter(function (_a) {
                        var relation = _a[0], value = _a[1], valueMetadata = _a[2];
                        // we need only defined values and insert cascades of the relation should be set
                        return value !== undefined && value !== null && relation.isCascadeRemove;
                    })
                        .forEach(function (_a) {
                        var relation = _a[0], value = _a[1], valueMetadata = _a[2];
                        // if we already has this entity in list of operated subjects then skip it to avoid recursion
                        var alreadyExistValueSubject = _this.findByEntityLike(valueMetadata.target, value);
                        if (alreadyExistValueSubject) {
                            alreadyExistValueSubject.mustBeRemoved = true;
                            return;
                        }
                        // add to the array of subjects to load only if there is no same entity there already
                        var valueSubject = new Subject_2.Subject(valueMetadata, value);
                        valueSubject.mustBeRemoved = true;
                        _this.operateSubjects.push(valueSubject);
                        // go recursively and find other entities to load by cascades in currently inserted entities
                        _this.buildCascadeRemoveOperateSubjects(valueSubject);
                    });
                };
                /**
                 * Loads database entities for all operate subjects which do not have database entity set.
                 * All entities that we load database entities for are marked as updated or inserted.
                 * To understand which of them really needs to be inserted or updated we need to load
                 * their original representations from the database.
                 */
                SubjectBuilder.prototype.loadOperateSubjectsDatabaseEntities = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var promises;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    promises = this.groupByEntityTargets().map(function (subjectGroup) { return __awaiter(_this, void 0, void 0, function () {
                                        var _this = this;
                                        var allIds, entities;
                                        return __generator(this, function (_a) {
                                            switch (_a.label) {
                                                case 0:
                                                    allIds = subjectGroup.subjects
                                                        .filter(function (subject) { return !subject.hasDatabaseEntity; }) // we don't load if subject already has a database entity loaded
                                                        .map(function (subject) { return subject.metadata.getEntityIdMixedMap(subject.entity); }) // we only need entity id
                                                        .filter(function (mixedId) {
                                                        if (mixedId instanceof Object)
                                                            return Object.keys(mixedId).every(function (key) { return mixedId[key] !== undefined && mixedId[key] !== null && mixedId[key] !== ""; });
                                                        return mixedId !== undefined && mixedId !== null && mixedId !== "";
                                                    });
                                                    // if there no ids found (which means all entities are new and have generated ids) - then nothing to load there
                                                    if (!allIds.length)
                                                        return [2 /*return*/];
                                                    return [4 /*yield*/, this.connection
                                                            .getRepository(subjectGroup.target)
                                                            .createQueryBuilder("operateSubject", this.queryRunnerProvider)
                                                            .andWhereInIds(allIds)
                                                            .enableOption("RELATION_ID_VALUES")
                                                            .getMany()];
                                                case 1:
                                                    entities = _a.sent();
                                                    // now when we have entities we need to find subject of each entity
                                                    // and insert that entity into database entity of the found subject
                                                    entities.forEach(function (entity) {
                                                        var subject = _this.findByEntityLike(subjectGroup.target, entity);
                                                        if (subject)
                                                            subject.databaseEntity = entity;
                                                    });
                                                    return [2 /*return*/];
                                            }
                                        });
                                    }); });
                                    return [4 /*yield*/, Promise.all(promises)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * We need to load removed entity when:
                 *  - entity with relations is not new (this can be determined only after entity is loaded from db)
                 *      (note: simple "id" check will not work because id can be not generated)
                 *  - entity missing relation. When relation is simple
                 *      - in the case of one-to-one owner (with join column) relation we need to load owner entity
                 *      - in the case of one-to-one (without join column) relation we need to load inverse side entity
                 *      - in the case of many-to-one relations we need to load entity itself
                 *      - in the case of one-to-many relations we need to load entities by relation from inverse side
                 *
                 *  Before loading each entity we need to check in the loaded subjects - maybe it was already loaded.
                 *
                 *  BIG NOTE: objects are being removed by cascades not only when relation is removed, but also when
                 *  relation is replaced (e.g. changed with different object).
                 */
                SubjectBuilder.prototype.buildCascadeRemovedAndRelationUpdateOperateSubjects = function (subject) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var promises;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    promises = subject.metadata.relations.map(function (relation) { return __awaiter(_this, void 0, void 0, function () {
                                        var _this = this;
                                        var valueMetadata, qbAlias, relationIdInDatabaseEntity_1, persistValueRelationId, persistValue, alreadyLoadedRelatedDatabaseSubject, databaseEntity, persistValueRelationId, persistValue, relationIdInDatabaseEntity_2, alreadyLoadedRelatedDatabaseSubject, databaseEntity, inverseEntityRelationId, persistValue_1, databaseEntities_1, escapeAlias, escapeColumn, relationIdInDatabaseEntity, relationIdInDatabaseEntity, relationIdInDatabaseEntity, promises_1, promises_2;
                                        return __generator(this, function (_a) {
                                            switch (_a.label) {
                                                case 0:
                                                    valueMetadata = relation.inverseEntityMetadata;
                                                    qbAlias = valueMetadata.table.name;
                                                    // added for type-safety, but subject without databaseEntity cant come here anyway because of checks on upper levels
                                                    if (!subject.hasDatabaseEntity)
                                                        return [2 /*return*/];
                                                    if (!(relation.isOneToOneOwner || relation.isManyToOne)) return [3 /*break*/, 4];
                                                    // we only work with cascade removes here
                                                    if (!relation.isCascadeRemove)
                                                        return [2 /*return*/];
                                                    relationIdInDatabaseEntity_1 = subject.databaseEntity[relation.joinColumn.propertyName];
                                                    // if database relation id does not exist in the database object then nothing to remove
                                                    if (relationIdInDatabaseEntity_1 === null || relationIdInDatabaseEntity_1 === undefined)
                                                        return [2 /*return*/];
                                                    persistValueRelationId = undefined;
                                                    if (subject.hasEntity) {
                                                        persistValue = relation.getEntityValue(subject.entity);
                                                        if (persistValue === null)
                                                            persistValueRelationId = null;
                                                        if (persistValue)
                                                            persistValueRelationId = persistValue[relation.joinColumn.referencedColumn.propertyName];
                                                        if (persistValueRelationId === undefined)
                                                            return [2 /*return*/]; // skip undefined properties
                                                    }
                                                    // object is removed only if relation id in the persisted entity is empty or is changed
                                                    if (persistValueRelationId !== null && persistValueRelationId === relationIdInDatabaseEntity_1)
                                                        return [2 /*return*/];
                                                    alreadyLoadedRelatedDatabaseSubject = this.operateSubjects.find(function (relatedSubject) {
                                                        // (example) filter only subject that has database entity loaded and its target is Details
                                                        if (!relatedSubject.hasDatabaseEntity || relatedSubject.entityTarget !== valueMetadata.target)
                                                            return false;
                                                        // (example) here we seek a Details loaded from the database in the subjects
                                                        // (example) here relatedSubject.databaseEntity is a Details
                                                        // (example) and we need to compare details.id === post.detailsId
                                                        return relatedSubject.databaseEntity[relation.joinColumn.referencedColumn.propertyName] === relationIdInDatabaseEntity_1;
                                                    });
                                                    if (!!alreadyLoadedRelatedDatabaseSubject) return [3 /*break*/, 2];
                                                    return [4 /*yield*/, this.connection
                                                            .getRepository(valueMetadata.target)
                                                            .createQueryBuilder(qbAlias, this.queryRunnerProvider)
                                                            .where(qbAlias + "." + relation.joinColumn.referencedColumn.propertyName + "=:id")
                                                            .setParameter("id", relationIdInDatabaseEntity_1) // (example) subject.entity is a post here
                                                            .enableOption("RELATION_ID_VALUES")
                                                            .getOne()];
                                                case 1:
                                                    databaseEntity = _a.sent();
                                                    if (databaseEntity) {
                                                        alreadyLoadedRelatedDatabaseSubject = new Subject_2.Subject(valueMetadata, undefined, databaseEntity);
                                                        this.operateSubjects.push(alreadyLoadedRelatedDatabaseSubject);
                                                    }
                                                    _a.label = 2;
                                                case 2:
                                                    if (!alreadyLoadedRelatedDatabaseSubject) return [3 /*break*/, 4];
                                                    // if object is already marked as removed then no need to proceed because it already was proceed
                                                    // if we remove this it will cause a recursion
                                                    if (alreadyLoadedRelatedDatabaseSubject.mustBeRemoved)
                                                        return [2 /*return*/];
                                                    alreadyLoadedRelatedDatabaseSubject.mustBeRemoved = true;
                                                    return [4 /*yield*/, this.buildCascadeRemovedAndRelationUpdateOperateSubjects(alreadyLoadedRelatedDatabaseSubject)];
                                                case 3:
                                                    _a.sent();
                                                    _a.label = 4;
                                                case 4:
                                                    if (!relation.isOneToOneNotOwner) return [3 /*break*/, 8];
                                                    // we only work with cascade removes here
                                                    if (!relation.isCascadeRemove)
                                                        return [2 /*return*/]; // todo: no
                                                    persistValueRelationId = undefined;
                                                    if (subject.hasEntity && !subject.mustBeRemoved) {
                                                        persistValue = relation.getEntityValue(subject.entity);
                                                        if (persistValue)
                                                            persistValueRelationId = persistValue[relation.inverseRelation.joinColumn.propertyName];
                                                        if (persistValueRelationId === undefined)
                                                            return [2 /*return*/]; // skip undefined properties
                                                    }
                                                    relationIdInDatabaseEntity_2 = subject.databaseEntity[relation.inverseRelation.joinColumn.referencedColumn.propertyName];
                                                    // if database relation id does not exist then nothing to remove (but can this be possible?)
                                                    if (relationIdInDatabaseEntity_2 === null || relationIdInDatabaseEntity_2 === undefined)
                                                        return [2 /*return*/];
                                                    alreadyLoadedRelatedDatabaseSubject = this.operateSubjects.find(function (relatedSubject) {
                                                        // (example) filter only subject that has database entity loaded and its target is Post
                                                        if (!relatedSubject.hasDatabaseEntity || relatedSubject.entityTarget !== valueMetadata.target)
                                                            return false;
                                                        // (example) here we seek a Post loaded from the database in the subjects
                                                        // (example) here relatedSubject.databaseEntity is a Post
                                                        // (example) and we need to compare post.detailsId === details.id
                                                        return relatedSubject.databaseEntity[relation.inverseRelation.joinColumn.propertyName] === relationIdInDatabaseEntity_2;
                                                    });
                                                    if (!!alreadyLoadedRelatedDatabaseSubject) return [3 /*break*/, 6];
                                                    return [4 /*yield*/, this.connection
                                                            .getRepository(valueMetadata.target)
                                                            .createQueryBuilder(qbAlias, this.queryRunnerProvider)
                                                            .where(qbAlias + "." + relation.inverseSideProperty + "=:id")
                                                            .setParameter("id", relationIdInDatabaseEntity_2) // (example) subject.entity is a details here, and the value is details.id
                                                            .enableOption("RELATION_ID_VALUES")
                                                            .getOne()];
                                                case 5:
                                                    databaseEntity = _a.sent();
                                                    // add only if database entity exist - because in the case of inverse side of the one-to-one relation
                                                    // we cannot check if it was removed or not until we query the database
                                                    // and it can be a situation that relation wasn't exist at all. This is particular that case
                                                    alreadyLoadedRelatedDatabaseSubject = new Subject_2.Subject(valueMetadata, undefined, databaseEntity);
                                                    this.operateSubjects.push(alreadyLoadedRelatedDatabaseSubject);
                                                    _a.label = 6;
                                                case 6:
                                                    if (!(alreadyLoadedRelatedDatabaseSubject && alreadyLoadedRelatedDatabaseSubject.hasDatabaseEntity)) return [3 /*break*/, 8];
                                                    inverseEntityRelationId = alreadyLoadedRelatedDatabaseSubject.databaseEntity[relation.inverseRelation.joinColumn.propertyName];
                                                    if (persistValueRelationId && persistValueRelationId === inverseEntityRelationId)
                                                        return [2 /*return*/];
                                                    // if object is already marked as removed then no need to proceed because it already was proceed
                                                    // if we remove this it will cause a recursion
                                                    if (alreadyLoadedRelatedDatabaseSubject.mustBeRemoved)
                                                        return [2 /*return*/];
                                                    alreadyLoadedRelatedDatabaseSubject.mustBeRemoved = true;
                                                    return [4 /*yield*/, this.buildCascadeRemovedAndRelationUpdateOperateSubjects(alreadyLoadedRelatedDatabaseSubject)];
                                                case 7:
                                                    _a.sent();
                                                    _a.label = 8;
                                                case 8:
                                                    if (!(relation.isOneToMany || relation.isManyToMany)) return [3 /*break*/, 18];
                                                    persistValue_1 = undefined;
                                                    if (subject.hasEntity) {
                                                        persistValue_1 = relation.getEntityValue(subject.entity);
                                                        if (persistValue_1 === undefined)
                                                            return [2 /*return*/]; // skip undefined properties
                                                    }
                                                    databaseEntities_1 = [];
                                                    escapeAlias = function (alias) { return _this.connection.driver.escapeAliasName(alias); };
                                                    escapeColumn = function (column) { return _this.connection.driver.escapeColumnName(column); };
                                                    if (!relation.isManyToManyOwner) return [3 /*break*/, 10];
                                                    relationIdInDatabaseEntity = subject.databaseEntity[relation.joinTable.referencedColumn.propertyName];
                                                    // we only need to load inverse entities if cascade removes are set
                                                    // because remove by cascades is the only reason we need relational entities here
                                                    if (!relation.isCascadeRemove)
                                                        return [2 /*return*/];
                                                    return [4 /*yield*/, this.connection
                                                            .getRepository(valueMetadata.target)
                                                            .createQueryBuilder(qbAlias, this.queryRunnerProvider)
                                                            .innerJoin(relation.junctionEntityMetadata.table.name, "persistenceJoinedRelation", escapeAlias("persistenceJoinedRelation") + "." + escapeColumn(relation.joinTable.inverseJoinColumnName) + "=" + escapeAlias(qbAlias) + "." + escapeColumn(relation.joinTable.inverseReferencedColumn.name) +
                                                            " AND " + escapeAlias("persistenceJoinedRelation") + "." + escapeColumn(relation.joinTable.joinColumnName) + "=:id")
                                                            .setParameter("id", relationIdInDatabaseEntity)
                                                            .enableOption("RELATION_ID_VALUES")
                                                            .getMany()];
                                                case 9:
                                                    databaseEntities_1 = _a.sent();
                                                    return [3 /*break*/, 14];
                                                case 10:
                                                    if (!relation.isManyToManyNotOwner) return [3 /*break*/, 12];
                                                    relationIdInDatabaseEntity = subject.databaseEntity[relation.inverseRelation.joinTable.inverseReferencedColumn.propertyName];
                                                    // we only need to load inverse entities if cascade removes are set
                                                    // because remove by cascades is the only reason we need relational entities here
                                                    if (!relation.isCascadeRemove)
                                                        return [2 /*return*/];
                                                    return [4 /*yield*/, this.connection
                                                            .getRepository(valueMetadata.target)
                                                            .createQueryBuilder(qbAlias, this.queryRunnerProvider)
                                                            .innerJoin(relation.junctionEntityMetadata.table.name, "persistenceJoinedRelation", escapeAlias("persistenceJoinedRelation") + "." + escapeColumn(relation.joinTable.joinColumnName) + "=" + escapeAlias(qbAlias) + "." + escapeColumn(relation.joinTable.referencedColumn.name) +
                                                            " AND " + escapeAlias("persistenceJoinedRelation") + "." + escapeColumn(relation.inverseRelation.joinTable.inverseJoinColumnName) + "=:id")
                                                            .setParameter("id", relationIdInDatabaseEntity)
                                                            .enableOption("RELATION_ID_VALUES")
                                                            .getMany()];
                                                case 11:
                                                    databaseEntities_1 = _a.sent();
                                                    return [3 /*break*/, 14];
                                                case 12:
                                                    relationIdInDatabaseEntity = subject.databaseEntity[relation.inverseRelation.joinColumn.referencedColumn.propertyName];
                                                    return [4 /*yield*/, this.connection
                                                            .getRepository(valueMetadata.target)
                                                            .createQueryBuilder(qbAlias, this.queryRunnerProvider)
                                                            .where(qbAlias + "." + relation.inverseSideProperty + "=:id")
                                                            .setParameter("id", relationIdInDatabaseEntity)
                                                            .enableOption("RELATION_ID_VALUES")
                                                            .getMany()];
                                                case 13:
                                                    // in this case we need inverse entities not only because of cascade removes
                                                    // because we also need inverse entities to be able to perform update of entities
                                                    // in the inverse side when entities is detached from one-to-many relation
                                                    databaseEntities_1 = _a.sent();
                                                    _a.label = 14;
                                                case 14:
                                                    // add to loadMap loaded entities if some of them are missing
                                                    databaseEntities_1.forEach(function (databaseEntity) {
                                                        var subjectInLoadMap = _this.findByEntityLike(valueMetadata.target, databaseEntity);
                                                        if (subjectInLoadMap && !subjectInLoadMap.hasDatabaseEntity) {
                                                            subjectInLoadMap.databaseEntity = databaseEntity;
                                                        }
                                                        else if (!subjectInLoadMap) {
                                                            var subject_1 = new Subject_2.Subject(valueMetadata, undefined, databaseEntity);
                                                            _this.operateSubjects.push(subject_1);
                                                        }
                                                    });
                                                    if (!(relation.isOneToMany && persistValue_1)) return [3 /*break*/, 16];
                                                    promises_1 = persistValue_1.map(function (persistValue) { return __awaiter(_this, void 0, void 0, function () {
                                                        var persistedValueInDatabaseEntity, loadedSubject, id, databaseEntity;
                                                        return __generator(this, function (_a) {
                                                            switch (_a.label) {
                                                                case 0:
                                                                    persistedValueInDatabaseEntity = databaseEntities_1.find(function (databaseEntity) {
                                                                        return valueMetadata.compareEntities(persistValue, databaseEntity);
                                                                    });
                                                                    if (!!persistedValueInDatabaseEntity) return [3 /*break*/, 3];
                                                                    loadedSubject = this.findByDatabaseEntityLike(valueMetadata.target, persistValue);
                                                                    if (!!loadedSubject) return [3 /*break*/, 2];
                                                                    id = valueMetadata.getEntityIdMixedMap(persistValue);
                                                                    if (!id) return [3 /*break*/, 2];
                                                                    return [4 /*yield*/, this.connection
                                                                            .getRepository(valueMetadata.target)
                                                                            .createQueryBuilder(qbAlias, this.queryRunnerProvider)
                                                                            .andWhereInIds([id])
                                                                            .enableOption("RELATION_ID_VALUES")
                                                                            .getOne()];
                                                                case 1:
                                                                    databaseEntity = _a.sent();
                                                                    if (databaseEntity) {
                                                                        loadedSubject = new Subject_2.Subject(valueMetadata, undefined, databaseEntity); // todo: what if entity like object exist in the loaded subjects but without databaseEntity?
                                                                        this.operateSubjects.push(loadedSubject);
                                                                    }
                                                                    _a.label = 2;
                                                                case 2:
                                                                    if (loadedSubject)
                                                                        loadedSubject.relationUpdates.push({
                                                                            relation: relation.inverseRelation,
                                                                            value: subject.entity
                                                                        });
                                                                    _a.label = 3;
                                                                case 3: return [2 /*return*/];
                                                            }
                                                        });
                                                    }); });
                                                    return [4 /*yield*/, Promise.all(promises_1)];
                                                case 15:
                                                    _a.sent();
                                                    _a.label = 16;
                                                case 16:
                                                    promises_2 = databaseEntities_1.map(function (databaseEntity) { return __awaiter(_this, void 0, void 0, function () {
                                                        var relatedEntitySubject, relatedValue;
                                                        return __generator(this, function (_a) {
                                                            switch (_a.label) {
                                                                case 0:
                                                                    relatedEntitySubject = this.findByDatabaseEntityLike(valueMetadata.target, databaseEntity);
                                                                    if (!relatedEntitySubject)
                                                                        return [2 /*return*/]; // should not be possible, anyway add it for type-safety
                                                                    // if object is already marked as removed then no need to proceed because it already was proceed
                                                                    // if we remove this check it will cause a recursion
                                                                    if (relatedEntitySubject.mustBeRemoved)
                                                                        return [2 /*return*/]; // todo: add another check for entity in unsetRelations?
                                                                    relatedValue = (persistValue_1 || []).find(function (persistValueItem) {
                                                                        return valueMetadata.compareEntities(relatedEntitySubject.databaseEntity, persistValueItem);
                                                                    });
                                                                    if (!(persistValue_1 === null || !relatedValue)) return [3 /*break*/, 3];
                                                                    if (!relation.isCascadeRemove) return [3 /*break*/, 2];
                                                                    relatedEntitySubject.mustBeRemoved = true;
                                                                    // mark as removed all underlying entities that has cascade remove
                                                                    return [4 /*yield*/, this.buildCascadeRemovedAndRelationUpdateOperateSubjects(relatedEntitySubject)];
                                                                case 1:
                                                                    // mark as removed all underlying entities that has cascade remove
                                                                    _a.sent();
                                                                    return [3 /*break*/, 3];
                                                                case 2:
                                                                    if (relation.isOneToMany && relation.inverseRelation) {
                                                                        relatedEntitySubject.relationUpdates.push({
                                                                            relation: relation.inverseRelation,
                                                                            value: null
                                                                        }); // todo: implement same for one-to-one
                                                                    }
                                                                    _a.label = 3;
                                                                case 3: return [2 /*return*/];
                                                            }
                                                        });
                                                    }); });
                                                    return [4 /*yield*/, Promise.all(promises_2)];
                                                case 17:
                                                    _a.sent();
                                                    _a.label = 18;
                                                case 18: return [2 /*return*/];
                                            }
                                        });
                                    }); });
                                    return [4 /*yield*/, Promise.all(promises)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Builds all junction insert and remove operations used to insert new bind data into junction tables,
                 * or remove old junction records.
                 * Options specifies which junction operations should be built - insert, remove or both.
                 */
                SubjectBuilder.prototype.buildJunctionOperations = function (options) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var promises;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    promises = this.operateSubjects.filter(function (subject) { return subject.hasEntity; }).map(function (subject) {
                                        var promises = subject.metadata.manyToManyRelations.map(function (relation) { return __awaiter(_this, void 0, void 0, function () {
                                            var specificRepository, existInverseEntityRelationIds_1, relatedValue, existInverseEntityRelationIds, specificRepository, changedInverseEntityRelationIds, removedJunctionEntityIds, newJunctionEntities;
                                            return __generator(this, function (_a) {
                                                switch (_a.label) {
                                                    case 0:
                                                        if (!(subject.mustBeRemoved && options.remove)) return [3 /*break*/, 2];
                                                        specificRepository = new SpecificRepository_2.SpecificRepository(this.connection, subject.metadata, this.queryRunnerProvider);
                                                        return [4 /*yield*/, specificRepository
                                                                .findRelationIds(relation, subject.databaseEntity)];
                                                    case 1:
                                                        existInverseEntityRelationIds_1 = _a.sent();
                                                        // finally create a new junction remove operation and push it to the array of such operations
                                                        if (existInverseEntityRelationIds_1.length > 0) {
                                                            subject.junctionRemoves.push({
                                                                relation: relation,
                                                                junctionRelationIds: existInverseEntityRelationIds_1
                                                            });
                                                        }
                                                        return [2 /*return*/];
                                                    case 2:
                                                        // if entity don't have entity then no need to find something that should be inserted or removed
                                                        if (!subject.hasEntity)
                                                            return [2 /*return*/];
                                                        relatedValue = relation.getEntityValue(subject.entity);
                                                        if (!(relatedValue instanceof Array))
                                                            return [2 /*return*/];
                                                        existInverseEntityRelationIds = [];
                                                        if (!subject.hasDatabaseEntity) return [3 /*break*/, 4];
                                                        specificRepository = new SpecificRepository_2.SpecificRepository(this.connection, subject.metadata, this.queryRunnerProvider);
                                                        return [4 /*yield*/, specificRepository
                                                                .findRelationIds(relation, subject.databaseEntity)];
                                                    case 3:
                                                        existInverseEntityRelationIds = _a.sent();
                                                        _a.label = 4;
                                                    case 4:
                                                        changedInverseEntityRelationIds = relatedValue
                                                            .map(function (subRelationValue) {
                                                            return relation.isManyToManyOwner
                                                                ? subRelationValue[relation.joinTable.inverseReferencedColumn.propertyName]
                                                                : subRelationValue[relation.inverseRelation.joinTable.referencedColumn.propertyName];
                                                        })
                                                            .filter(function (subRelationValue) { return subRelationValue !== undefined && subRelationValue !== null; });
                                                        removedJunctionEntityIds = existInverseEntityRelationIds.filter(function (existRelationId) {
                                                            return !changedInverseEntityRelationIds.find(function (changedRelationId) {
                                                                return changedRelationId === existRelationId;
                                                            });
                                                        });
                                                        newJunctionEntities = relatedValue.filter(function (subRelatedValue) {
                                                            var relationValue = relation.isManyToManyOwner
                                                                ? subRelatedValue[relation.joinTable.inverseReferencedColumn.propertyName]
                                                                : subRelatedValue[relation.inverseRelation.joinTable.referencedColumn.propertyName];
                                                            return !existInverseEntityRelationIds.find(function (relationId) { return relationValue === relationId; });
                                                        });
                                                        // finally create a new junction insert operation and push it to the array of such operations
                                                        if (newJunctionEntities.length > 0 && options.insert) {
                                                            subject.junctionInserts.push({
                                                                relation: relation,
                                                                junctionEntities: newJunctionEntities
                                                            });
                                                        }
                                                        // finally create a new junction remove operation and push it to the array of such operations
                                                        if (removedJunctionEntityIds.length > 0 && options.remove) {
                                                            subject.junctionRemoves.push({
                                                                relation: relation,
                                                                junctionRelationIds: removedJunctionEntityIds
                                                            });
                                                        }
                                                        return [2 /*return*/];
                                                }
                                            });
                                        }); });
                                        return Promise.all(promises);
                                    });
                                    return [4 /*yield*/, Promise.all(promises)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Finds subject where entity like given subject's entity.
                 * Comparision made by entity id.
                 */
                SubjectBuilder.prototype.findByEntityLike = function (entityTarget, entity) {
                    return this.operateSubjects.find(function (subject) {
                        if (!subject.hasEntity)
                            return false;
                        if (subject.entity === entity)
                            return true;
                        return subject.entityTarget === entityTarget && subject.metadata.compareEntities(subject.entity, entity);
                    });
                };
                /**
                 * Finds subject where entity like given subject's database entity.
                 * Comparision made by entity id.
                 */
                SubjectBuilder.prototype.findByDatabaseEntityLike = function (entityTarget, entity) {
                    return this.operateSubjects.find(function (subject) {
                        if (!subject.hasDatabaseEntity)
                            return false;
                        return subject.entityTarget === entityTarget && subject.metadata.compareEntities(subject.databaseEntity, entity);
                    });
                };
                /**
                 * Groups given Subject objects into groups separated by entity targets.
                 */
                SubjectBuilder.prototype.groupByEntityTargets = function () {
                    return this.operateSubjects.reduce(function (groups, operatedEntity) {
                        var group = groups.find(function (group) { return group.target === operatedEntity.entityTarget; });
                        if (!group) {
                            group = { target: operatedEntity.entityTarget, subjects: [] };
                            groups.push(group);
                        }
                        group.subjects.push(operatedEntity);
                        return groups;
                    }, []);
                };
                return SubjectBuilder;
            }());
            exports_76("SubjectBuilder", SubjectBuilder);
        }
    };
});
System.register("typeorm/repository/Repository", ["typeorm/query-builder/QueryBuilder", "typeorm/query-builder/transformer/PlainObjectToNewEntityTransformer", "typeorm/query-builder/transformer/PlainObjectToDatabaseEntityTransformer", "typeorm/find-options/FindOptionsUtils", "typeorm/query-runner/QueryRunnerProvider", "typeorm/persistence/SubjectOperationExecutor", "typeorm/persistence/SubjectBuilder"], function (exports_77, context_77) {
    "use strict";
    var __moduleName = context_77 && context_77.id;
    var QueryBuilder_3, PlainObjectToNewEntityTransformer_1, PlainObjectToDatabaseEntityTransformer_1, FindOptionsUtils_1, QueryRunnerProvider_4, SubjectOperationExecutor_1, SubjectBuilder_1, Repository;
    return {
        setters: [
            function (QueryBuilder_3_1) {
                QueryBuilder_3 = QueryBuilder_3_1;
            },
            function (PlainObjectToNewEntityTransformer_1_1) {
                PlainObjectToNewEntityTransformer_1 = PlainObjectToNewEntityTransformer_1_1;
            },
            function (PlainObjectToDatabaseEntityTransformer_1_1) {
                PlainObjectToDatabaseEntityTransformer_1 = PlainObjectToDatabaseEntityTransformer_1_1;
            },
            function (FindOptionsUtils_1_1) {
                FindOptionsUtils_1 = FindOptionsUtils_1_1;
            },
            function (QueryRunnerProvider_4_1) {
                QueryRunnerProvider_4 = QueryRunnerProvider_4_1;
            },
            function (SubjectOperationExecutor_1_1) {
                SubjectOperationExecutor_1 = SubjectOperationExecutor_1_1;
            },
            function (SubjectBuilder_1_1) {
                SubjectBuilder_1 = SubjectBuilder_1_1;
            }
        ],
        execute: function () {
            /**
             * Repository is supposed to work with your entity objects. Find entities, insert, update, delete, etc.
             */
            Repository = (function () {
                function Repository() {
                }
                Object.defineProperty(Repository.prototype, "target", {
                    // -------------------------------------------------------------------------
                    // Public Methods
                    // -------------------------------------------------------------------------
                    /**
                     * Returns object that is managed by this repository.
                     * If this repository manages entity from schema,
                     * then it returns a name of that schema instead.
                     */
                    get: function () {
                        return this.metadata.target;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Checks if entity has an id.
                 * If entity contains compose ids, then it checks them all.
                 */
                Repository.prototype.hasId = function (entity) {
                    return this.metadata.hasId(entity);
                };
                /**
                 * Creates a new query builder that can be used to build a sql query.
                 */
                Repository.prototype.createQueryBuilder = function (alias, queryRunnerProvider) {
                    return new QueryBuilder_3.QueryBuilder(this.connection, queryRunnerProvider || this.queryRunnerProvider)
                        .select(alias)
                        .from(this.metadata.target, alias);
                };
                /**
                 * Creates a new entity instance or instances.
                 * Can copy properties from the given object into new entities.
                 */
                Repository.prototype.create = function (plainObjectOrObjects) {
                    var _this = this;
                    if (plainObjectOrObjects instanceof Array)
                        return plainObjectOrObjects.map(function (object) { return _this.create(object); });
                    var newEntity = this.metadata.create();
                    if (plainObjectOrObjects) {
                        var plainObjectToEntityTransformer = new PlainObjectToNewEntityTransformer_1.PlainObjectToNewEntityTransformer();
                        plainObjectToEntityTransformer.transform(newEntity, plainObjectOrObjects, this.metadata);
                    }
                    return newEntity;
                };
                /**
                 * Creates a new entity from the given plan javascript object. If entity already exist in the database, then
                 * it loads it (and everything related to it), replaces all values with the new ones from the given object
                 * and returns this new entity. This new entity is actually a loaded from the db entity with all properties
                 * replaced from the new object.
                 */
                Repository.prototype.preload = function (object) {
                    var queryBuilder = this.createQueryBuilder(this.metadata.table.name);
                    var plainObjectToDatabaseEntityTransformer = new PlainObjectToDatabaseEntityTransformer_1.PlainObjectToDatabaseEntityTransformer();
                    return plainObjectToDatabaseEntityTransformer.transform(object, this.metadata, queryBuilder);
                };
                /**
                 * Merges multiple entities (or entity-like objects) into a one new entity.
                 */
                Repository.prototype.merge = function () {
                    var _this = this;
                    var objects = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        objects[_i] = arguments[_i];
                    }
                    var newEntity = this.metadata.create();
                    var plainObjectToEntityTransformer = new PlainObjectToNewEntityTransformer_1.PlainObjectToNewEntityTransformer();
                    objects.forEach(function (object) { return plainObjectToEntityTransformer.transform(newEntity, object, _this.metadata); });
                    return newEntity;
                };
                /**
                 * Persists one or many given entities.
                 */
                Repository.prototype.persist = function (entityOrEntities) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var queryRunnerProvider, transactionEntityManager, databaseEntityLoader, executor;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    // if multiple entities given then go throw all of them and save them
                                    if (entityOrEntities instanceof Array)
                                        return [2 /*return*/, Promise.all(entityOrEntities.map(function (entity) { return _this.persist(entity); }))];
                                    queryRunnerProvider = this.queryRunnerProvider || new QueryRunnerProvider_4.QueryRunnerProvider(this.connection.driver, true);
                                    _a.label = 1;
                                case 1:
                                    _a.trys.push([1, , 4, 7]);
                                    transactionEntityManager = this.connection.createEntityManagerWithSingleDatabaseConnection(queryRunnerProvider);
                                    databaseEntityLoader = new SubjectBuilder_1.SubjectBuilder(this.connection, queryRunnerProvider);
                                    return [4 /*yield*/, databaseEntityLoader.persist(entityOrEntities, this.metadata)];
                                case 2:
                                    _a.sent();
                                    executor = new SubjectOperationExecutor_1.SubjectOperationExecutor(this.connection, transactionEntityManager, queryRunnerProvider);
                                    return [4 /*yield*/, executor.execute(databaseEntityLoader.operateSubjects)];
                                case 3:
                                    _a.sent();
                                    return [2 /*return*/, entityOrEntities];
                                case 4:
                                    if (!!this.queryRunnerProvider) return [3 /*break*/, 6];
                                    return [4 /*yield*/, queryRunnerProvider.releaseReused()];
                                case 5:
                                    _a.sent();
                                    _a.label = 6;
                                case 6: return [7 /*endfinally*/];
                                case 7: return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Removes one or many given entities.
                 */
                Repository.prototype.remove = function (entityOrEntities) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var queryRunnerProvider, transactionEntityManager, databaseEntityLoader, executor;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    // if multiple entities given then go throw all of them and save them
                                    if (entityOrEntities instanceof Array)
                                        return [2 /*return*/, Promise.all(entityOrEntities.map(function (entity) { return _this.remove(entity); }))];
                                    queryRunnerProvider = this.queryRunnerProvider || new QueryRunnerProvider_4.QueryRunnerProvider(this.connection.driver, true);
                                    _a.label = 1;
                                case 1:
                                    _a.trys.push([1, , 4, 7]);
                                    transactionEntityManager = this.connection.createEntityManagerWithSingleDatabaseConnection(queryRunnerProvider);
                                    databaseEntityLoader = new SubjectBuilder_1.SubjectBuilder(this.connection, queryRunnerProvider);
                                    return [4 /*yield*/, databaseEntityLoader.remove(entityOrEntities, this.metadata)];
                                case 2:
                                    _a.sent();
                                    executor = new SubjectOperationExecutor_1.SubjectOperationExecutor(this.connection, transactionEntityManager, queryRunnerProvider);
                                    return [4 /*yield*/, executor.execute(databaseEntityLoader.operateSubjects)];
                                case 3:
                                    _a.sent();
                                    return [2 /*return*/, entityOrEntities];
                                case 4:
                                    if (!!this.queryRunnerProvider) return [3 /*break*/, 6];
                                    return [4 /*yield*/, queryRunnerProvider.releaseReused()];
                                case 5:
                                    _a.sent();
                                    _a.label = 6;
                                case 6: return [7 /*endfinally*/];
                                case 7: return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Counts entities that match given conditions and/or find options.
                 */
                Repository.prototype.count = function (conditionsOrFindOptions, options) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            return [2 /*return*/, this.createFindQueryBuilder(conditionsOrFindOptions, options)
                                    .getCount()];
                        });
                    });
                };
                /**
                 * Finds entities that match given conditions and/or find options.
                 */
                Repository.prototype.find = function (conditionsOrFindOptions, options) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            return [2 /*return*/, this.createFindQueryBuilder(conditionsOrFindOptions, options)
                                    .getMany()];
                        });
                    });
                };
                /**
                 * Finds entities that match given conditions.
                 * Also counts all entities that match given conditions,
                 * but ignores pagination settings (maxResults, firstResult) options.
                 */
                Repository.prototype.findAndCount = function (conditionsOrFindOptions, options) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            return [2 /*return*/, this.createFindQueryBuilder(conditionsOrFindOptions, options)
                                    .getManyAndCount()];
                        });
                    });
                };
                /**
                 * Finds first entity that matches given conditions and/or find options.
                 */
                Repository.prototype.findOne = function (conditionsOrFindOptions, options) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            return [2 /*return*/, this.createFindQueryBuilder(conditionsOrFindOptions, options)
                                    .getOne()];
                        });
                    });
                };
                /**
                 * Finds entities with ids.
                 * Optionally find options can be applied.
                 */
                Repository.prototype.findByIds = function (ids, options) {
                    return __awaiter(this, void 0, void 0, function () {
                        var qb;
                        return __generator(this, function (_a) {
                            qb = this.createFindQueryBuilder(undefined, options);
                            return [2 /*return*/, qb.andWhereInIds(ids).getMany()];
                        });
                    });
                };
                /**
                 * Finds entity with given id.
                 * Optionally find options can be applied.
                 */
                Repository.prototype.findOneById = function (id, options) {
                    return __awaiter(this, void 0, void 0, function () {
                        var qb;
                        return __generator(this, function (_a) {
                            qb = this.createFindQueryBuilder(undefined, options);
                            return [2 /*return*/, qb.andWhereInIds([id]).getOne()];
                        });
                    });
                };
                /**
                 * Executes a raw SQL query and returns a raw database results.
                 */
                Repository.prototype.query = function (query, parameters) {
                    return __awaiter(this, void 0, void 0, function () {
                        var queryRunnerProvider, queryRunner;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    queryRunnerProvider = this.queryRunnerProvider || new QueryRunnerProvider_4.QueryRunnerProvider(this.connection.driver);
                                    return [4 /*yield*/, queryRunnerProvider.provide()];
                                case 1:
                                    queryRunner = _a.sent();
                                    _a.label = 2;
                                case 2:
                                    _a.trys.push([2, , 4, 6]);
                                    return [4 /*yield*/, queryRunner.query(query, parameters)];
                                case 3: return [2 /*return*/, _a.sent()]; // await is needed here because we are using finally
                                case 4: return [4 /*yield*/, queryRunnerProvider.release(queryRunner)];
                                case 5:
                                    _a.sent();
                                    return [7 /*endfinally*/];
                                case 6: return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Wraps given function execution (and all operations made there) in a transaction.
                 * All database operations must be executed using provided repository.
                 */
                Repository.prototype.transaction = function (runInTransaction) {
                    return __awaiter(this, void 0, void 0, function () {
                        var queryRunnerProvider, queryRunner, transactionRepository, result, err_2;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    queryRunnerProvider = this.queryRunnerProvider || new QueryRunnerProvider_4.QueryRunnerProvider(this.connection.driver, true);
                                    return [4 /*yield*/, queryRunnerProvider.provide()];
                                case 1:
                                    queryRunner = _a.sent();
                                    transactionRepository = new Repository();
                                    transactionRepository["connection"] = this.connection;
                                    transactionRepository["metadata"] = this.metadata;
                                    transactionRepository["queryRunnerProvider"] = queryRunnerProvider;
                                    _a.label = 2;
                                case 2:
                                    _a.trys.push([2, 6, 8, 12]);
                                    return [4 /*yield*/, queryRunner.beginTransaction()];
                                case 3:
                                    _a.sent();
                                    return [4 /*yield*/, runInTransaction(transactionRepository)];
                                case 4:
                                    result = _a.sent();
                                    return [4 /*yield*/, queryRunner.commitTransaction()];
                                case 5:
                                    _a.sent();
                                    return [2 /*return*/, result];
                                case 6:
                                    err_2 = _a.sent();
                                    return [4 /*yield*/, queryRunner.rollbackTransaction()];
                                case 7:
                                    _a.sent();
                                    throw err_2;
                                case 8: return [4 /*yield*/, queryRunnerProvider.release(queryRunner)];
                                case 9:
                                    _a.sent();
                                    if (!!this.queryRunnerProvider) return [3 /*break*/, 11];
                                    return [4 /*yield*/, queryRunnerProvider.releaseReused()];
                                case 10:
                                    _a.sent();
                                    _a.label = 11;
                                case 11: return [7 /*endfinally*/];
                                case 12: return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Clears all the data from the given table (truncates/drops it).
                 */
                Repository.prototype.clear = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var queryRunnerProvider, queryRunner;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    queryRunnerProvider = this.queryRunnerProvider || new QueryRunnerProvider_4.QueryRunnerProvider(this.connection.driver);
                                    return [4 /*yield*/, queryRunnerProvider.provide()];
                                case 1:
                                    queryRunner = _a.sent();
                                    _a.label = 2;
                                case 2:
                                    _a.trys.push([2, , 4, 6]);
                                    return [4 /*yield*/, queryRunner.truncate(this.metadata.table.name)];
                                case 3: return [2 /*return*/, _a.sent()]; // await is needed here because we are using finally
                                case 4: return [4 /*yield*/, queryRunnerProvider.release(queryRunner)];
                                case 5:
                                    _a.sent();
                                    return [7 /*endfinally*/];
                                case 6: return [2 /*return*/];
                            }
                        });
                    });
                };
                // -------------------------------------------------------------------------
                // Protected Methods
                // -------------------------------------------------------------------------
                /**
                 * Creates a query builder from the given conditions or find options.
                 * Used to create a query builder for find* methods.
                 */
                Repository.prototype.createFindQueryBuilder = function (conditionsOrFindOptions, options) {
                    var findOptions = FindOptionsUtils_1.FindOptionsUtils.isFindOptions(conditionsOrFindOptions) ? conditionsOrFindOptions : options;
                    var conditions = FindOptionsUtils_1.FindOptionsUtils.isFindOptions(conditionsOrFindOptions) ? undefined : conditionsOrFindOptions;
                    var alias = findOptions ? findOptions.alias : this.metadata.table.name;
                    var qb = this.createQueryBuilder(alias);
                    // if find options are given then apply them to query builder
                    if (findOptions)
                        FindOptionsUtils_1.FindOptionsUtils.applyOptionsToQueryBuilder(qb, findOptions);
                    // if conditions are given then apply them to query builder
                    if (conditions) {
                        Object.keys(conditions).forEach(function (key) {
                            var name = key.indexOf(".") === -1 ? alias + "." + key : key;
                            if (conditions[key] === null) {
                                qb.andWhere(name + " IS NULL");
                            }
                            else {
                                qb.andWhere(name + "=:" + key);
                            }
                        });
                        qb.setParameters(conditions);
                    }
                    return qb;
                };
                return Repository;
            }());
            exports_77("Repository", Repository);
        }
    };
});
System.register("typeorm/subscriber/event/UpdateEvent", [], function (exports_78, context_78) {
    "use strict";
    var __moduleName = context_78 && context_78.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/subscriber/event/RemoveEvent", [], function (exports_79, context_79) {
    "use strict";
    var __moduleName = context_79 && context_79.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/subscriber/event/InsertEvent", [], function (exports_80, context_80) {
    "use strict";
    var __moduleName = context_80 && context_80.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/subscriber/EntitySubscriberInterface", [], function (exports_81, context_81) {
    "use strict";
    var __moduleName = context_81 && context_81.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/connection/error/RepositoryNotFoundError", [], function (exports_82, context_82) {
    "use strict";
    var __moduleName = context_82 && context_82.id;
    var RepositoryNotFoundError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown when repository for the given class is not found.
             */
            RepositoryNotFoundError = (function (_super) {
                __extends(RepositoryNotFoundError, _super);
                function RepositoryNotFoundError(connectionName, entityClass) {
                    var _this = _super.call(this) || this;
                    _this.name = "RepositoryNotFoundError";
                    var targetName = typeof entityClass === "function" && entityClass.name ? entityClass.name : entityClass;
                    _this.message = "No repository for \"" + targetName + "\" was found. Looks like this entity is not registered in " +
                        ("current \"" + connectionName + "\" connection?");
                    _this.stack = new Error().stack;
                    return _this;
                }
                return RepositoryNotFoundError;
            }(Error));
            exports_82("RepositoryNotFoundError", RepositoryNotFoundError);
        }
    };
});
System.register("typeorm/metadata/types/EventListenerTypes", [], function (exports_83, context_83) {
    "use strict";
    var __moduleName = context_83 && context_83.id;
    var EventListenerTypes;
    return {
        setters: [],
        execute: function () {
            /**
             * Provides a constants for each entity listener type.
             */
            EventListenerTypes = (function () {
                function EventListenerTypes() {
                }
                return EventListenerTypes;
            }());
            EventListenerTypes.AFTER_LOAD = "after-load";
            EventListenerTypes.BEFORE_INSERT = "before-insert";
            EventListenerTypes.AFTER_INSERT = "after-insert";
            EventListenerTypes.BEFORE_UPDATE = "before-update";
            EventListenerTypes.AFTER_UPDATE = "after-update";
            EventListenerTypes.BEFORE_REMOVE = "before-remove";
            EventListenerTypes.AFTER_REMOVE = "after-remove";
            exports_83("EventListenerTypes", EventListenerTypes);
        }
    };
});
System.register("typeorm/metadata-args/EntityListenerMetadataArgs", [], function (exports_84, context_84) {
    "use strict";
    var __moduleName = context_84 && context_84.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/metadata/EntityListenerMetadata", [], function (exports_85, context_85) {
    "use strict";
    var __moduleName = context_85 && context_85.id;
    var EntityListenerMetadata;
    return {
        setters: [],
        execute: function () {
            /**
             * This metadata contains all information about entity's listeners.
             */
            EntityListenerMetadata = (function () {
                // ---------------------------------------------------------------------
                // Constructor
                // ---------------------------------------------------------------------
                function EntityListenerMetadata(args) {
                    this.target = args.target;
                    this.propertyName = args.propertyName;
                    this.type = args.type;
                }
                return EntityListenerMetadata;
            }());
            exports_85("EntityListenerMetadata", EntityListenerMetadata);
        }
    };
});
System.register("typeorm/util/DirectoryExportedClassesLoader", ["typeorm/platform/PlatformTools"], function (exports_86, context_86) {
    "use strict";
    var __moduleName = context_86 && context_86.id;
    /**
     * Loads all exported classes from the given directory.
     */
    function importClassesFromDirectories(directories, formats) {
        if (formats === void 0) { formats = [".js", ".ts"]; }
        function loadFileClasses(exported, allLoaded) {
            if (exported instanceof Function) {
                allLoaded.push(exported);
            }
            else if (exported instanceof Object) {
                Object.keys(exported).forEach(function (key) { return loadFileClasses(exported[key], allLoaded); });
            }
            else if (exported instanceof Array) {
                exported.forEach(function (i) { return loadFileClasses(i, allLoaded); });
            }
            return allLoaded;
        }
        var allFiles = directories.reduce(function (allDirs, dir) {
            return allDirs.concat(PlatformTools_3.PlatformTools.load("glob").sync(PlatformTools_3.PlatformTools.pathNormilize(dir)));
        }, []);
        var dirs = allFiles
            .filter(function (file) {
            var dtsExtension = file.substring(file.length - 5, file.length);
            return formats.indexOf(PlatformTools_3.PlatformTools.pathExtname(file)) !== -1 && dtsExtension !== ".d.ts";
        })
            .map(function (file) { return PlatformTools_3.PlatformTools.load(PlatformTools_3.PlatformTools.pathResolve(file)); });
        return loadFileClasses(dirs, []);
    }
    exports_86("importClassesFromDirectories", importClassesFromDirectories);
    /**
     * Loads all json files from the given directory.
     */
    function importJsonsFromDirectories(directories, format) {
        if (format === void 0) { format = ".json"; }
        var allFiles = directories.reduce(function (allDirs, dir) {
            return allDirs.concat(PlatformTools_3.PlatformTools.load("glob").sync(PlatformTools_3.PlatformTools.pathNormilize(dir)));
        }, []);
        return allFiles
            .filter(function (file) { return PlatformTools_3.PlatformTools.pathExtname(file) === format; })
            .map(function (file) { return PlatformTools_3.PlatformTools.load(PlatformTools_3.PlatformTools.pathResolve(file)); });
    }
    exports_86("importJsonsFromDirectories", importJsonsFromDirectories);
    var PlatformTools_3;
    return {
        setters: [
            function (PlatformTools_3_1) {
                PlatformTools_3 = PlatformTools_3_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/metadata-builder/error/UsingJoinTableIsNotAllowedError", [], function (exports_87, context_87) {
    "use strict";
    var __moduleName = context_87 && context_87.id;
    var UsingJoinTableIsNotAllowedError;
    return {
        setters: [],
        execute: function () {
            /**
             */
            UsingJoinTableIsNotAllowedError = (function (_super) {
                __extends(UsingJoinTableIsNotAllowedError, _super);
                function UsingJoinTableIsNotAllowedError(entityMetadata, relation) {
                    var _this = _super.call(this) || this;
                    _this.name = "UsingJoinTableIsNotAllowedError";
                    _this.message = "Using JoinTable on " + entityMetadata.name + "#" + relation.propertyName + " is wrong. " +
                        (entityMetadata.name + "#" + relation.propertyName + " has " + relation.relationType + " relation, ") +
                        "however you can use JoinTable only on many-to-many relations.";
                    return _this;
                }
                return UsingJoinTableIsNotAllowedError;
            }(Error));
            exports_87("UsingJoinTableIsNotAllowedError", UsingJoinTableIsNotAllowedError);
        }
    };
});
System.register("typeorm/metadata-builder/error/UsingJoinTableOnlyOnOneSideAllowedError", [], function (exports_88, context_88) {
    "use strict";
    var __moduleName = context_88 && context_88.id;
    var UsingJoinTableOnlyOnOneSideAllowedError;
    return {
        setters: [],
        execute: function () {
            /**
             */
            UsingJoinTableOnlyOnOneSideAllowedError = (function (_super) {
                __extends(UsingJoinTableOnlyOnOneSideAllowedError, _super);
                function UsingJoinTableOnlyOnOneSideAllowedError(entityMetadata, relation) {
                    var _this = _super.call(this) || this;
                    _this.name = "UsingJoinTableOnlyOnOneSideAllowedError";
                    _this.message = "Using JoinTable is allowed only on one side of the many-to-many relationship. " +
                        ("Both " + entityMetadata.name + "#" + relation.propertyName + " and " + relation.inverseEntityMetadata.name + "#" + relation.inverseRelation.propertyName + " ") +
                        "has JoinTable decorators. Choose one of them and left JoinColumn decorator only on it.";
                    return _this;
                }
                return UsingJoinTableOnlyOnOneSideAllowedError;
            }(Error));
            exports_88("UsingJoinTableOnlyOnOneSideAllowedError", UsingJoinTableOnlyOnOneSideAllowedError);
        }
    };
});
System.register("typeorm/metadata-builder/error/UsingJoinColumnIsNotAllowedError", [], function (exports_89, context_89) {
    "use strict";
    var __moduleName = context_89 && context_89.id;
    var UsingJoinColumnIsNotAllowedError;
    return {
        setters: [],
        execute: function () {
            /**
             */
            UsingJoinColumnIsNotAllowedError = (function (_super) {
                __extends(UsingJoinColumnIsNotAllowedError, _super);
                function UsingJoinColumnIsNotAllowedError(entityMetadata, relation) {
                    var _this = _super.call(this) || this;
                    _this.name = "UsingJoinColumnIsNotAllowedError";
                    _this.message = "Using JoinColumn on " + entityMetadata.name + "#" + relation.propertyName + " is wrong. " +
                        "You can use JoinColumn only on one-to-one and many-to-one relations.";
                    return _this;
                }
                return UsingJoinColumnIsNotAllowedError;
            }(Error));
            exports_89("UsingJoinColumnIsNotAllowedError", UsingJoinColumnIsNotAllowedError);
        }
    };
});
System.register("typeorm/metadata-builder/error/UsingJoinColumnOnlyOnOneSideAllowedError", [], function (exports_90, context_90) {
    "use strict";
    var __moduleName = context_90 && context_90.id;
    var UsingJoinColumnOnlyOnOneSideAllowedError;
    return {
        setters: [],
        execute: function () {
            /**
             */
            UsingJoinColumnOnlyOnOneSideAllowedError = (function (_super) {
                __extends(UsingJoinColumnOnlyOnOneSideAllowedError, _super);
                function UsingJoinColumnOnlyOnOneSideAllowedError(entityMetadata, relation) {
                    var _this = _super.call(this) || this;
                    _this.name = "UsingJoinColumnOnlyOnOneSideAllowedError";
                    _this.message = "Using JoinColumn is allowed only on one side of the one-to-one relationship. " +
                        ("Both " + entityMetadata.name + "#" + relation.propertyName + " and " + relation.inverseEntityMetadata.name + "#" + relation.inverseRelation.propertyName + " ") +
                        "has JoinTable decorators. Choose one of them and left JoinTable decorator only on it.";
                    return _this;
                }
                return UsingJoinColumnOnlyOnOneSideAllowedError;
            }(Error));
            exports_90("UsingJoinColumnOnlyOnOneSideAllowedError", UsingJoinColumnOnlyOnOneSideAllowedError);
        }
    };
});
System.register("typeorm/metadata-builder/error/MissingJoinColumnError", [], function (exports_91, context_91) {
    "use strict";
    var __moduleName = context_91 && context_91.id;
    var MissingJoinColumnError;
    return {
        setters: [],
        execute: function () {
            /**
             */
            MissingJoinColumnError = (function (_super) {
                __extends(MissingJoinColumnError, _super);
                function MissingJoinColumnError(entityMetadata, relation) {
                    var _this = _super.call(this) || this;
                    _this.name = "MissingJoinColumnError";
                    if (relation.hasInverseSide) {
                        _this.message = "JoinColumn is missing on both sides of " + entityMetadata.name + "#" + relation.propertyName + " and " +
                            (relation.inverseEntityMetadata.name + "#" + relation.inverseRelation.propertyName + " one-to-one relationship. ") +
                            "You need to put JoinColumn decorator on one of the sides.";
                    }
                    else {
                        _this.message = "JoinColumn is missing on " + entityMetadata.name + "#" + relation.propertyName + " one-to-one relationship. " +
                            "You need to put JoinColumn decorator on it.";
                    }
                    return _this;
                }
                return MissingJoinColumnError;
            }(Error));
            exports_91("MissingJoinColumnError", MissingJoinColumnError);
        }
    };
});
System.register("typeorm/metadata-builder/error/MissingJoinTableError", [], function (exports_92, context_92) {
    "use strict";
    var __moduleName = context_92 && context_92.id;
    var MissingJoinTableError;
    return {
        setters: [],
        execute: function () {
            /**
             */
            MissingJoinTableError = (function (_super) {
                __extends(MissingJoinTableError, _super);
                function MissingJoinTableError(entityMetadata, relation) {
                    var _this = _super.call(this) || this;
                    _this.name = "MissingJoinTableError";
                    if (relation.hasInverseSide) {
                        _this.message = "JoinTable is missing on both sides of " + entityMetadata.name + "#" + relation.propertyName + " and " +
                            (relation.inverseEntityMetadata.name + "#" + relation.inverseRelation.propertyName + " many-to-many relationship. ") +
                            "You need to put decorator decorator on one of the sides.";
                    }
                    else {
                        _this.message = "JoinTable is missing on " + entityMetadata.name + "#" + relation.propertyName + " many-to-many relationship. " +
                            "You need to put JoinTable decorator on it.";
                    }
                    return _this;
                }
                return MissingJoinTableError;
            }(Error));
            exports_92("MissingJoinTableError", MissingJoinTableError);
        }
    };
});
System.register("typeorm/metadata-builder/error/MissingPrimaryColumnError", [], function (exports_93, context_93) {
    "use strict";
    var __moduleName = context_93 && context_93.id;
    var MissingPrimaryColumnError;
    return {
        setters: [],
        execute: function () {
            /**
             */
            MissingPrimaryColumnError = (function (_super) {
                __extends(MissingPrimaryColumnError, _super);
                function MissingPrimaryColumnError(entityMetadata) {
                    var _this = _super.call(this) || this;
                    _this.name = "MissingPrimaryColumnError";
                    _this.message = "Entity \"" + entityMetadata.name + "\" does not have a primary column. Primary column is required to " +
                        "have in all your entities. Use @PrimaryColumn decorator to add a primary column to your entity.";
                    return _this;
                }
                return MissingPrimaryColumnError;
            }(Error));
            exports_93("MissingPrimaryColumnError", MissingPrimaryColumnError);
        }
    };
});
System.register("typeorm/metadata-builder/error/CircularRelationsError", [], function (exports_94, context_94) {
    "use strict";
    var __moduleName = context_94 && context_94.id;
    var CircularRelationsError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown when circular relations detected with nullable set to false.
             */
            CircularRelationsError = (function (_super) {
                __extends(CircularRelationsError, _super);
                function CircularRelationsError(path) {
                    var _this = _super.call(this, "Circular relations detected: " + path + ". To resolve this issue you need to set nullable: false somewhere in this dependency structure.") || this;
                    _this.name = "CircularRelationsError";
                    return _this;
                }
                return CircularRelationsError;
            }(Error));
            exports_94("CircularRelationsError", CircularRelationsError);
        }
    };
});
/**
 * This source code is from https://github.com/jriecken/dependency-graph
 * Just added "any" types here, wrapper everything into exported class.
 * We cant use a package itself because we want to package "everything-in-it" for the frontend users of TypeORM.
 */
System.register("typeorm/util/DepGraph", [], function (exports_95, context_95) {
    "use strict";
    var __moduleName = context_95 && context_95.id;
    /**
     * A simple dependency graph
     */
    /**
     * Helper for creating a Depth-First-Search on
     * a set of edges.
     *
     * Detects cycles and throws an Error if one is detected.
     *
     * @param edges The set of edges to DFS through
     * @param leavesOnly Whether to only return "leaf" nodes (ones who have no edges)
     * @param result An array in which the results will be populated
     */
    function createDFS(edges, leavesOnly, result) {
        var currentPath = [];
        var visited = {};
        return function DFS(currentNode) {
            visited[currentNode] = true;
            currentPath.push(currentNode);
            edges[currentNode].forEach(function (node) {
                if (!visited[node]) {
                    DFS(node);
                }
                else if (currentPath.indexOf(node) >= 0) {
                    currentPath.push(node);
                    throw new Error("Dependency Cycle Found: " + currentPath.join(" -> "));
                }
            });
            currentPath.pop();
            if ((!leavesOnly || edges[currentNode].length === 0) && result.indexOf(currentNode) === -1) {
                result.push(currentNode);
            }
        };
    }
    var DepGraph;
    return {
        setters: [],
        execute: function () {/**
             * This source code is from https://github.com/jriecken/dependency-graph
             * Just added "any" types here, wrapper everything into exported class.
             * We cant use a package itself because we want to package "everything-in-it" for the frontend users of TypeORM.
             */
            DepGraph = (function () {
                function DepGraph() {
                    this.nodes = {};
                    this.outgoingEdges = {}; // Node -> [Dependency Node]
                    this.incomingEdges = {}; // Node -> [Dependant Node]
                }
                /**
                 * Add a node to the dependency graph. If a node already exists, this method will do nothing.
                 */
                DepGraph.prototype.addNode = function (node, data) {
                    if (!this.hasNode(node)) {
                        // Checking the arguments length allows the user to add a node with undefined data
                        if (arguments.length === 2) {
                            this.nodes[node] = data;
                        }
                        else {
                            this.nodes[node] = node;
                        }
                        this.outgoingEdges[node] = [];
                        this.incomingEdges[node] = [];
                    }
                };
                /**
                 * Remove a node from the dependency graph. If a node does not exist, this method will do nothing.
                 */
                DepGraph.prototype.removeNode = function (node) {
                    if (this.hasNode(node)) {
                        delete this.nodes[node];
                        delete this.outgoingEdges[node];
                        delete this.incomingEdges[node];
                        [this.incomingEdges, this.outgoingEdges].forEach(function (edgeList) {
                            Object.keys(edgeList).forEach(function (key) {
                                var idx = edgeList[key].indexOf(node);
                                if (idx >= 0) {
                                    edgeList[key].splice(idx, 1);
                                }
                            }, this);
                        });
                    }
                };
                /**
                 * Check if a node exists in the graph
                 */
                DepGraph.prototype.hasNode = function (node) {
                    return this.nodes.hasOwnProperty(node);
                };
                /**
                 * Get the data associated with a node name
                 */
                DepGraph.prototype.getNodeData = function (node) {
                    if (this.hasNode(node)) {
                        return this.nodes[node];
                    }
                    else {
                        throw new Error("Node does not exist: " + node);
                    }
                };
                /**
                 * Set the associated data for a given node name. If the node does not exist, this method will throw an error
                 */
                DepGraph.prototype.setNodeData = function (node, data) {
                    if (this.hasNode(node)) {
                        this.nodes[node] = data;
                    }
                    else {
                        throw new Error("Node does not exist: " + node);
                    }
                };
                /**
                 * Add a dependency between two nodes. If either of the nodes does not exist,
                 * an Error will be thrown.
                 */
                DepGraph.prototype.addDependency = function (from, to) {
                    if (!this.hasNode(from)) {
                        throw new Error("Node does not exist: " + from);
                    }
                    if (!this.hasNode(to)) {
                        throw new Error("Node does not exist: " + to);
                    }
                    if (this.outgoingEdges[from].indexOf(to) === -1) {
                        this.outgoingEdges[from].push(to);
                    }
                    if (this.incomingEdges[to].indexOf(from) === -1) {
                        this.incomingEdges[to].push(from);
                    }
                    return true;
                };
                /**
                 * Remove a dependency between two nodes.
                 */
                DepGraph.prototype.removeDependency = function (from, to) {
                    var idx;
                    if (this.hasNode(from)) {
                        idx = this.outgoingEdges[from].indexOf(to);
                        if (idx >= 0) {
                            this.outgoingEdges[from].splice(idx, 1);
                        }
                    }
                    if (this.hasNode(to)) {
                        idx = this.incomingEdges[to].indexOf(from);
                        if (idx >= 0) {
                            this.incomingEdges[to].splice(idx, 1);
                        }
                    }
                };
                /**
                 * Get an array containing the nodes that the specified node depends on (transitively).
                 *
                 * Throws an Error if the graph has a cycle, or the specified node does not exist.
                 *
                 * If `leavesOnly` is true, only nodes that do not depend on any other nodes will be returned
                 * in the array.
                 */
                DepGraph.prototype.dependenciesOf = function (node, leavesOnly) {
                    if (this.hasNode(node)) {
                        var result = [];
                        var DFS = createDFS(this.outgoingEdges, leavesOnly, result);
                        DFS(node);
                        var idx = result.indexOf(node);
                        if (idx >= 0) {
                            result.splice(idx, 1);
                        }
                        return result;
                    }
                    else {
                        throw new Error("Node does not exist: " + node);
                    }
                };
                /**
                 * get an array containing the nodes that depend on the specified node (transitively).
                 *
                 * Throws an Error if the graph has a cycle, or the specified node does not exist.
                 *
                 * If `leavesOnly` is true, only nodes that do not have any dependants will be returned in the array.
                 */
                DepGraph.prototype.dependantsOf = function (node, leavesOnly) {
                    if (this.hasNode(node)) {
                        var result = [];
                        var DFS = createDFS(this.incomingEdges, leavesOnly, result);
                        DFS(node);
                        var idx = result.indexOf(node);
                        if (idx >= 0) {
                            result.splice(idx, 1);
                        }
                        return result;
                    }
                    else {
                        throw new Error("Node does not exist: " + node);
                    }
                };
                /**
                 * Construct the overall processing order for the dependency graph.
                 *
                 * Throws an Error if the graph has a cycle.
                 *
                 * If `leavesOnly` is true, only nodes that do not depend on any other nodes will be returned.
                 */
                DepGraph.prototype.overallOrder = function (leavesOnly) {
                    var self = this;
                    var result = [];
                    var keys = Object.keys(this.nodes);
                    if (keys.length === 0) {
                        return result; // Empty graph
                    }
                    else {
                        // Look for cycles - we run the DFS starting at all the nodes in case there
                        // are several disconnected subgraphs inside this dependency graph.
                        var CycleDFS_1 = createDFS(this.outgoingEdges, false, []);
                        keys.forEach(function (n) {
                            CycleDFS_1(n);
                        });
                        var DFS_1 = createDFS(this.outgoingEdges, leavesOnly, result);
                        // Find all potential starting points (nodes with nothing depending on them) an
                        // run a DFS starting at these points to get the order
                        keys.filter(function (node) {
                            return self.incomingEdges[node].length === 0;
                        }).forEach(function (n) {
                            DFS_1(n);
                        });
                        return result;
                    }
                };
                return DepGraph;
            }());
            exports_95("DepGraph", DepGraph);
        }
    };
});
System.register("typeorm/metadata-builder/EntityMetadataValidator", ["typeorm/metadata-builder/error/UsingJoinTableIsNotAllowedError", "typeorm/metadata-builder/error/UsingJoinTableOnlyOnOneSideAllowedError", "typeorm/metadata-builder/error/UsingJoinColumnIsNotAllowedError", "typeorm/metadata-builder/error/UsingJoinColumnOnlyOnOneSideAllowedError", "typeorm/metadata-builder/error/MissingJoinColumnError", "typeorm/metadata-builder/error/MissingJoinTableError", "typeorm/metadata-builder/error/MissingPrimaryColumnError", "typeorm/metadata-builder/error/CircularRelationsError", "typeorm/util/DepGraph"], function (exports_96, context_96) {
    "use strict";
    var __moduleName = context_96 && context_96.id;
    var UsingJoinTableIsNotAllowedError_1, UsingJoinTableOnlyOnOneSideAllowedError_1, UsingJoinColumnIsNotAllowedError_1, UsingJoinColumnOnlyOnOneSideAllowedError_1, MissingJoinColumnError_1, MissingJoinTableError_1, MissingPrimaryColumnError_1, CircularRelationsError_1, DepGraph_1, EntityMetadataValidator;
    return {
        setters: [
            function (UsingJoinTableIsNotAllowedError_1_1) {
                UsingJoinTableIsNotAllowedError_1 = UsingJoinTableIsNotAllowedError_1_1;
            },
            function (UsingJoinTableOnlyOnOneSideAllowedError_1_1) {
                UsingJoinTableOnlyOnOneSideAllowedError_1 = UsingJoinTableOnlyOnOneSideAllowedError_1_1;
            },
            function (UsingJoinColumnIsNotAllowedError_1_1) {
                UsingJoinColumnIsNotAllowedError_1 = UsingJoinColumnIsNotAllowedError_1_1;
            },
            function (UsingJoinColumnOnlyOnOneSideAllowedError_1_1) {
                UsingJoinColumnOnlyOnOneSideAllowedError_1 = UsingJoinColumnOnlyOnOneSideAllowedError_1_1;
            },
            function (MissingJoinColumnError_1_1) {
                MissingJoinColumnError_1 = MissingJoinColumnError_1_1;
            },
            function (MissingJoinTableError_1_1) {
                MissingJoinTableError_1 = MissingJoinTableError_1_1;
            },
            function (MissingPrimaryColumnError_1_1) {
                MissingPrimaryColumnError_1 = MissingPrimaryColumnError_1_1;
            },
            function (CircularRelationsError_1_1) {
                CircularRelationsError_1 = CircularRelationsError_1_1;
            },
            function (DepGraph_1_1) {
                DepGraph_1 = DepGraph_1_1;
            }
        ],
        execute: function () {
            /// todo: add check if there are multiple tables with the same name
            /// todo: add checks when generated column / table names are too long for the specific driver
            /**
             * Validates built entity metadatas.
             */
            EntityMetadataValidator = (function () {
                function EntityMetadataValidator() {
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Validates all given entity metadatas.
                 */
                EntityMetadataValidator.prototype.validateMany = function (entityMetadatas) {
                    var _this = this;
                    entityMetadatas.forEach(function (entityMetadata) { return _this.validate(entityMetadata, entityMetadatas); });
                    this.validateDependencies(entityMetadatas);
                };
                /**
                 * Validates given entity metadata.
                 */
                EntityMetadataValidator.prototype.validate = function (entityMetadata, allEntityMetadatas) {
                    // check if table metadata has an id
                    if (!entityMetadata.table.isClassTableChild && !entityMetadata.primaryColumns.length && !entityMetadata.junction)
                        throw new MissingPrimaryColumnError_1.MissingPrimaryColumnError(entityMetadata);
                    // validate if table is using inheritance it has a discriminator
                    // also validate if discriminator values are not empty and not repeated
                    if (entityMetadata.inheritanceType === "single-table") {
                        if (!entityMetadata.hasDiscriminatorColumn)
                            throw new Error("Entity " + entityMetadata.name + " using single-table inheritance, it should also have a discriminator column. Did you forget to put @DiscriminatorColumn decorator?");
                        if (["", undefined, null].indexOf(entityMetadata.discriminatorValue) !== -1)
                            throw new Error("Entity " + entityMetadata.name + " has empty discriminator value. Discriminator value should not be empty.");
                        var sameDiscriminatorValueEntityMetadata = allEntityMetadatas.find(function (metadata) {
                            return metadata !== entityMetadata && metadata.discriminatorValue === entityMetadata.discriminatorValue;
                        });
                        if (sameDiscriminatorValueEntityMetadata)
                            throw new Error("Entities " + entityMetadata.name + " and " + sameDiscriminatorValueEntityMetadata.name + " as equal discriminator values. Make sure their discriminator values are not equal using @DiscriminatorValue decorator.");
                    }
                    // validate relations
                    entityMetadata.relations.forEach(function (relation) {
                        // check join tables:
                        // using JoinTable is possible only on one side of the many-to-many relation
                        if (relation.joinTable) {
                            if (!relation.isManyToMany)
                                throw new UsingJoinTableIsNotAllowedError_1.UsingJoinTableIsNotAllowedError(entityMetadata, relation);
                            // if there is inverse side of the relation, then check if it does not have join table too
                            if (relation.hasInverseSide && relation.inverseRelation.joinTable)
                                throw new UsingJoinTableOnlyOnOneSideAllowedError_1.UsingJoinTableOnlyOnOneSideAllowedError(entityMetadata, relation);
                        }
                        // check join columns:
                        // using JoinColumn is possible only on one side of the relation and on one-to-one, many-to-one relation types
                        // first check if relation is one-to-one or many-to-one
                        if (relation.joinColumn) {
                            // join column can be applied only on one-to-one and many-to-one relations
                            if (!relation.isOneToOne && !relation.isManyToOne)
                                throw new UsingJoinColumnIsNotAllowedError_1.UsingJoinColumnIsNotAllowedError(entityMetadata, relation);
                            // if there is inverse side of the relation, then check if it does not have join table too
                            if (relation.hasInverseSide && relation.inverseRelation.joinColumn && relation.isOneToOne)
                                throw new UsingJoinColumnOnlyOnOneSideAllowedError_1.UsingJoinColumnOnlyOnOneSideAllowedError(entityMetadata, relation);
                            // check if join column really has referenced column
                            if (relation.joinColumn && !relation.joinColumn.referencedColumn)
                                throw new Error("Join column does not have referenced column set");
                        }
                        // if its a one-to-one relation and JoinColumn is missing on both sides of the relation
                        // or its one-side relation without JoinColumn we should give an error
                        if (!relation.joinColumn && relation.isOneToOne && (!relation.hasInverseSide || !relation.inverseRelation.joinColumn))
                            throw new MissingJoinColumnError_1.MissingJoinColumnError(entityMetadata, relation);
                        // if its a many-to-many relation and JoinTable is missing on both sides of the relation
                        // or its one-side relation without JoinTable we should give an error
                        if (!relation.joinTable && relation.isManyToMany && (!relation.hasInverseSide || !relation.inverseRelation.joinTable))
                            throw new MissingJoinTableError_1.MissingJoinTableError(entityMetadata, relation);
                        // todo: validate if its one-to-one and side which does not have join column MUST have inverse side
                        // todo: validate if its many-to-many and side which does not have join table MUST have inverse side
                        // todo: if there is a relation, and inverse side is specified only on one side, shall we give error
                        // todo: with message like: "Inverse side is specified only on one side of the relationship. Specify on other side too to prevent confusion".
                        // todo: add validation if there two entities with the same target, and show error message with description of the problem (maybe file was renamed/moved but left in output directory)
                        // todo: check if there are multiple columns on the same column applied.
                    });
                    // make sure cascade remove is not set for both sides of relationships (can be set in OneToOne decorators)
                    entityMetadata.relations.forEach(function (relation) {
                        var isCircularCascadeRemove = relation.isCascadeRemove && relation.hasInverseSide && relation.inverseRelation.isCascadeRemove;
                        if (isCircularCascadeRemove)
                            throw new Error("Relation " + entityMetadata.name + "#" + relation.propertyName + " and " + relation.inverseRelation.entityMetadata.name + "#" + relation.inverseRelation.propertyName + " both has cascade remove set. " +
                                "This may lead to unexpected circular removals. Please set cascade remove only from one side of relationship.");
                    }); // todo: maybe better just deny removal from one to one relation without join column?
                };
                /**
                 * Validates dependencies of the entity metadatas.
                 */
                EntityMetadataValidator.prototype.validateDependencies = function (entityMetadatas) {
                    var graph = new DepGraph_1.DepGraph();
                    entityMetadatas.forEach(function (entityMetadata) {
                        graph.addNode(entityMetadata.name);
                    });
                    entityMetadatas.forEach(function (entityMetadata) {
                        entityMetadata.relationsWithJoinColumns
                            .filter(function (relation) { return !relation.isNullable; })
                            .forEach(function (relation) {
                            graph.addDependency(entityMetadata.name, relation.inverseEntityMetadata.name);
                        });
                    });
                    try {
                        graph.overallOrder();
                    }
                    catch (err) {
                        throw new CircularRelationsError_1.CircularRelationsError(err.toString().replace("Error: Dependency Cycle Found: ", ""));
                    }
                };
                return EntityMetadataValidator;
            }());
            exports_96("EntityMetadataValidator", EntityMetadataValidator);
        }
    };
});
System.register("typeorm/metadata-builder/JunctionEntityMetadataBuilder", ["typeorm/metadata/ColumnMetadata", "typeorm/metadata/ForeignKeyMetadata", "typeorm/metadata/TableMetadata", "typeorm/metadata/IndexMetadata", "typeorm/metadata/EntityMetadata"], function (exports_97, context_97) {
    "use strict";
    var __moduleName = context_97 && context_97.id;
    var ColumnMetadata_1, ForeignKeyMetadata_1, TableMetadata_1, IndexMetadata_1, EntityMetadata_1, JunctionEntityMetadataBuilder;
    return {
        setters: [
            function (ColumnMetadata_1_1) {
                ColumnMetadata_1 = ColumnMetadata_1_1;
            },
            function (ForeignKeyMetadata_1_1) {
                ForeignKeyMetadata_1 = ForeignKeyMetadata_1_1;
            },
            function (TableMetadata_1_1) {
                TableMetadata_1 = TableMetadata_1_1;
            },
            function (IndexMetadata_1_1) {
                IndexMetadata_1 = IndexMetadata_1_1;
            },
            function (EntityMetadata_1_1) {
                EntityMetadata_1 = EntityMetadata_1_1;
            }
        ],
        execute: function () {
            /**
             * Helps to create EntityMetadatas for junction tables.
             */
            JunctionEntityMetadataBuilder = (function () {
                function JunctionEntityMetadataBuilder() {
                }
                JunctionEntityMetadataBuilder.prototype.build = function (driver, lazyRelationsWrapper, args) {
                    var column1 = args.joinTable.referencedColumn;
                    var column2 = args.joinTable.inverseReferencedColumn;
                    var tableMetadata = new TableMetadata_1.TableMetadata({
                        target: "",
                        name: args.joinTable.name,
                        type: "junction"
                    });
                    var junctionColumn1 = new ColumnMetadata_1.ColumnMetadata({
                        target: "__virtual__",
                        // propertyType: column1.type,
                        propertyName: args.joinTable.joinColumnName,
                        mode: "virtual",
                        options: {
                            length: column1.length,
                            type: column1.type,
                            name: args.joinTable.joinColumnName,
                            nullable: false,
                            primary: true
                        }
                    });
                    var junctionColumn2 = new ColumnMetadata_1.ColumnMetadata({
                        target: "__virtual__",
                        // propertyType: column2.type,
                        propertyName: args.joinTable.inverseJoinColumnName,
                        mode: "virtual",
                        options: {
                            length: column2.length,
                            type: column2.type,
                            name: args.joinTable.inverseJoinColumnName,
                            nullable: false,
                            primary: true
                        }
                    });
                    var entityMetadata = new EntityMetadata_1.EntityMetadata({
                        junction: true,
                        target: "__virtual__",
                        tablesPrefix: driver.options.tablesPrefix,
                        namingStrategy: args.namingStrategy,
                        tableMetadata: tableMetadata,
                        columnMetadatas: [
                            junctionColumn1,
                            junctionColumn2
                        ],
                        foreignKeyMetadatas: [
                            new ForeignKeyMetadata_1.ForeignKeyMetadata([junctionColumn1], args.firstTable, [column1]),
                            new ForeignKeyMetadata_1.ForeignKeyMetadata([junctionColumn2], args.secondTable, [column2])
                        ],
                        indexMetadatas: [
                            new IndexMetadata_1.IndexMetadata({ columns: [args.joinTable.joinColumnName], unique: false }),
                            new IndexMetadata_1.IndexMetadata({ columns: [args.joinTable.inverseJoinColumnName], unique: false })
                        ]
                    }, lazyRelationsWrapper);
                    entityMetadata.columns[0].entityMetadata = entityMetadata;
                    entityMetadata.columns[1].entityMetadata = entityMetadata;
                    return entityMetadata;
                };
                return JunctionEntityMetadataBuilder;
            }());
            exports_97("JunctionEntityMetadataBuilder", JunctionEntityMetadataBuilder);
        }
    };
});
System.register("typeorm/metadata-builder/ClosureJunctionEntityMetadataBuilder", ["typeorm/metadata/EntityMetadata", "typeorm/metadata/ColumnMetadata", "typeorm/metadata/ForeignKeyMetadata", "typeorm/metadata/TableMetadata", "typeorm/metadata/types/ColumnTypes"], function (exports_98, context_98) {
    "use strict";
    var __moduleName = context_98 && context_98.id;
    var EntityMetadata_2, ColumnMetadata_2, ForeignKeyMetadata_2, TableMetadata_2, ColumnTypes_3, ClosureJunctionEntityMetadataBuilder;
    return {
        setters: [
            function (EntityMetadata_2_1) {
                EntityMetadata_2 = EntityMetadata_2_1;
            },
            function (ColumnMetadata_2_1) {
                ColumnMetadata_2 = ColumnMetadata_2_1;
            },
            function (ForeignKeyMetadata_2_1) {
                ForeignKeyMetadata_2 = ForeignKeyMetadata_2_1;
            },
            function (TableMetadata_2_1) {
                TableMetadata_2 = TableMetadata_2_1;
            },
            function (ColumnTypes_3_1) {
                ColumnTypes_3 = ColumnTypes_3_1;
            }
        ],
        execute: function () {
            /**
             * Helps to create EntityMetadatas for junction tables for closure tables.
             */
            ClosureJunctionEntityMetadataBuilder = (function () {
                function ClosureJunctionEntityMetadataBuilder() {
                }
                ClosureJunctionEntityMetadataBuilder.prototype.build = function (driver, lazyRelationsWrapper, args) {
                    var columns = [
                        new ColumnMetadata_2.ColumnMetadata({
                            target: "__virtual__",
                            propertyName: "__virtual__",
                            propertyType: args.primaryColumn.type,
                            mode: "virtual",
                            options: {
                                length: args.primaryColumn.length,
                                type: args.primaryColumn.type,
                                name: "ancestor"
                            }
                        }),
                        new ColumnMetadata_2.ColumnMetadata({
                            target: "__virtual__",
                            propertyName: "__virtual__",
                            propertyType: args.primaryColumn.type,
                            mode: "virtual",
                            options: {
                                length: args.primaryColumn.length,
                                type: args.primaryColumn.type,
                                name: "descendant"
                            }
                        })
                    ];
                    if (args.hasTreeLevelColumn) {
                        columns.push(new ColumnMetadata_2.ColumnMetadata({
                            target: "__virtual__",
                            propertyName: "__virtual__",
                            propertyType: ColumnTypes_3.ColumnTypes.INTEGER,
                            mode: "virtual",
                            options: {
                                type: ColumnTypes_3.ColumnTypes.INTEGER,
                                name: "level"
                            }
                        }));
                    }
                    var closureJunctionTableMetadata = new TableMetadata_2.TableMetadata({
                        target: "__virtual__",
                        name: args.table.name,
                        type: "closure-junction"
                    });
                    return new EntityMetadata_2.EntityMetadata({
                        junction: true,
                        target: "__virtual__",
                        tablesPrefix: driver.options.tablesPrefix,
                        namingStrategy: args.namingStrategy,
                        tableMetadata: closureJunctionTableMetadata,
                        columnMetadatas: columns,
                        foreignKeyMetadatas: [
                            new ForeignKeyMetadata_2.ForeignKeyMetadata([columns[0]], args.table, [args.primaryColumn]),
                            new ForeignKeyMetadata_2.ForeignKeyMetadata([columns[1]], args.table, [args.primaryColumn])
                        ]
                    }, lazyRelationsWrapper);
                };
                return ClosureJunctionEntityMetadataBuilder;
            }());
            exports_98("ClosureJunctionEntityMetadataBuilder", ClosureJunctionEntityMetadataBuilder);
        }
    };
});
System.register("typeorm/entity-schema/EntitySchema", [], function (exports_99, context_99) {
    "use strict";
    var __moduleName = context_99 && context_99.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/metadata-builder/error/MetadataAlreadyExistsError", [], function (exports_100, context_100) {
    "use strict";
    var __moduleName = context_100 && context_100.id;
    var MetadataAlreadyExistsError;
    return {
        setters: [],
        execute: function () {
            /**
             */
            MetadataAlreadyExistsError = (function (_super) {
                __extends(MetadataAlreadyExistsError, _super);
                function MetadataAlreadyExistsError(metadataType, constructor, propertyName) {
                    var _this = _super.call(this) || this;
                    _this.name = "MetadataAlreadyExistsError";
                    _this.message = metadataType + " metadata already exists for the class constructor " + JSON.stringify(constructor) +
                        (propertyName ? " on property " + propertyName : ". If you previously renamed or moved entity class, make sure" +
                            " that compiled version of old entity class source wasn't left in the compiler output directory.");
                    return _this;
                }
                return MetadataAlreadyExistsError;
            }(Error));
            exports_100("MetadataAlreadyExistsError", MetadataAlreadyExistsError);
        }
    };
});
System.register("typeorm/metadata-args/collection/TargetMetadataArgsCollection", ["typeorm/metadata-builder/error/MetadataAlreadyExistsError"], function (exports_101, context_101) {
    "use strict";
    var __moduleName = context_101 && context_101.id;
    var MetadataAlreadyExistsError_1, TargetMetadataArgsCollection;
    return {
        setters: [
            function (MetadataAlreadyExistsError_1_1) {
                MetadataAlreadyExistsError_1 = MetadataAlreadyExistsError_1_1;
            }
        ],
        execute: function () {
            TargetMetadataArgsCollection = (function () {
                function TargetMetadataArgsCollection() {
                    // -------------------------------------------------------------------------
                    // Protected Properties
                    // -------------------------------------------------------------------------
                    this.items = [];
                }
                Object.defineProperty(TargetMetadataArgsCollection.prototype, "length", {
                    // -------------------------------------------------------------------------
                    // Public Properties
                    // -------------------------------------------------------------------------
                    get: function () {
                        return this.items.length;
                    },
                    enumerable: true,
                    configurable: true
                });
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                TargetMetadataArgsCollection.prototype.filter = function (callbackfn, thisArg) {
                    var collection = new this.constructor();
                    this.items.filter(callbackfn).forEach(function (metadata) { return collection.add(metadata); });
                    return collection;
                };
                TargetMetadataArgsCollection.prototype.filterByTarget = function (cls) {
                    // if no class specified then simply return empty collection
                    if (!cls)
                        return new this.constructor();
                    return this.filterByTargets([cls]);
                };
                TargetMetadataArgsCollection.prototype.filterByTargets = function (classes) {
                    return this.filter(function (metadata) {
                        if (!metadata.target)
                            return false;
                        return classes.indexOf(metadata.target) !== -1;
                    });
                };
                TargetMetadataArgsCollection.prototype.add = function (metadata, checkForDuplicateTargets) {
                    if (checkForDuplicateTargets === void 0) { checkForDuplicateTargets = false; }
                    if (checkForDuplicateTargets) {
                        if (!metadata.target || !(metadata.target instanceof Function))
                            throw new Error("Target is not set in the given metadata.");
                        if (this.hasWithTarget(metadata.target))
                            throw new MetadataAlreadyExistsError_1.MetadataAlreadyExistsError(metadata.constructor.name, metadata.target);
                    }
                    this.items.push(metadata);
                };
                TargetMetadataArgsCollection.prototype.toArray = function () {
                    return this.items.map(function (item) { return item; });
                };
                // -------------------------------------------------------------------------
                // Private Methods
                // -------------------------------------------------------------------------
                TargetMetadataArgsCollection.prototype.hasWithTarget = function (constructor) {
                    return !!this.items.find(function (metadata) { return metadata.target === constructor; });
                };
                return TargetMetadataArgsCollection;
            }());
            exports_101("TargetMetadataArgsCollection", TargetMetadataArgsCollection);
        }
    };
});
System.register("typeorm/metadata-args/collection/PropertyMetadataArgsCollection", ["typeorm/metadata-args/collection/TargetMetadataArgsCollection"], function (exports_102, context_102) {
    "use strict";
    var __moduleName = context_102 && context_102.id;
    var TargetMetadataArgsCollection_1, PropertyMetadataArgsCollection;
    return {
        setters: [
            function (TargetMetadataArgsCollection_1_1) {
                TargetMetadataArgsCollection_1 = TargetMetadataArgsCollection_1_1;
            }
        ],
        execute: function () {
            PropertyMetadataArgsCollection = (function (_super) {
                __extends(PropertyMetadataArgsCollection, _super);
                function PropertyMetadataArgsCollection() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                PropertyMetadataArgsCollection.prototype.filterRepeatedMetadatas = function (existsMetadatas) {
                    return this.filter(function (metadata) {
                        return !existsMetadatas.find(function (fieldFromDocument) { return fieldFromDocument.propertyName === metadata.propertyName; });
                    });
                };
                PropertyMetadataArgsCollection.prototype.findByProperty = function (propertyName) {
                    return this.items.find(function (item) { return item.propertyName === propertyName; });
                };
                PropertyMetadataArgsCollection.prototype.hasWithProperty = function (propertyName) {
                    return !!this.findByProperty(propertyName);
                };
                return PropertyMetadataArgsCollection;
            }(TargetMetadataArgsCollection_1.TargetMetadataArgsCollection));
            exports_102("PropertyMetadataArgsCollection", PropertyMetadataArgsCollection);
        }
    };
});
System.register("typeorm/metadata-args/RelationCountMetadataArgs", [], function (exports_103, context_103) {
    "use strict";
    var __moduleName = context_103 && context_103.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/metadata-args/NamingStrategyMetadataArgs", [], function (exports_104, context_104) {
    "use strict";
    var __moduleName = context_104 && context_104.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/metadata-args/EmbeddedMetadataArgs", [], function (exports_105, context_105) {
    "use strict";
    var __moduleName = context_105 && context_105.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/metadata-args/EntitySubscriberMetadataArgs", [], function (exports_106, context_106) {
    "use strict";
    var __moduleName = context_106 && context_106.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/metadata-args/RelationIdMetadataArgs", [], function (exports_107, context_107) {
    "use strict";
    var __moduleName = context_107 && context_107.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/metadata-args/InheritanceMetadataArgs", [], function (exports_108, context_108) {
    "use strict";
    var __moduleName = context_108 && context_108.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/metadata-args/DiscriminatorValueMetadataArgs", [], function (exports_109, context_109) {
    "use strict";
    var __moduleName = context_109 && context_109.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/metadata-args/EntityRepositoryMetadataArgs", [], function (exports_110, context_110) {
    "use strict";
    var __moduleName = context_110 && context_110.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/metadata-args/TransactionEntityMetadataArgs", [], function (exports_111, context_111) {
    "use strict";
    var __moduleName = context_111 && context_111.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/metadata-args/MetadataArgsStorage", ["typeorm/metadata-args/collection/TargetMetadataArgsCollection", "typeorm/metadata-args/collection/PropertyMetadataArgsCollection"], function (exports_112, context_112) {
    "use strict";
    var __moduleName = context_112 && context_112.id;
    var TargetMetadataArgsCollection_2, PropertyMetadataArgsCollection_1, MetadataArgsStorage;
    return {
        setters: [
            function (TargetMetadataArgsCollection_2_1) {
                TargetMetadataArgsCollection_2 = TargetMetadataArgsCollection_2_1;
            },
            function (PropertyMetadataArgsCollection_1_1) {
                PropertyMetadataArgsCollection_1 = PropertyMetadataArgsCollection_1_1;
            }
        ],
        execute: function () {
            /**
             * Storage all metadatas of all available types: tables, fields, subscribers, relations, etc.
             * Each metadata represents some specifications of what it represents.
             */
            MetadataArgsStorage = (function () {
                function MetadataArgsStorage() {
                    // todo: type in function validation, inverse side function validation
                    // todo: check on build for duplicate names, since naming checking was removed from MetadataStorage
                    // todo: duplicate name checking for: table, relation, column, index, naming strategy, join tables/columns?
                    // todo: check for duplicate targets too since this check has been removed too
                    // -------------------------------------------------------------------------
                    // Properties
                    // -------------------------------------------------------------------------
                    this.tables = new TargetMetadataArgsCollection_2.TargetMetadataArgsCollection();
                    this.entityRepositories = new TargetMetadataArgsCollection_2.TargetMetadataArgsCollection();
                    this.transactionEntityManagers = new TargetMetadataArgsCollection_2.TargetMetadataArgsCollection();
                    this.namingStrategies = new TargetMetadataArgsCollection_2.TargetMetadataArgsCollection();
                    this.entitySubscribers = new TargetMetadataArgsCollection_2.TargetMetadataArgsCollection();
                    this.indices = new PropertyMetadataArgsCollection_1.PropertyMetadataArgsCollection();
                    this.columns = new PropertyMetadataArgsCollection_1.PropertyMetadataArgsCollection();
                    this.relations = new PropertyMetadataArgsCollection_1.PropertyMetadataArgsCollection();
                    this.joinColumns = new PropertyMetadataArgsCollection_1.PropertyMetadataArgsCollection();
                    this.joinTables = new PropertyMetadataArgsCollection_1.PropertyMetadataArgsCollection();
                    this.entityListeners = new PropertyMetadataArgsCollection_1.PropertyMetadataArgsCollection();
                    this.relationCounts = new PropertyMetadataArgsCollection_1.PropertyMetadataArgsCollection();
                    this.relationIds = new PropertyMetadataArgsCollection_1.PropertyMetadataArgsCollection();
                    this.embeddeds = new PropertyMetadataArgsCollection_1.PropertyMetadataArgsCollection();
                    this.inheritances = new TargetMetadataArgsCollection_2.TargetMetadataArgsCollection();
                    this.discriminatorValues = new TargetMetadataArgsCollection_2.TargetMetadataArgsCollection();
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Gets merged (with all abstract classes) table metadatas for the given classes.
                 */
                MetadataArgsStorage.prototype.getMergedTableMetadatas = function (classes) {
                    var _this = this;
                    var allTableMetadataArgs = classes ? this.tables.filterByTargets(classes) : this.tables;
                    var tableMetadatas = allTableMetadataArgs.filter(function (table) { return table.type === "regular" || table.type === "closure" || table.type === "class-table-child"; });
                    return tableMetadatas.toArray().map(function (tableMetadata) {
                        return _this.mergeWithAbstract(allTableMetadataArgs, tableMetadata);
                    });
                };
                /**
                 * Gets merged (with all abstract classes) embeddable table metadatas for the given classes.
                 */
                MetadataArgsStorage.prototype.getMergedEmbeddableTableMetadatas = function (classes) {
                    var _this = this;
                    var tables = classes ? this.tables.filterByTargets(classes) : this.tables;
                    var embeddableTableMetadatas = tables.filter(function (table) { return table.type === "embeddable"; });
                    return embeddableTableMetadatas.toArray().map(function (embeddableTableMetadata) {
                        return _this.mergeWithEmbeddable(embeddableTableMetadatas, embeddableTableMetadata);
                    });
                };
                // -------------------------------------------------------------------------
                // Private Methods
                // -------------------------------------------------------------------------
                /**
                 */
                MetadataArgsStorage.prototype.mergeWithAbstract = function (allTableMetadatas, table) {
                    var _this = this;
                    var indices = this.indices.filterByTarget(table.target);
                    var columns = this.columns.filterByTarget(table.target);
                    var relations = this.relations.filterByTarget(table.target);
                    var joinColumns = this.joinColumns.filterByTarget(table.target);
                    var joinTables = this.joinTables.filterByTarget(table.target);
                    var entityListeners = this.entityListeners.filterByTarget(table.target);
                    var relationCounts = this.relationCounts.filterByTarget(table.target);
                    var relationIds = this.relationIds.filterByTarget(table.target);
                    var embeddeds = this.embeddeds.filterByTarget(table.target);
                    var inheritances = this.inheritances.filterByTarget(table.target);
                    var inheritance = (inheritances.length > 0) ? inheritances.toArray()[0] : undefined;
                    var discriminatorValues = [];
                    // find parent if this table is class-table-child
                    var parent = undefined;
                    // merge metadata from abstract tables
                    allTableMetadatas.toArray().forEach(function (inheritedTable) {
                        if (table.type === "single-table-child")
                            return;
                        if (!table.target || !inheritedTable.target)
                            return;
                        if (!(table.target instanceof Function) || !(inheritedTable.target instanceof Function))
                            return;
                        if (!_this.isInherited(table.target, inheritedTable.target))
                            return;
                        // check if inheritedTable is a class with class table inheritance - then we don't need to merge its columns, relations, etc. things
                        if (!!_this.inheritances.filterByTarget(inheritedTable.target).toArray().find(function (inheritance) { return inheritance.type === "class-table"; })) {
                            parent = inheritedTable;
                            return;
                        }
                        var metadatasFromAbstract = _this.mergeWithAbstract(allTableMetadatas, inheritedTable);
                        metadatasFromAbstract.indices
                            .toArray()
                            .filter(function (index) {
                            return !index.name || !indices.toArray().find(function (existIndex) { return existIndex.name === index.name; });
                        })
                            .forEach(function (index) { return indices.add(index); });
                        metadatasFromAbstract.columns
                            .filterRepeatedMetadatas(columns.toArray())
                            .toArray()
                            .forEach(function (metadata) { return columns.add(metadata); });
                        metadatasFromAbstract.relations
                            .filterRepeatedMetadatas(relations.toArray())
                            .toArray()
                            .forEach(function (metadata) { return relations.add(metadata); });
                        metadatasFromAbstract.joinColumns
                            .filterRepeatedMetadatas(joinColumns.toArray())
                            .toArray()
                            .forEach(function (metadata) { return joinColumns.add(metadata); });
                        metadatasFromAbstract.joinTables
                            .filterRepeatedMetadatas(joinTables.toArray())
                            .toArray()
                            .forEach(function (metadata) { return joinTables.add(metadata); });
                        metadatasFromAbstract.entityListeners
                            .filterRepeatedMetadatas(entityListeners.toArray())
                            .toArray()
                            .forEach(function (metadata) { return entityListeners.add(metadata); });
                        metadatasFromAbstract.relationCounts
                            .filterRepeatedMetadatas(relationCounts.toArray())
                            .toArray()
                            .forEach(function (metadata) { return relationCounts.add(metadata); });
                        metadatasFromAbstract.relationIds
                            .filterRepeatedMetadatas(relationIds.toArray())
                            .toArray()
                            .forEach(function (metadata) { return relationIds.add(metadata); });
                        metadatasFromAbstract.embeddeds
                            .filterRepeatedMetadatas(embeddeds.toArray())
                            .toArray()
                            .forEach(function (metadata) { return embeddeds.add(metadata); });
                    });
                    // merge metadata from child tables for single-table inheritance
                    var children = [];
                    if (inheritance && inheritance.type === "single-table") {
                        allTableMetadatas.toArray().forEach(function (childTable) {
                            if (childTable.type !== "single-table-child")
                                return;
                            if (!childTable.target || !table.target)
                                return;
                            if (!(childTable.target instanceof Function) || !(table.target instanceof Function))
                                return;
                            if (!_this.isInherited(childTable.target, table.target))
                                return;
                            children.push(childTable);
                            _this.discriminatorValues
                                .filterByTarget(childTable.target)
                                .toArray()
                                .forEach(function (metadata) { return discriminatorValues.push(metadata); });
                            // for single table inheritance we also merge all columns, relation, etc. into same table
                            if (inheritance.type === "single-table") {
                                var metadatasFromAbstract = _this.mergeWithAbstract(allTableMetadatas, childTable);
                                metadatasFromAbstract.indices
                                    .toArray()
                                    .filter(function (index) {
                                    return !indices.toArray().find(function (existIndex) { return existIndex.name === index.name; });
                                })
                                    .forEach(function (index) { return indices.add(index); });
                                metadatasFromAbstract.columns
                                    .filterRepeatedMetadatas(columns.toArray())
                                    .toArray()
                                    .forEach(function (metadata) { return columns.add(metadata); });
                                metadatasFromAbstract.relations
                                    .filterRepeatedMetadatas(relations.toArray())
                                    .toArray()
                                    .forEach(function (metadata) { return relations.add(metadata); });
                                metadatasFromAbstract.joinColumns
                                    .filterRepeatedMetadatas(joinColumns.toArray())
                                    .toArray()
                                    .forEach(function (metadata) { return joinColumns.add(metadata); });
                                metadatasFromAbstract.joinTables
                                    .filterRepeatedMetadatas(joinTables.toArray())
                                    .toArray()
                                    .forEach(function (metadata) { return joinTables.add(metadata); });
                                metadatasFromAbstract.entityListeners
                                    .filterRepeatedMetadatas(entityListeners.toArray())
                                    .toArray()
                                    .forEach(function (metadata) { return entityListeners.add(metadata); });
                                metadatasFromAbstract.relationCounts
                                    .filterRepeatedMetadatas(relationCounts.toArray())
                                    .toArray()
                                    .forEach(function (metadata) { return relationCounts.add(metadata); });
                                metadatasFromAbstract.relationIds
                                    .filterRepeatedMetadatas(relationIds.toArray())
                                    .toArray()
                                    .forEach(function (metadata) { return relationIds.add(metadata); });
                                metadatasFromAbstract.embeddeds
                                    .filterRepeatedMetadatas(embeddeds.toArray())
                                    .toArray()
                                    .forEach(function (metadata) { return embeddeds.add(metadata); });
                                metadatasFromAbstract.children
                                    .forEach(function (metadata) { return children.push(metadata); });
                            }
                        });
                    }
                    return {
                        table: table,
                        parent: parent,
                        inheritance: inheritance,
                        children: children,
                        indices: indices,
                        columns: columns,
                        relations: relations,
                        joinColumns: joinColumns,
                        joinTables: joinTables,
                        entityListeners: entityListeners,
                        relationCounts: relationCounts,
                        relationIds: relationIds,
                        embeddeds: embeddeds,
                        discriminatorValues: discriminatorValues
                    };
                };
                /**
                 */
                MetadataArgsStorage.prototype.mergeWithEmbeddable = function (allTableMetadatas, tableMetadata) {
                    var _this = this;
                    var columns = this.columns.filterByTarget(tableMetadata.target);
                    allTableMetadatas
                        .filter(function (metadata) {
                        if (!tableMetadata.target || !metadata.target)
                            return false;
                        if (!(tableMetadata.target instanceof Function) || !(metadata.target instanceof Function))
                            return false;
                        return _this.isInherited(tableMetadata.target, metadata.target); // todo: fix it for entity schema
                    })
                        .toArray()
                        .forEach(function (parentMetadata) {
                        var metadatasFromParents = _this.mergeWithEmbeddable(allTableMetadatas, parentMetadata);
                        metadatasFromParents.columns
                            .filterRepeatedMetadatas(columns.toArray())
                            .toArray()
                            .forEach(function (metadata) { return columns.add(metadata); });
                    });
                    return {
                        table: tableMetadata,
                        columns: columns
                    };
                };
                /**
                 * Checks if this table is inherited from another table.
                 */
                MetadataArgsStorage.prototype.isInherited = function (target1, target2) {
                    // we cannot use instanceOf in this method, because we need order of inherited tables, to ensure that
                    // properties get inherited in a right order. To achieve it we can only check a first parent of the class
                    // return this.target.prototype instanceof anotherTable.target;
                    return Object.getPrototypeOf(target1.prototype).constructor === target2;
                };
                return MetadataArgsStorage;
            }());
            exports_112("MetadataArgsStorage", MetadataArgsStorage);
        }
    };
});
System.register("typeorm/metadata-builder/EntityMetadataBuilder", ["typeorm/metadata/EntityMetadata", "typeorm/metadata/ColumnMetadata", "typeorm/metadata/ForeignKeyMetadata", "typeorm/metadata-builder/EntityMetadataValidator", "typeorm/metadata/IndexMetadata", "typeorm/metadata/JoinColumnMetadata", "typeorm/metadata/TableMetadata", "typeorm/index", "typeorm/metadata/RelationMetadata", "typeorm/metadata/JoinTableMetadata", "typeorm/metadata-builder/JunctionEntityMetadataBuilder", "typeorm/metadata-builder/ClosureJunctionEntityMetadataBuilder", "typeorm/metadata/EmbeddedMetadata", "typeorm/metadata-args/MetadataArgsStorage"], function (exports_113, context_113) {
    "use strict";
    var __moduleName = context_113 && context_113.id;
    var EntityMetadata_3, ColumnMetadata_3, ForeignKeyMetadata_3, EntityMetadataValidator_1, IndexMetadata_2, JoinColumnMetadata_1, TableMetadata_3, index_2, RelationMetadata_2, JoinTableMetadata_1, JunctionEntityMetadataBuilder_1, ClosureJunctionEntityMetadataBuilder_1, EmbeddedMetadata_1, MetadataArgsStorage_1, EntityMetadataBuilder;
    return {
        setters: [
            function (EntityMetadata_3_1) {
                EntityMetadata_3 = EntityMetadata_3_1;
            },
            function (ColumnMetadata_3_1) {
                ColumnMetadata_3 = ColumnMetadata_3_1;
            },
            function (ForeignKeyMetadata_3_1) {
                ForeignKeyMetadata_3 = ForeignKeyMetadata_3_1;
            },
            function (EntityMetadataValidator_1_1) {
                EntityMetadataValidator_1 = EntityMetadataValidator_1_1;
            },
            function (IndexMetadata_2_1) {
                IndexMetadata_2 = IndexMetadata_2_1;
            },
            function (JoinColumnMetadata_1_1) {
                JoinColumnMetadata_1 = JoinColumnMetadata_1_1;
            },
            function (TableMetadata_3_1) {
                TableMetadata_3 = TableMetadata_3_1;
            },
            function (index_2_1) {
                index_2 = index_2_1;
            },
            function (RelationMetadata_2_1) {
                RelationMetadata_2 = RelationMetadata_2_1;
            },
            function (JoinTableMetadata_1_1) {
                JoinTableMetadata_1 = JoinTableMetadata_1_1;
            },
            function (JunctionEntityMetadataBuilder_1_1) {
                JunctionEntityMetadataBuilder_1 = JunctionEntityMetadataBuilder_1_1;
            },
            function (ClosureJunctionEntityMetadataBuilder_1_1) {
                ClosureJunctionEntityMetadataBuilder_1 = ClosureJunctionEntityMetadataBuilder_1_1;
            },
            function (EmbeddedMetadata_1_1) {
                EmbeddedMetadata_1 = EmbeddedMetadata_1_1;
            },
            function (MetadataArgsStorage_1_1) {
                MetadataArgsStorage_1 = MetadataArgsStorage_1_1;
            }
        ],
        execute: function () {
            /**
             * Aggregates all metadata: table, column, relation into one collection grouped by tables for a given set of classes.
             */
            EntityMetadataBuilder = (function () {
                function EntityMetadataBuilder() {
                }
                // todo: type in function validation, inverse side function validation
                // todo: check on build for duplicate names, since naming checking was removed from MetadataStorage
                // todo: duplicate name checking for: table, relation, column, index, naming strategy, join tables/columns?
                // todo: check if multiple tree parent metadatas in validator
                // todo: tree decorators can be used only on closure table (validation)
                // todo: throw error if parent tree metadata was not specified in a closure table
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                EntityMetadataBuilder.prototype.buildFromSchemas = function (driver, lazyRelationsWrapper, namingStrategy, schemas) {
                    var metadataArgsStorage = new MetadataArgsStorage_1.MetadataArgsStorage();
                    // extract into separate class?
                    schemas.forEach(function (schema) {
                        // add table metadata args from the schema
                        var tableSchema = schema.table || {};
                        var table = {
                            target: schema.target || schema.name,
                            name: tableSchema.name,
                            type: tableSchema.type || "regular",
                            // targetId: schema.name,
                            orderBy: tableSchema.orderBy
                        };
                        metadataArgsStorage.tables.add(table);
                        // add columns metadata args from the schema
                        Object.keys(schema.columns).forEach(function (columnName) {
                            var columnSchema = schema.columns[columnName];
                            var mode = "regular";
                            if (columnSchema.createDate)
                                mode = "createDate";
                            if (columnSchema.updateDate)
                                mode = "updateDate";
                            if (columnSchema.version)
                                mode = "version";
                            if (columnSchema.treeChildrenCount)
                                mode = "treeChildrenCount";
                            if (columnSchema.treeLevel)
                                mode = "treeLevel";
                            var column = {
                                target: schema.target || schema.name,
                                mode: mode,
                                propertyName: columnName,
                                // todo: what to do with it?: propertyType: 
                                options: {
                                    type: columnSchema.type,
                                    name: columnSchema.name,
                                    length: columnSchema.length,
                                    primary: columnSchema.primary,
                                    generated: columnSchema.generated,
                                    unique: columnSchema.unique,
                                    nullable: columnSchema.nullable,
                                    comment: columnSchema.comment,
                                    default: columnSchema.default,
                                    precision: columnSchema.precision,
                                    scale: columnSchema.scale
                                }
                            };
                            metadataArgsStorage.columns.add(column);
                        });
                        // add relation metadata args from the schema
                        if (schema.relations) {
                            Object.keys(schema.relations).forEach(function (relationName) {
                                var relationSchema = schema.relations[relationName];
                                var relation = {
                                    target: schema.target || schema.name,
                                    propertyName: relationName,
                                    relationType: relationSchema.type,
                                    isLazy: relationSchema.isLazy || false,
                                    type: relationSchema.target,
                                    inverseSideProperty: relationSchema.inverseSide,
                                    isTreeParent: relationSchema.isTreeParent,
                                    isTreeChildren: relationSchema.isTreeChildren,
                                    options: {
                                        cascadeAll: relationSchema.cascadeAll,
                                        cascadeInsert: relationSchema.cascadeInsert,
                                        cascadeUpdate: relationSchema.cascadeUpdate,
                                        cascadeRemove: relationSchema.cascadeRemove,
                                        nullable: relationSchema.nullable,
                                        onDelete: relationSchema.onDelete
                                    }
                                };
                                metadataArgsStorage.relations.add(relation);
                                // add join column
                                if (relationSchema.joinColumn) {
                                    if (typeof relationSchema.joinColumn === "boolean") {
                                        var joinColumn = {
                                            target: schema.target || schema.name,
                                            propertyName: relationName
                                        };
                                        metadataArgsStorage.joinColumns.add(joinColumn);
                                    }
                                    else {
                                        var joinColumn = {
                                            target: schema.target || schema.name,
                                            propertyName: relationName,
                                            name: relationSchema.joinColumn.name,
                                            referencedColumnName: relationSchema.joinColumn.referencedColumnName
                                        };
                                        metadataArgsStorage.joinColumns.add(joinColumn);
                                    }
                                }
                                // add join table
                                if (relationSchema.joinTable) {
                                    if (typeof relationSchema.joinTable === "boolean") {
                                        var joinTable = {
                                            target: schema.target || schema.name,
                                            propertyName: relationName
                                        };
                                        metadataArgsStorage.joinTables.add(joinTable);
                                    }
                                    else {
                                        var joinTable = {
                                            target: schema.target || schema.name,
                                            propertyName: relationName,
                                            name: relationSchema.joinTable.name,
                                            joinColumn: relationSchema.joinTable.joinColumn,
                                            inverseJoinColumn: relationSchema.joinTable.inverseJoinColumn
                                        };
                                        metadataArgsStorage.joinTables.add(joinTable);
                                    }
                                }
                            });
                        }
                    });
                    return this.build(driver, lazyRelationsWrapper, metadataArgsStorage, namingStrategy);
                };
                /**
                 * Builds a complete metadata aggregations for the given entity classes.
                 */
                EntityMetadataBuilder.prototype.buildFromMetadataArgsStorage = function (driver, lazyRelationsWrapper, namingStrategy, entityClasses) {
                    return this.build(driver, lazyRelationsWrapper, index_2.getMetadataArgsStorage(), namingStrategy, entityClasses);
                };
                // -------------------------------------------------------------------------
                // Private Methods
                // -------------------------------------------------------------------------
                EntityMetadataBuilder.prototype.build = function (driver, lazyRelationsWrapper, metadataArgsStorage, namingStrategy, entityClasses) {
                    var embeddableMergedArgs = metadataArgsStorage.getMergedEmbeddableTableMetadatas(entityClasses);
                    var entityMetadatas = [];
                    var allMergedArgs = metadataArgsStorage.getMergedTableMetadatas(entityClasses);
                    allMergedArgs.forEach(function (mergedArgs) {
                        var tables = [mergedArgs.table].concat(mergedArgs.children);
                        tables.forEach(function (tableArgs) {
                            // find embeddable tables for embeddeds registered in this table and create EmbeddedMetadatas from them
                            var embeddeds = [];
                            mergedArgs.embeddeds.toArray().forEach(function (embedded) {
                                var embeddableTable = embeddableMergedArgs.find(function (embeddedMergedArgs) { return embeddedMergedArgs.table.target === embedded.type(); });
                                if (embeddableTable) {
                                    var table_1 = new TableMetadata_3.TableMetadata(embeddableTable.table);
                                    var columns_1 = embeddableTable.columns.toArray().map(function (args) { return new ColumnMetadata_3.ColumnMetadata(args); });
                                    embeddeds.push(new EmbeddedMetadata_1.EmbeddedMetadata(embedded.type(), embedded.propertyName, table_1, columns_1));
                                }
                            });
                            // create metadatas from args
                            var argsForTable = mergedArgs.inheritance && mergedArgs.inheritance.type === "single-table" ? mergedArgs.table : tableArgs;
                            var table = new TableMetadata_3.TableMetadata(argsForTable);
                            var columns = mergedArgs.columns.toArray().map(function (args) {
                                // if column's target is a child table then this column should have all nullable columns
                                if (mergedArgs.inheritance &&
                                    mergedArgs.inheritance.type === "single-table" &&
                                    args.target !== mergedArgs.table.target && !!mergedArgs.children.find(function (childTable) { return childTable.target === args.target; })) {
                                    args.options.nullable = true;
                                }
                                return new ColumnMetadata_3.ColumnMetadata(args);
                            });
                            var relations = mergedArgs.relations.toArray().map(function (args) { return new RelationMetadata_2.RelationMetadata(args); });
                            var indices = mergedArgs.indices.toArray().map(function (args) { return new IndexMetadata_2.IndexMetadata(args); });
                            var discriminatorValueArgs = mergedArgs.discriminatorValues.find(function (discriminatorValueArgs) {
                                return discriminatorValueArgs.target === tableArgs.target;
                            });
                            // create a new entity metadata
                            var entityMetadata = new EntityMetadata_3.EntityMetadata({
                                junction: false,
                                target: tableArgs.target,
                                tablesPrefix: driver.options.tablesPrefix,
                                namingStrategy: namingStrategy,
                                tableMetadata: table,
                                columnMetadatas: columns,
                                relationMetadatas: relations,
                                indexMetadatas: indices,
                                embeddedMetadatas: embeddeds,
                                inheritanceType: mergedArgs.inheritance ? mergedArgs.inheritance.type : undefined,
                                discriminatorValue: discriminatorValueArgs ? discriminatorValueArgs.value : tableArgs.target.name // todo: pass this to naming strategy to generate a name
                            }, lazyRelationsWrapper);
                            entityMetadatas.push(entityMetadata);
                            // create entity's relations join tables
                            entityMetadata.manyToManyRelations.forEach(function (relation) {
                                var joinTableMetadata = mergedArgs.joinTables.findByProperty(relation.propertyName);
                                if (joinTableMetadata) {
                                    var joinTable = new JoinTableMetadata_1.JoinTableMetadata(joinTableMetadata);
                                    relation.joinTable = joinTable;
                                    joinTable.relation = relation;
                                }
                            });
                            // create entity's relations join columns
                            entityMetadata.oneToOneRelations
                                .concat(entityMetadata.manyToOneRelations)
                                .forEach(function (relation) {
                                // since for many-to-one relations having JoinColumn is not required on decorators level, we need to go
                                // throw all of them which don't have JoinColumn decorators and create it for them
                                var joinColumnMetadata = mergedArgs.joinColumns.findByProperty(relation.propertyName);
                                if (!joinColumnMetadata && relation.isManyToOne) {
                                    joinColumnMetadata = {
                                        target: relation.entityMetadata.target,
                                        propertyName: relation.propertyName
                                    };
                                }
                                if (joinColumnMetadata) {
                                    var joinColumn = new JoinColumnMetadata_1.JoinColumnMetadata(joinColumnMetadata);
                                    relation.joinColumn = joinColumn;
                                    joinColumn.relation = relation;
                                }
                            });
                            // save relation id-s data
                            entityMetadata.relations.forEach(function (relation) {
                                var relationIdMetadata = mergedArgs.relationIds.toArray().find(function (relationId) {
                                    if (relationId.relation instanceof Function)
                                        return relation.propertyName === relationId.relation(entityMetadata.createPropertiesMap());
                                    return relation.propertyName === relationId.relation;
                                });
                                if (relationIdMetadata) {
                                    if (relation.isOneToOneNotOwner || relation.isOneToMany)
                                        throw new Error("RelationId cannot be used for the one-to-one without join column or one-to-many relations.");
                                    relation.idField = relationIdMetadata.propertyName;
                                }
                            });
                            // save relation counter-s data
                            entityMetadata.relations.forEach(function (relation) {
                                var relationCountMetadata = mergedArgs.relationCounts.toArray().find(function (relationCount) {
                                    if (relationCount.relation instanceof Function)
                                        return relation.propertyName === relationCount.relation(entityMetadata.createPropertiesMap());
                                    return relation.propertyName === relationCount.relation;
                                });
                                if (relationCountMetadata)
                                    relation.countField = relationCountMetadata.propertyName;
                            });
                            // add lazy initializer for entity relations
                            if (entityMetadata.target instanceof Function) {
                                entityMetadata.relations
                                    .filter(function (relation) { return relation.isLazy; })
                                    .forEach(function (relation) {
                                    lazyRelationsWrapper.wrap(entityMetadata.target.prototype, relation);
                                });
                            }
                        });
                    });
                    // after all metadatas created we set inverse side (related) entity metadatas for all relation metadatas
                    entityMetadatas.forEach(function (entityMetadata) {
                        entityMetadata.relations.forEach(function (relation) {
                            var inverseEntityMetadata = entityMetadatas.find(function (m) { return m.target === relation.type || (typeof relation.type === "string" && m.targetName === relation.type); });
                            if (!inverseEntityMetadata)
                                throw new Error("Entity metadata for " + entityMetadata.name + "#" + relation.propertyName + " was not found.");
                            relation.inverseEntityMetadata = inverseEntityMetadata;
                        });
                    });
                    // after all metadatas created we set parent entity metadata for class-table inheritance
                    entityMetadatas.forEach(function (entityMetadata) {
                        var mergedArgs = allMergedArgs.find(function (mergedArgs) {
                            return mergedArgs.table.target === entityMetadata.target;
                        });
                        if (mergedArgs && mergedArgs.parent) {
                            var parentEntityMetadata = entityMetadatas.find(function (entityMetadata) { return entityMetadata.table.target === mergedArgs.parent.target; }); // todo: weird compiler error here, thats why type casing is used
                            if (parentEntityMetadata)
                                entityMetadata.parentEntityMetadata = parentEntityMetadata;
                        }
                    });
                    // generate keys for tables with single-table inheritance
                    entityMetadatas
                        .filter(function (metadata) { return metadata.inheritanceType === "single-table" && metadata.hasDiscriminatorColumn; })
                        .forEach(function (metadata) {
                        var indexForKey = new IndexMetadata_2.IndexMetadata({
                            target: metadata.target,
                            columns: [metadata.discriminatorColumn.name],
                            unique: false
                        });
                        indexForKey.entityMetadata = metadata;
                        metadata.indices.push(indexForKey);
                        var indexForKeyWithPrimary = new IndexMetadata_2.IndexMetadata({
                            target: metadata.target,
                            columns: [metadata.firstPrimaryColumn.propertyName, metadata.discriminatorColumn.propertyName],
                            unique: false
                        });
                        indexForKeyWithPrimary.entityMetadata = metadata;
                        metadata.indices.push(indexForKeyWithPrimary);
                    });
                    // generate virtual column with foreign key for class-table inheritance
                    entityMetadatas
                        .filter(function (metadata) { return !!metadata.parentEntityMetadata; })
                        .forEach(function (metadata) {
                        var parentEntityMetadataPrimaryColumn = metadata.parentEntityMetadata.firstPrimaryColumn; // todo: make sure to create columns for all its primary columns
                        var columnName = namingStrategy.classTableInheritanceParentColumnName(metadata.parentEntityMetadata.table.name, parentEntityMetadataPrimaryColumn.propertyName);
                        var parentRelationColumn = new ColumnMetadata_3.ColumnMetadata({
                            target: metadata.parentEntityMetadata.table.target,
                            propertyName: parentEntityMetadataPrimaryColumn.propertyName,
                            // propertyType: parentEntityMetadataPrimaryColumn.propertyType,
                            mode: "parentId",
                            options: {
                                name: columnName,
                                type: parentEntityMetadataPrimaryColumn.type,
                                unique: true,
                                nullable: false,
                                primary: false
                            }
                        });
                        // add column
                        metadata.addColumn(parentRelationColumn);
                        // add foreign key
                        var foreignKey = new ForeignKeyMetadata_3.ForeignKeyMetadata([parentRelationColumn], metadata.parentEntityMetadata.table, [parentEntityMetadataPrimaryColumn], "CASCADE");
                        foreignKey.entityMetadata = metadata;
                        metadata.foreignKeys.push(foreignKey);
                    });
                    // generate columns and foreign keys for tables with relations
                    entityMetadatas.forEach(function (metadata) {
                        metadata.relationsWithJoinColumns.forEach(function (relation) {
                            // find relational column and if it does not exist - add it
                            var inverseSideColumn = relation.joinColumn.referencedColumn;
                            var relationalColumn = metadata.columns.find(function (column) { return column.name === relation.name; });
                            if (!relationalColumn) {
                                relationalColumn = new ColumnMetadata_3.ColumnMetadata({
                                    target: metadata.target,
                                    propertyName: relation.name,
                                    // propertyType: inverseSideColumn.propertyType,
                                    mode: "virtual",
                                    options: {
                                        type: inverseSideColumn.type,
                                        nullable: relation.isNullable,
                                        primary: relation.isPrimary
                                    }
                                });
                                relationalColumn.relationMetadata = relation;
                                metadata.addColumn(relationalColumn);
                            }
                            // create and add foreign key
                            var foreignKey = new ForeignKeyMetadata_3.ForeignKeyMetadata([relationalColumn], relation.inverseEntityMetadata.table, [inverseSideColumn], relation.onDelete);
                            foreignKey.entityMetadata = metadata;
                            metadata.foreignKeys.push(foreignKey);
                        });
                    });
                    // generate junction tables for all closure tables
                    entityMetadatas.forEach(function (metadata) {
                        if (!metadata.table.isClosure)
                            return;
                        if (metadata.primaryColumns.length > 1)
                            throw new Error("Cannot use given entity " + metadata.name + " as a closure table, because it have multiple primary keys. Entities with multiple primary keys are not supported in closure tables.");
                        var closureJunctionEntityMetadata = index_2.getFromContainer(ClosureJunctionEntityMetadataBuilder_1.ClosureJunctionEntityMetadataBuilder).build(driver, lazyRelationsWrapper, {
                            namingStrategy: namingStrategy,
                            table: metadata.table,
                            primaryColumn: metadata.firstPrimaryColumn,
                            hasTreeLevelColumn: metadata.hasTreeLevelColumn
                        });
                        metadata.closureJunctionTable = closureJunctionEntityMetadata;
                        entityMetadatas.push(closureJunctionEntityMetadata);
                    });
                    // generate junction tables for all many-to-many tables
                    entityMetadatas.forEach(function (metadata) {
                        metadata.ownerManyToManyRelations.forEach(function (relation) {
                            var junctionEntityMetadata = index_2.getFromContainer(JunctionEntityMetadataBuilder_1.JunctionEntityMetadataBuilder).build(driver, lazyRelationsWrapper, {
                                namingStrategy: namingStrategy,
                                firstTable: metadata.table,
                                secondTable: relation.inverseEntityMetadata.table,
                                joinTable: relation.joinTable
                            });
                            relation.junctionEntityMetadata = junctionEntityMetadata;
                            if (relation.hasInverseSide)
                                relation.inverseRelation.junctionEntityMetadata = junctionEntityMetadata;
                            entityMetadatas.push(junctionEntityMetadata);
                        });
                    });
                    // check for errors in a built metadata schema (we need to check after relationEntityMetadata is set)
                    index_2.getFromContainer(EntityMetadataValidator_1.EntityMetadataValidator).validateMany(entityMetadatas);
                    return entityMetadatas;
                };
                return EntityMetadataBuilder;
            }());
            exports_113("EntityMetadataBuilder", EntityMetadataBuilder);
        }
    };
});
System.register("typeorm/util/RandomGenerator", [], function (exports_114, context_114) {
    "use strict";
    var __moduleName = context_114 && context_114.id;
    var RandomGenerator;
    return {
        setters: [],
        execute: function () {
            RandomGenerator = (function () {
                function RandomGenerator() {
                }
                /**
                 *  discuss at: http://locutus.io/php/sha1/
                 * original by: Webtoolkit.info (http://www.webtoolkit.info/)
                 * improved by: Michael White (http://getsprink.com)
                 * improved by: Kevin van Zonneveld (http://kvz.io)
                 *    input by: Brett Zamir (http://brett-zamir.me)
                 *      note 1: Keep in mind that in accordance with PHP, the whole string is buffered and then
                 *      note 1: hashed. If available, we'd recommend using Node's native crypto modules directly
                 *      note 1: in a steaming fashion for faster and more efficient hashing
                 *   example 1: sha1('Kevin van Zonneveld')
                 *   returns 1: '54916d2e62f65b3afa6e192e6a601cdbe5cb5897'
                 */
                RandomGenerator.sha1 = function (str) {
                    var _rotLeft = function (n, s) {
                        var t4 = (n << s) | (n >>> (32 - s));
                        return t4;
                    };
                    var _cvtHex = function (val) {
                        var str = "";
                        var i;
                        var v;
                        for (i = 7; i >= 0; i--) {
                            v = (val >>> (i * 4)) & 0x0f;
                            str += v.toString(16);
                        }
                        return str;
                    };
                    var blockstart;
                    var i, j;
                    var W = new Array(80);
                    var H0 = 0x67452301;
                    var H1 = 0xEFCDAB89;
                    var H2 = 0x98BADCFE;
                    var H3 = 0x10325476;
                    var H4 = 0xC3D2E1F0;
                    var A, B, C, D, E;
                    var temp;
                    // utf8_encode
                    str = (encodeURIComponent(str));
                    var strLen = str.length;
                    var wordArray = [];
                    for (i = 0; i < strLen - 3; i += 4) {
                        j = str.charCodeAt(i) << 24 |
                            str.charCodeAt(i + 1) << 16 |
                            str.charCodeAt(i + 2) << 8 |
                            str.charCodeAt(i + 3);
                        wordArray.push(j);
                    }
                    switch (strLen % 4) {
                        case 0:
                            i = 0x080000000;
                            break;
                        case 1:
                            i = str.charCodeAt(strLen - 1) << 24 | 0x0800000;
                            break;
                        case 2:
                            i = str.charCodeAt(strLen - 2) << 24 | str.charCodeAt(strLen - 1) << 16 | 0x08000;
                            break;
                        case 3:
                            i = str.charCodeAt(strLen - 3) << 24 |
                                str.charCodeAt(strLen - 2) << 16 |
                                str.charCodeAt(strLen - 1) <<
                                    8 | 0x80;
                            break;
                    }
                    wordArray.push(i);
                    while ((wordArray.length % 16) !== 14) {
                        wordArray.push(0);
                    }
                    wordArray.push(strLen >>> 29);
                    wordArray.push((strLen << 3) & 0x0ffffffff);
                    for (blockstart = 0; blockstart < wordArray.length; blockstart += 16) {
                        for (i = 0; i < 16; i++) {
                            W[i] = wordArray[blockstart + i];
                        }
                        for (i = 16; i <= 79; i++) {
                            W[i] = _rotLeft(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);
                        }
                        A = H0;
                        B = H1;
                        C = H2;
                        D = H3;
                        E = H4;
                        for (i = 0; i <= 19; i++) {
                            temp = (_rotLeft(A, 5) + ((B & C) | (~B & D)) + E + W[i] + 0x5A827999) & 0x0ffffffff;
                            E = D;
                            D = C;
                            C = _rotLeft(B, 30);
                            B = A;
                            A = temp;
                        }
                        for (i = 20; i <= 39; i++) {
                            temp = (_rotLeft(A, 5) + (B ^ C ^ D) + E + W[i] + 0x6ED9EBA1) & 0x0ffffffff;
                            E = D;
                            D = C;
                            C = _rotLeft(B, 30);
                            B = A;
                            A = temp;
                        }
                        for (i = 40; i <= 59; i++) {
                            temp = (_rotLeft(A, 5) + ((B & C) | (B & D) | (C & D)) + E + W[i] + 0x8F1BBCDC) & 0x0ffffffff;
                            E = D;
                            D = C;
                            C = _rotLeft(B, 30);
                            B = A;
                            A = temp;
                        }
                        for (i = 60; i <= 79; i++) {
                            temp = (_rotLeft(A, 5) + (B ^ C ^ D) + E + W[i] + 0xCA62C1D6) & 0x0ffffffff;
                            E = D;
                            D = C;
                            C = _rotLeft(B, 30);
                            B = A;
                            A = temp;
                        }
                        H0 = (H0 + A) & 0x0ffffffff;
                        H1 = (H1 + B) & 0x0ffffffff;
                        H2 = (H2 + C) & 0x0ffffffff;
                        H3 = (H3 + D) & 0x0ffffffff;
                        H4 = (H4 + E) & 0x0ffffffff;
                    }
                    temp = _cvtHex(H0) + _cvtHex(H1) + _cvtHex(H2) + _cvtHex(H3) + _cvtHex(H4);
                    return temp.toLowerCase();
                };
                return RandomGenerator;
            }());
            exports_114("RandomGenerator", RandomGenerator);
        }
    };
});
System.register("typeorm/util/StringUtils", [], function (exports_115, context_115) {
    "use strict";
    var __moduleName = context_115 && context_115.id;
    /**
     * Converts string into camelCase.
     *
     * @see http://stackoverflow.com/questions/2970525/converting-any-string-into-camel-case
     */
    function camelCase(str) {
        return str.replace(/^([A-Z])|[\s-_](\w)/g, function (match, p1, p2, offset) {
            if (p2)
                return p2.toUpperCase();
            return p1.toLowerCase();
        });
    }
    exports_115("camelCase", camelCase);
    /**
     * Converts string into snake-case.
     *
     * @see http://stackoverflow.com/questions/30521224/javascript-convert-pascalcase-to-underscore-case
     */
    function snakeCase(str) {
        return str.replace(/(?:^|\.?)([A-Z])/g, function (x, y) { return "_" + y.toLowerCase(); }).replace(/^_/, "");
    }
    exports_115("snakeCase", snakeCase);
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/naming-strategy/DefaultNamingStrategy", ["typeorm/util/RandomGenerator", "typeorm/util/StringUtils"], function (exports_116, context_116) {
    "use strict";
    var __moduleName = context_116 && context_116.id;
    var RandomGenerator_1, StringUtils_1, DefaultNamingStrategy;
    return {
        setters: [
            function (RandomGenerator_1_1) {
                RandomGenerator_1 = RandomGenerator_1_1;
            },
            function (StringUtils_1_1) {
                StringUtils_1 = StringUtils_1_1;
            }
        ],
        execute: function () {
            /**
             * Naming strategy that is used by default.
             */
            DefaultNamingStrategy = (function () {
                function DefaultNamingStrategy() {
                }
                DefaultNamingStrategy.prototype.tableName = function (className, customName) {
                    return customName ? customName : StringUtils_1.snakeCase(className);
                };
                DefaultNamingStrategy.prototype.columnName = function (propertyName, customName) {
                    return customName ? customName : propertyName;
                };
                DefaultNamingStrategy.prototype.embeddedColumnName = function (embeddedPropertyName, columnPropertyName, columnCustomName) {
                    return StringUtils_1.camelCase(embeddedPropertyName + "_" + (columnCustomName ? columnCustomName : columnPropertyName));
                };
                DefaultNamingStrategy.prototype.relationName = function (propertyName) {
                    return propertyName;
                };
                DefaultNamingStrategy.prototype.indexName = function (customName, tableName, columns) {
                    if (customName)
                        return customName;
                    var key = "ind_" + tableName + "_" + columns.join("_");
                    return "ind_" + RandomGenerator_1.RandomGenerator.sha1(key).substr(0, 27);
                };
                DefaultNamingStrategy.prototype.joinColumnInverseSideName = function (joinColumnName, propertyName) {
                    if (joinColumnName)
                        return joinColumnName;
                    return propertyName;
                };
                DefaultNamingStrategy.prototype.joinTableName = function (firstTableName, secondTableName, firstPropertyName, secondPropertyName, firstColumnName, secondColumnName) {
                    return StringUtils_1.snakeCase(firstTableName + "_" + firstPropertyName + "_" + secondTableName + "_" + secondColumnName);
                };
                DefaultNamingStrategy.prototype.joinTableColumnName = function (tableName, columnName, secondTableName, secondColumnName) {
                    var column1 = StringUtils_1.camelCase(tableName + "_" + columnName);
                    var column2 = StringUtils_1.camelCase(secondTableName + "_" + secondColumnName);
                    return column1 === column2 ? column1 + "_1" : column1; // todo: do we still need _1 prefix?!
                };
                DefaultNamingStrategy.prototype.joinTableInverseColumnName = function (tableName, columnName, secondTableName, secondColumnName) {
                    var column1 = StringUtils_1.camelCase(tableName + "_" + columnName);
                    var column2 = StringUtils_1.camelCase(secondTableName + "_" + secondColumnName);
                    return column1 === column2 ? column1 + "_2" : column1; // todo: do we still need _2 prefix?!
                };
                DefaultNamingStrategy.prototype.closureJunctionTableName = function (tableName) {
                    return tableName + "_closure";
                };
                DefaultNamingStrategy.prototype.foreignKeyName = function (tableName, columnNames, referencedTableName, referencedColumnNames) {
                    var key = tableName + "_" + columnNames.join("_") + "_" + referencedTableName + "_" + referencedColumnNames.join("_");
                    return "fk_" + RandomGenerator_1.RandomGenerator.sha1(key).substr(0, 27); // todo: use crypto instead?
                };
                DefaultNamingStrategy.prototype.classTableInheritanceParentColumnName = function (parentTableName, parentTableIdPropertyName) {
                    return StringUtils_1.camelCase(parentTableName + "_" + parentTableIdPropertyName);
                };
                /**
                 * Adds prefix to the table.
                 */
                DefaultNamingStrategy.prototype.prefixTableName = function (prefix, originalTableName) {
                    return prefix + originalTableName;
                };
                return DefaultNamingStrategy;
            }());
            exports_116("DefaultNamingStrategy", DefaultNamingStrategy);
        }
    };
});
System.register("typeorm/connection/error/CannotImportAlreadyConnectedError", [], function (exports_117, context_117) {
    "use strict";
    var __moduleName = context_117 && context_117.id;
    var CannotImportAlreadyConnectedError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown when consumer tries to import entities / entity schemas / subscribers / naming strategies after connection
             * is established.
             */
            CannotImportAlreadyConnectedError = (function (_super) {
                __extends(CannotImportAlreadyConnectedError, _super);
                function CannotImportAlreadyConnectedError(importStuff, connectionName) {
                    var _this = _super.call(this) || this;
                    _this.name = "CannotImportAlreadyConnected";
                    _this.message = "Cannot import " + importStuff + " for \"" + connectionName + "\" connection because connection to the database already established.";
                    _this.stack = new Error().stack;
                    return _this;
                }
                return CannotImportAlreadyConnectedError;
            }(Error));
            exports_117("CannotImportAlreadyConnectedError", CannotImportAlreadyConnectedError);
        }
    };
});
System.register("typeorm/connection/error/CannotCloseNotConnectedError", [], function (exports_118, context_118) {
    "use strict";
    var __moduleName = context_118 && context_118.id;
    var CannotCloseNotConnectedError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown when consumer tries close not opened connection.
             */
            CannotCloseNotConnectedError = (function (_super) {
                __extends(CannotCloseNotConnectedError, _super);
                function CannotCloseNotConnectedError(connectionName) {
                    var _this = _super.call(this) || this;
                    _this.name = "CannotCloseNotConnectedError";
                    _this.message = "Cannot close \"" + connectionName + "\" connection because connection is not yet established.";
                    _this.stack = new Error().stack;
                    return _this;
                }
                return CannotCloseNotConnectedError;
            }(Error));
            exports_118("CannotCloseNotConnectedError", CannotCloseNotConnectedError);
        }
    };
});
System.register("typeorm/connection/error/CannotConnectAlreadyConnectedError", [], function (exports_119, context_119) {
    "use strict";
    var __moduleName = context_119 && context_119.id;
    var CannotConnectAlreadyConnectedError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown when consumer tries to connect when he already connected.
             */
            CannotConnectAlreadyConnectedError = (function (_super) {
                __extends(CannotConnectAlreadyConnectedError, _super);
                function CannotConnectAlreadyConnectedError(connectionName) {
                    var _this = _super.call(this) || this;
                    _this.name = "CannotConnectAlreadyConnectedError";
                    _this.message = "Cannot create a \"" + connectionName + "\" connection because connection to the database already established.";
                    _this.stack = new Error().stack;
                    return _this;
                }
                return CannotConnectAlreadyConnectedError;
            }(Error));
            exports_119("CannotConnectAlreadyConnectedError", CannotConnectAlreadyConnectedError);
        }
    };
});
System.register("typeorm/connection/error/NamingStrategyNotFoundError", [], function (exports_120, context_120) {
    "use strict";
    var __moduleName = context_120 && context_120.id;
    var NamingStrategyNotFoundError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown when consumer tries to use naming strategy that does not exist.
             */
            NamingStrategyNotFoundError = (function (_super) {
                __extends(NamingStrategyNotFoundError, _super);
                function NamingStrategyNotFoundError(strategyName, connectionName) {
                    var _this = _super.call(this) || this;
                    _this.name = "NamingStrategyNotFoundError";
                    var name = strategyName instanceof Function ? strategyName.name : strategyName;
                    _this.message = "Naming strategy \"" + name + "\" was not found. Looks like this naming strategy does not " +
                        ("exist or it was not registered in current \"" + connectionName + "\" connection?");
                    _this.stack = new Error().stack;
                    return _this;
                }
                return NamingStrategyNotFoundError;
            }(Error));
            exports_120("NamingStrategyNotFoundError", NamingStrategyNotFoundError);
        }
    };
});
System.register("typeorm/connection/error/CannotSyncNotConnectedError", [], function (exports_121, context_121) {
    "use strict";
    var __moduleName = context_121 && context_121.id;
    var CannotSyncNotConnectedError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown when consumer tries to sync a database schema after connection is established
             */
            CannotSyncNotConnectedError = (function (_super) {
                __extends(CannotSyncNotConnectedError, _super);
                function CannotSyncNotConnectedError(connectionName) {
                    var _this = _super.call(this) || this;
                    _this.name = "CannotSyncNotConnectedError";
                    _this.message = "Cannot sync schema of the \"" + connectionName + "\" connection because connection is not yet established.";
                    _this.stack = new Error().stack;
                    return _this;
                }
                return CannotSyncNotConnectedError;
            }(Error));
            exports_121("CannotSyncNotConnectedError", CannotSyncNotConnectedError);
        }
    };
});
System.register("typeorm/connection/error/CannotUseNamingStrategyNotConnectedError", [], function (exports_122, context_122) {
    "use strict";
    var __moduleName = context_122 && context_122.id;
    var CannotUseNamingStrategyNotConnectedError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown when consumer tries to change used naming strategy after connection is established.
             */
            CannotUseNamingStrategyNotConnectedError = (function (_super) {
                __extends(CannotUseNamingStrategyNotConnectedError, _super);
                function CannotUseNamingStrategyNotConnectedError(connectionName) {
                    var _this = _super.call(this) || this;
                    _this.name = "CannotUseNamingStrategyNotConnectedError";
                    _this.message = "Cannot use a given naming strategy for \"" + connectionName + "\" connection because connection to the database already established.";
                    _this.stack = new Error().stack;
                    return _this;
                }
                return CannotUseNamingStrategyNotConnectedError;
            }(Error));
            exports_122("CannotUseNamingStrategyNotConnectedError", CannotUseNamingStrategyNotConnectedError);
        }
    };
});
System.register("typeorm/subscriber/Broadcaster", ["typeorm/metadata/types/EventListenerTypes"], function (exports_123, context_123) {
    "use strict";
    var __moduleName = context_123 && context_123.id;
    var EventListenerTypes_1, Broadcaster;
    return {
        setters: [
            function (EventListenerTypes_1_1) {
                EventListenerTypes_1 = EventListenerTypes_1_1;
            }
        ],
        execute: function () {
            /**
             * Broadcaster provides a helper methods to broadcast events to the subscribers.
             */
            Broadcaster = (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function Broadcaster(connection, subscriberMetadatas, entityListeners) {
                    this.connection = connection;
                    this.subscriberMetadatas = subscriberMetadatas;
                    this.entityListeners = entityListeners;
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Broadcasts "BEFORE_INSERT", "BEFORE_UPDATE", "BEFORE_REMOVE" events for all given subjects.
                 */
                Broadcaster.prototype.broadcastBeforeEventsForAll = function (entityManager, insertSubjects, updateSubjects, removeSubjects) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var insertPromises, updatePromises, removePromises, allPromises;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    insertPromises = insertSubjects.map(function (subject) { return _this.broadcastBeforeInsertEvent(entityManager, subject); });
                                    updatePromises = updateSubjects.map(function (subject) { return _this.broadcastBeforeUpdateEvent(entityManager, subject); });
                                    removePromises = removeSubjects.map(function (subject) { return _this.broadcastBeforeRemoveEvent(entityManager, subject); });
                                    allPromises = insertPromises.concat(updatePromises).concat(removePromises);
                                    return [4 /*yield*/, Promise.all(allPromises)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Broadcasts "AFTER_INSERT", "AFTER_UPDATE", "AFTER_REMOVE" events for all given subjects.
                 */
                Broadcaster.prototype.broadcastAfterEventsForAll = function (entityManager, insertSubjects, updateSubjects, removeSubjects) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var insertPromises, updatePromises, removePromises, allPromises;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    insertPromises = insertSubjects.map(function (subject) { return _this.broadcastAfterInsertEvent(entityManager, subject); });
                                    updatePromises = updateSubjects.map(function (subject) { return _this.broadcastAfterUpdateEvent(entityManager, subject); });
                                    removePromises = removeSubjects.map(function (subject) { return _this.broadcastAfterRemoveEvent(entityManager, subject); });
                                    allPromises = insertPromises.concat(updatePromises).concat(removePromises);
                                    return [4 /*yield*/, Promise.all(allPromises)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Broadcasts "BEFORE_INSERT" event.
                 * Before insert event is executed before entity is being inserted to the database for the first time.
                 * All subscribers and entity listeners who listened to this event will be executed at this point.
                 * Subscribers and entity listeners can return promises, it will wait until they are resolved.
                 */
                Broadcaster.prototype.broadcastBeforeInsertEvent = function (entityManager, subject) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var listeners, subscribers;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    listeners = this.entityListeners
                                        .filter(function (listener) { return listener.type === EventListenerTypes_1.EventListenerTypes.BEFORE_INSERT && _this.isAllowedListener(listener, subject.entity); })
                                        .map(function (entityListener) { return subject.entity[entityListener.propertyName](); });
                                    subscribers = this.subscriberMetadatas
                                        .filter(function (subscriber) { return _this.isAllowedSubscriber(subscriber, subject.entityTarget) && subscriber.beforeInsert; })
                                        .map(function (subscriber) { return subscriber.beforeInsert({
                                        entityManager: entityManager,
                                        entity: subject.entity
                                    }); });
                                    return [4 /*yield*/, Promise.all(listeners.concat(subscribers))];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Broadcasts "BEFORE_UPDATE" event.
                 * Before update event is executed before entity is being updated in the database.
                 * All subscribers and entity listeners who listened to this event will be executed at this point.
                 * Subscribers and entity listeners can return promises, it will wait until they are resolved.
                 */
                Broadcaster.prototype.broadcastBeforeUpdateEvent = function (entityManager, subject) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var listeners, subscribers;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    listeners = this.entityListeners
                                        .filter(function (listener) { return listener.type === EventListenerTypes_1.EventListenerTypes.BEFORE_UPDATE && _this.isAllowedListener(listener, subject.entity); })
                                        .map(function (entityListener) { return subject.entity[entityListener.propertyName](); });
                                    subscribers = this.subscriberMetadatas
                                        .filter(function (subscriber) { return _this.isAllowedSubscriber(subscriber, subject.entityTarget) && subscriber.beforeUpdate; })
                                        .map(function (subscriber) { return subscriber.beforeUpdate({
                                        entityManager: entityManager,
                                        entity: subject.entity,
                                        databaseEntity: subject.databaseEntity,
                                        updatedColumns: subject.diffColumns,
                                        updatedRelations: subject.diffRelations,
                                    }); });
                                    return [4 /*yield*/, Promise.all(listeners.concat(subscribers))];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Broadcasts "BEFORE_REMOVE" event.
                 * Before remove event is executed before entity is being removed from the database.
                 * All subscribers and entity listeners who listened to this event will be executed at this point.
                 * Subscribers and entity listeners can return promises, it will wait until they are resolved.
                 */
                Broadcaster.prototype.broadcastBeforeRemoveEvent = function (entityManager, subject) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var listeners, subscribers;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    listeners = this.entityListeners
                                        .filter(function (listener) { return listener.type === EventListenerTypes_1.EventListenerTypes.BEFORE_REMOVE && _this.isAllowedListener(listener, subject.entity); })
                                        .map(function (entityListener) { return subject.databaseEntity[entityListener.propertyName](); });
                                    subscribers = this.subscriberMetadatas
                                        .filter(function (subscriber) { return _this.isAllowedSubscriber(subscriber, subject.entityTarget) && subscriber.beforeRemove; })
                                        .map(function (subscriber) { return subscriber.beforeRemove({
                                        entityManager: entityManager,
                                        entity: subject.hasEntity ? subject.entity : undefined,
                                        databaseEntity: subject.databaseEntity,
                                        entityId: subject.metadata.getEntityIdMixedMap(subject.databaseEntity)
                                    }); });
                                    return [4 /*yield*/, Promise.all(listeners.concat(subscribers))];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Broadcasts "AFTER_INSERT" event.
                 * After insert event is executed after entity is being persisted to the database for the first time.
                 * All subscribers and entity listeners who listened to this event will be executed at this point.
                 * Subscribers and entity listeners can return promises, it will wait until they are resolved.
                 */
                Broadcaster.prototype.broadcastAfterInsertEvent = function (entityManager, subject) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var listeners, subscribers;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    listeners = this.entityListeners
                                        .filter(function (listener) { return listener.type === EventListenerTypes_1.EventListenerTypes.AFTER_INSERT && _this.isAllowedListener(listener, subject.entity); })
                                        .map(function (entityListener) { return subject.entity[entityListener.propertyName](); });
                                    subscribers = this.subscriberMetadatas
                                        .filter(function (subscriber) { return _this.isAllowedSubscriber(subscriber, subject.entityTarget) && subscriber.afterInsert; })
                                        .map(function (subscriber) { return subscriber.afterInsert({
                                        entityManager: entityManager,
                                        entity: subject.entity
                                    }); });
                                    return [4 /*yield*/, Promise.all(listeners.concat(subscribers))];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Broadcasts "AFTER_UPDATE" event.
                 * After update event is executed after entity is being updated in the database.
                 * All subscribers and entity listeners who listened to this event will be executed at this point.
                 * Subscribers and entity listeners can return promises, it will wait until they are resolved.
                 */
                Broadcaster.prototype.broadcastAfterUpdateEvent = function (entityManager, subject) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var listeners, subscribers;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    listeners = this.entityListeners
                                        .filter(function (listener) { return listener.type === EventListenerTypes_1.EventListenerTypes.AFTER_UPDATE && _this.isAllowedListener(listener, subject.entity); })
                                        .map(function (entityListener) { return subject.entity[entityListener.propertyName](); });
                                    subscribers = this.subscriberMetadatas
                                        .filter(function (subscriber) { return _this.isAllowedSubscriber(subscriber, subject.entityTarget) && subscriber.afterUpdate; })
                                        .map(function (subscriber) { return subscriber.afterUpdate({
                                        entityManager: entityManager,
                                        entity: subject.entity,
                                        databaseEntity: subject.databaseEntity,
                                        updatedColumns: subject.diffColumns,
                                        updatedRelations: subject.diffRelations,
                                    }); });
                                    return [4 /*yield*/, Promise.all(listeners.concat(subscribers))];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Broadcasts "AFTER_REMOVE" event.
                 * After remove event is executed after entity is being removed from the database.
                 * All subscribers and entity listeners who listened to this event will be executed at this point.
                 * Subscribers and entity listeners can return promises, it will wait until they are resolved.
                 */
                Broadcaster.prototype.broadcastAfterRemoveEvent = function (entityManager, subject) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var listeners, subscribers;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    listeners = this.entityListeners
                                        .filter(function (listener) { return listener.type === EventListenerTypes_1.EventListenerTypes.AFTER_REMOVE && _this.isAllowedListener(listener, subject.entity); })
                                        .map(function (entityListener) { return subject.entity[entityListener.propertyName](); });
                                    subscribers = this.subscriberMetadatas
                                        .filter(function (subscriber) { return _this.isAllowedSubscriber(subscriber, subject.entityTarget) && subscriber.afterRemove; })
                                        .map(function (subscriber) { return subscriber.afterRemove({
                                        entityManager: entityManager,
                                        entity: subject.hasEntity ? subject.entity : undefined,
                                        databaseEntity: subject.databaseEntity,
                                        entityId: subject.metadata.getEntityIdMixedMap(subject.databaseEntity)
                                    }); });
                                    return [4 /*yield*/, Promise.all(listeners.concat(subscribers))];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Broadcasts "AFTER_LOAD" event for all given entities, and their sub-entities.
                 * After load event is executed after entity has been loaded from the database.
                 * All subscribers and entity listeners who listened to this event will be executed at this point.
                 * Subscribers and entity listeners can return promises, it will wait until they are resolved.
                 */
                Broadcaster.prototype.broadcastLoadEventsForAll = function (target, entities) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, Promise.all(entities.map(function (entity) { return _this.broadcastLoadEvents(target, entity); }))];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Broadcasts "AFTER_LOAD" event for the given entity and all its sub-entities.
                 * After load event is executed after entity has been loaded from the database.
                 * All subscribers and entity listeners who listened to this event will be executed at this point.
                 * Subscribers and entity listeners can return promises, it will wait until they are resolved.
                 */
                Broadcaster.prototype.broadcastLoadEvents = function (target, entity) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var children, listeners, subscribers;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (entity instanceof Promise)
                                        return [2 /*return*/];
                                    children = this.connection.getMetadata(target).relations.reduce(function (promises, relation) {
                                        if (!entity.hasOwnProperty(relation.propertyName))
                                            return promises;
                                        var value = relation.getEntityValue(entity);
                                        if (value instanceof Array) {
                                            promises = promises.concat(_this.broadcastLoadEventsForAll(relation.inverseEntityMetadata.target, value));
                                        }
                                        else if (value) {
                                            promises.push(_this.broadcastLoadEvents(relation.inverseEntityMetadata.target, value));
                                        }
                                        return promises;
                                    }, []);
                                    listeners = this.entityListeners
                                        .filter(function (listener) { return listener.type === EventListenerTypes_1.EventListenerTypes.AFTER_LOAD && _this.isAllowedListener(listener, entity); })
                                        .map(function (listener) { return entity[listener.propertyName](); });
                                    subscribers = this.subscriberMetadatas
                                        .filter(function (subscriber) { return _this.isAllowedSubscriber(subscriber, target) && subscriber.afterLoad; })
                                        .map(function (subscriber) { return subscriber.afterLoad(entity); });
                                    return [4 /*yield*/, Promise.all(children.concat(listeners.concat(subscribers)))];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                // -------------------------------------------------------------------------
                // Protected Methods
                // -------------------------------------------------------------------------
                /**
                 * Checks if entity listener is allowed to be executed on the given entity.
                 */
                Broadcaster.prototype.isAllowedListener = function (listener, entity) {
                    // todo: create in entity metadata method like isInherited
                    return listener.target === entity.constructor ||
                        (listener.target instanceof Function && entity.constructor.prototype instanceof listener.target); // todo: also need to implement entity schema inheritance
                };
                /**
                 * Checks if subscriber's methods can be executed by checking if its don't listen to the particular entity,
                 * or listens our entity.
                 */
                Broadcaster.prototype.isAllowedSubscriber = function (subscriber, target) {
                    return !subscriber.listenTo ||
                        !subscriber.listenTo() ||
                        subscriber.listenTo() === Object ||
                        subscriber.listenTo() === target;
                };
                return Broadcaster;
            }());
            exports_123("Broadcaster", Broadcaster);
        }
    };
});
System.register("typeorm/schema-builder/SchemaBuilder", ["typeorm/schema-builder/schema/TableSchema", "typeorm/schema-builder/schema/ColumnSchema", "typeorm/schema-builder/schema/ForeignKeySchema", "typeorm/schema-builder/schema/IndexSchema", "typeorm/schema-builder/schema/PrimaryKeySchema", "typeorm/util/PromiseUtils"], function (exports_124, context_124) {
    "use strict";
    var __moduleName = context_124 && context_124.id;
    var TableSchema_2, ColumnSchema_3, ForeignKeySchema_2, IndexSchema_2, PrimaryKeySchema_2, PromiseUtils_2, SchemaBuilder;
    return {
        setters: [
            function (TableSchema_2_1) {
                TableSchema_2 = TableSchema_2_1;
            },
            function (ColumnSchema_3_1) {
                ColumnSchema_3 = ColumnSchema_3_1;
            },
            function (ForeignKeySchema_2_1) {
                ForeignKeySchema_2 = ForeignKeySchema_2_1;
            },
            function (IndexSchema_2_1) {
                IndexSchema_2 = IndexSchema_2_1;
            },
            function (PrimaryKeySchema_2_1) {
                PrimaryKeySchema_2 = PrimaryKeySchema_2_1;
            },
            function (PromiseUtils_2_1) {
                PromiseUtils_2 = PromiseUtils_2_1;
            }
        ],
        execute: function () {
            /**
             * Creates complete tables schemas in the database based on the entity metadatas.
             *
             * Steps how schema is being built:
             * 1. load list of all tables with complete column and keys information from the db
             * 2. drop all (old) foreign keys that exist in the table, but does not exist in the metadata
             * 3. create new tables that does not exist in the db, but exist in the metadata
             * 4. drop all columns exist (left old) in the db table, but does not exist in the metadata
             * 5. add columns from metadata which does not exist in the table
             * 6. update all exist columns which metadata has changed
             * 7. update primary keys - update old and create new primary key from changed columns
             * 8. create foreign keys which does not exist in the table yet
             * 9. create indices which are missing in db yet, and drops indices which exist in the db, but does not exist in the metadata anymore
             */
            SchemaBuilder = (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                /**
                 * @param driver Driver needs to create a query runner
                 * @param logger Used to log schema creation events
                 * @param entityMetadatas All entities to create schema for
                 */
                function SchemaBuilder(driver, logger, entityMetadatas) {
                    this.driver = driver;
                    this.logger = logger;
                    this.entityMetadatas = entityMetadatas;
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Creates complete schemas for the given entity metadatas.
                 */
                SchemaBuilder.prototype.build = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var _a, _b, error_3;
                        return __generator(this, function (_c) {
                            switch (_c.label) {
                                case 0:
                                    _a = this;
                                    return [4 /*yield*/, this.driver.createQueryRunner()];
                                case 1:
                                    _a.queryRunner = _c.sent();
                                    _b = this;
                                    return [4 /*yield*/, this.loadTableSchemas()];
                                case 2:
                                    _b.tableSchemas = _c.sent();
                                    return [4 /*yield*/, this.queryRunner.beginTransaction()];
                                case 3:
                                    _c.sent();
                                    _c.label = 4;
                                case 4:
                                    _c.trys.push([4, 14, 16, 18]);
                                    return [4 /*yield*/, this.dropOldForeignKeys()];
                                case 5:
                                    _c.sent();
                                    // await this.dropOldPrimaryKeys(); // todo: need to drop primary column because column updates are not possible
                                    return [4 /*yield*/, this.createNewTables()];
                                case 6:
                                    // await this.dropOldPrimaryKeys(); // todo: need to drop primary column because column updates are not possible
                                    _c.sent();
                                    return [4 /*yield*/, this.dropRemovedColumns()];
                                case 7:
                                    _c.sent();
                                    return [4 /*yield*/, this.addNewColumns()];
                                case 8:
                                    _c.sent();
                                    return [4 /*yield*/, this.updateExistColumns()];
                                case 9:
                                    _c.sent();
                                    return [4 /*yield*/, this.updatePrimaryKeys()];
                                case 10:
                                    _c.sent();
                                    return [4 /*yield*/, this.createForeignKeys()];
                                case 11:
                                    _c.sent();
                                    return [4 /*yield*/, this.createIndices()];
                                case 12:
                                    _c.sent();
                                    return [4 /*yield*/, this.queryRunner.commitTransaction()];
                                case 13:
                                    _c.sent();
                                    return [3 /*break*/, 18];
                                case 14:
                                    error_3 = _c.sent();
                                    return [4 /*yield*/, this.queryRunner.rollbackTransaction()];
                                case 15:
                                    _c.sent();
                                    throw error_3;
                                case 16: return [4 /*yield*/, this.queryRunner.release()];
                                case 17:
                                    _c.sent();
                                    return [7 /*endfinally*/];
                                case 18: return [2 /*return*/];
                            }
                        });
                    });
                };
                Object.defineProperty(SchemaBuilder.prototype, "entityToSyncMetadatas", {
                    // -------------------------------------------------------------------------
                    // Private Methods
                    // -------------------------------------------------------------------------
                    get: function () {
                        return this.entityMetadatas.filter(function (metadata) { return !metadata.table.skipSchemaSync; });
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Loads all table schemas from the database.
                 */
                SchemaBuilder.prototype.loadTableSchemas = function () {
                    var tableNames = this.entityToSyncMetadatas.map(function (metadata) { return metadata.table.name; });
                    return this.queryRunner.loadTableSchemas(tableNames);
                };
                /**
                 * Drops all (old) foreign keys that exist in the table schemas, but do not exist in the entity metadata.
                 */
                SchemaBuilder.prototype.dropOldForeignKeys = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, PromiseUtils_2.PromiseUtils.runInSequence(this.entityToSyncMetadatas, function (metadata) { return __awaiter(_this, void 0, void 0, function () {
                                        var tableSchema, foreignKeySchemasToDrop;
                                        return __generator(this, function (_a) {
                                            switch (_a.label) {
                                                case 0:
                                                    tableSchema = this.tableSchemas.find(function (table) { return table.name === metadata.table.name; });
                                                    if (!tableSchema)
                                                        return [2 /*return*/];
                                                    foreignKeySchemasToDrop = tableSchema.foreignKeys.filter(function (foreignKeySchema) {
                                                        return !metadata.foreignKeys.find(function (metadataForeignKey) { return metadataForeignKey.name === foreignKeySchema.name; });
                                                    });
                                                    if (foreignKeySchemasToDrop.length === 0)
                                                        return [2 /*return*/];
                                                    this.logger.logSchemaBuild("dropping old foreign keys of " + tableSchema.name + ": " + foreignKeySchemasToDrop.map(function (dbForeignKey) { return dbForeignKey.name; }).join(", "));
                                                    // remove foreign keys from the table schema
                                                    tableSchema.removeForeignKeys(foreignKeySchemasToDrop);
                                                    // drop foreign keys from the database
                                                    return [4 /*yield*/, this.queryRunner.dropForeignKeys(tableSchema, foreignKeySchemasToDrop)];
                                                case 1:
                                                    // drop foreign keys from the database
                                                    _a.sent();
                                                    return [2 /*return*/];
                                            }
                                        });
                                    }); })];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Creates tables that do not exist in the database yet.
                 * New tables are created without foreign and primary keys.
                 * Primary key only can be created in conclusion with auto generated column.
                 */
                SchemaBuilder.prototype.createNewTables = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, PromiseUtils_2.PromiseUtils.runInSequence(this.entityToSyncMetadatas, function (metadata) { return __awaiter(_this, void 0, void 0, function () {
                                        var existTableSchema, tableSchema;
                                        return __generator(this, function (_a) {
                                            switch (_a.label) {
                                                case 0:
                                                    existTableSchema = this.tableSchemas.find(function (table) { return table.name === metadata.table.name; });
                                                    if (existTableSchema)
                                                        return [2 /*return*/];
                                                    this.logger.logSchemaBuild("creating a new table: " + metadata.table.name);
                                                    tableSchema = new TableSchema_2.TableSchema(metadata.table.name, this.metadataColumnsToColumnSchemas(metadata.columns), true);
                                                    this.tableSchemas.push(tableSchema);
                                                    return [4 /*yield*/, this.queryRunner.createTable(tableSchema)];
                                                case 1:
                                                    _a.sent();
                                                    return [2 /*return*/];
                                            }
                                        });
                                    }); })];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Drops all columns that exist in the table, but does not exist in the metadata (left old).
                 * We drop their keys too, since it should be safe.
                 */
                SchemaBuilder.prototype.dropRemovedColumns = function () {
                    var _this = this;
                    return PromiseUtils_2.PromiseUtils.runInSequence(this.entityToSyncMetadatas, function (metadata) { return __awaiter(_this, void 0, void 0, function () {
                        var _this = this;
                        var tableSchema, droppedColumnSchemas;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    tableSchema = this.tableSchemas.find(function (table) { return table.name === metadata.table.name; });
                                    if (!tableSchema)
                                        return [2 /*return*/];
                                    droppedColumnSchemas = tableSchema.columns.filter(function (columnSchema) {
                                        return !metadata.columns.find(function (columnMetadata) { return columnMetadata.name === columnSchema.name; });
                                    });
                                    if (droppedColumnSchemas.length === 0)
                                        return [2 /*return*/];
                                    // drop all foreign keys that has column to be removed in its columns
                                    return [4 /*yield*/, Promise.all(droppedColumnSchemas.map(function (droppedColumnSchema) {
                                            return _this.dropColumnReferencedForeignKeys(metadata.table.name, droppedColumnSchema.name);
                                        }))];
                                case 1:
                                    // drop all foreign keys that has column to be removed in its columns
                                    _a.sent();
                                    // drop all indices that point to this column
                                    return [4 /*yield*/, Promise.all(droppedColumnSchemas.map(function (droppedColumnSchema) {
                                            return _this.dropColumnReferencedIndices(metadata.table.name, droppedColumnSchema.name);
                                        }))];
                                case 2:
                                    // drop all indices that point to this column
                                    _a.sent();
                                    this.logger.logSchemaBuild("columns dropped in " + tableSchema.name + ": " + droppedColumnSchemas.map(function (column) { return column.name; }).join(", "));
                                    // remove columns from the table schema and primary keys of it if its used in the primary keys
                                    tableSchema.removeColumns(droppedColumnSchemas);
                                    tableSchema.removePrimaryKeysOfColumns(droppedColumnSchemas);
                                    // drop columns from the database
                                    return [4 /*yield*/, this.queryRunner.dropColumns(tableSchema, droppedColumnSchemas)];
                                case 3:
                                    // drop columns from the database
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    }); });
                };
                /**
                 * Adds columns from metadata which does not exist in the table.
                 * Columns are created without keys.
                 */
                SchemaBuilder.prototype.addNewColumns = function () {
                    var _this = this;
                    return PromiseUtils_2.PromiseUtils.runInSequence(this.entityToSyncMetadatas, function (metadata) { return __awaiter(_this, void 0, void 0, function () {
                        var tableSchema, newColumnMetadatas, newColumnSchemas;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    tableSchema = this.tableSchemas.find(function (table) { return table.name === metadata.table.name; });
                                    if (!tableSchema)
                                        return [2 /*return*/];
                                    newColumnMetadatas = metadata.columns.filter(function (columnMetadata) {
                                        return !tableSchema.columns.find(function (columnSchema) { return columnSchema.name === columnMetadata.name; });
                                    });
                                    if (newColumnMetadatas.length === 0)
                                        return [2 /*return*/];
                                    this.logger.logSchemaBuild("new columns added: " + newColumnMetadatas.map(function (column) { return column.name; }).join(", "));
                                    newColumnSchemas = this.metadataColumnsToColumnSchemas(newColumnMetadatas);
                                    return [4 /*yield*/, this.queryRunner.addColumns(tableSchema, newColumnSchemas)];
                                case 1:
                                    _a.sent();
                                    tableSchema.addColumns(newColumnSchemas);
                                    return [2 /*return*/];
                            }
                        });
                    }); });
                };
                /**
                 * Update all exist columns which metadata has changed.
                 * Still don't create keys. Also we don't touch foreign keys of the changed columns.
                 */
                SchemaBuilder.prototype.updateExistColumns = function () {
                    var _this = this;
                    return PromiseUtils_2.PromiseUtils.runInSequence(this.entityToSyncMetadatas, function (metadata) { return __awaiter(_this, void 0, void 0, function () {
                        var _this = this;
                        var tableSchema, updatedColumnSchemas, dropRelatedForeignKeysPromises, dropRelatedIndicesPromises, newAndOldColumnSchemas;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    tableSchema = this.tableSchemas.find(function (table) { return table.name === metadata.table.name; });
                                    if (!tableSchema)
                                        return [2 /*return*/];
                                    updatedColumnSchemas = tableSchema.findChangedColumns(this.queryRunner, metadata.columns);
                                    if (updatedColumnSchemas.length === 0)
                                        return [2 /*return*/];
                                    this.logger.logSchemaBuild("columns changed in " + tableSchema.name + ". updating: " + updatedColumnSchemas.map(function (column) { return column.name; }).join(", "));
                                    dropRelatedForeignKeysPromises = updatedColumnSchemas
                                        .filter(function (changedColumnSchema) { return !!metadata.columns.find(function (columnMetadata) { return columnMetadata.name === changedColumnSchema.name; }); })
                                        .map(function (changedColumnSchema) { return _this.dropColumnReferencedForeignKeys(metadata.table.name, changedColumnSchema.name); });
                                    // wait until all related foreign keys are dropped
                                    return [4 /*yield*/, Promise.all(dropRelatedForeignKeysPromises)];
                                case 1:
                                    // wait until all related foreign keys are dropped
                                    _a.sent();
                                    dropRelatedIndicesPromises = updatedColumnSchemas
                                        .filter(function (changedColumnSchema) { return !!metadata.columns.find(function (columnMetadata) { return columnMetadata.name === changedColumnSchema.name; }); })
                                        .map(function (changedColumnSchema) { return _this.dropColumnReferencedIndices(metadata.table.name, changedColumnSchema.name); });
                                    // wait until all related indices are dropped
                                    return [4 /*yield*/, Promise.all(dropRelatedIndicesPromises)];
                                case 2:
                                    // wait until all related indices are dropped
                                    _a.sent();
                                    newAndOldColumnSchemas = updatedColumnSchemas.map(function (changedColumnSchema) {
                                        var columnMetadata = metadata.columns.find(function (column) { return column.name === changedColumnSchema.name; });
                                        var newColumnSchema = ColumnSchema_3.ColumnSchema.create(columnMetadata, _this.queryRunner.normalizeType(columnMetadata));
                                        tableSchema.replaceColumn(changedColumnSchema, newColumnSchema);
                                        return {
                                            newColumn: newColumnSchema,
                                            oldColumn: changedColumnSchema
                                        };
                                    });
                                    return [2 /*return*/, this.queryRunner.changeColumns(tableSchema, newAndOldColumnSchemas)];
                            }
                        });
                    }); });
                };
                /**
                 * Creates primary keys which does not exist in the table yet.
                 */
                SchemaBuilder.prototype.updatePrimaryKeys = function () {
                    var _this = this;
                    return PromiseUtils_2.PromiseUtils.runInSequence(this.entityToSyncMetadatas, function (metadata) { return __awaiter(_this, void 0, void 0, function () {
                        var tableSchema, metadataPrimaryColumns, addedKeys, droppedKeys;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    tableSchema = this.tableSchemas.find(function (table) { return table.name === metadata.table.name && !table.justCreated; });
                                    if (!tableSchema)
                                        return [2 /*return*/];
                                    metadataPrimaryColumns = metadata.columns.filter(function (column) { return column.isPrimary && !column.isGenerated; });
                                    addedKeys = metadataPrimaryColumns
                                        .filter(function (primaryKey) {
                                        return !tableSchema.primaryKeysWithoutGenerated.find(function (dbPrimaryKey) { return dbPrimaryKey.columnName === primaryKey.name; });
                                    })
                                        .map(function (primaryKey) { return new PrimaryKeySchema_2.PrimaryKeySchema("", primaryKey.name); });
                                    droppedKeys = tableSchema.primaryKeysWithoutGenerated.filter(function (primaryKeySchema) {
                                        return !metadataPrimaryColumns.find(function (primaryKeyMetadata) { return primaryKeyMetadata.name === primaryKeySchema.columnName; });
                                    });
                                    if (addedKeys.length === 0 && droppedKeys.length === 0)
                                        return [2 /*return*/];
                                    this.logger.logSchemaBuild("primary keys of " + tableSchema.name + " has changed: dropped - " + (droppedKeys.map(function (key) { return key.columnName; }).join(", ") || "nothing") + "; added - " + (addedKeys.map(function (key) { return key.columnName; }).join(", ") || "nothing"));
                                    tableSchema.addPrimaryKeys(addedKeys);
                                    tableSchema.removePrimaryKeys(droppedKeys);
                                    return [4 /*yield*/, this.queryRunner.updatePrimaryKeys(tableSchema)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    }); });
                };
                /**
                 * Creates foreign keys which does not exist in the table yet.
                 */
                SchemaBuilder.prototype.createForeignKeys = function () {
                    var _this = this;
                    return PromiseUtils_2.PromiseUtils.runInSequence(this.entityToSyncMetadatas, function (metadata) { return __awaiter(_this, void 0, void 0, function () {
                        var tableSchema, newKeys, dbForeignKeys;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    tableSchema = this.tableSchemas.find(function (table) { return table.name === metadata.table.name; });
                                    if (!tableSchema)
                                        return [2 /*return*/];
                                    newKeys = metadata.foreignKeys.filter(function (foreignKey) {
                                        return !tableSchema.foreignKeys.find(function (dbForeignKey) { return dbForeignKey.name === foreignKey.name; });
                                    });
                                    if (newKeys.length === 0)
                                        return [2 /*return*/];
                                    dbForeignKeys = newKeys.map(function (foreignKeyMetadata) { return ForeignKeySchema_2.ForeignKeySchema.create(foreignKeyMetadata); });
                                    this.logger.logSchemaBuild("creating a foreign keys: " + newKeys.map(function (key) { return key.name; }).join(", "));
                                    return [4 /*yield*/, this.queryRunner.createForeignKeys(tableSchema, dbForeignKeys)];
                                case 1:
                                    _a.sent();
                                    tableSchema.addForeignKeys(dbForeignKeys);
                                    return [2 /*return*/];
                            }
                        });
                    }); });
                };
                /**
                 * Creates indices which are missing in db yet, and drops indices which exist in the db,
                 * but does not exist in the metadata anymore.
                 */
                SchemaBuilder.prototype.createIndices = function () {
                    var _this = this;
                    // return Promise.all(this.entityMetadatas.map(metadata => this.createIndices(metadata.table, metadata.indices)));
                    return PromiseUtils_2.PromiseUtils.runInSequence(this.entityToSyncMetadatas, function (metadata) { return __awaiter(_this, void 0, void 0, function () {
                        var _this = this;
                        var tableSchema, dropQueries, addQueries;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    tableSchema = this.tableSchemas.find(function (table) { return table.name === metadata.table.name; });
                                    if (!tableSchema)
                                        return [2 /*return*/];
                                    dropQueries = tableSchema.indices
                                        .filter(function (indexSchema) { return !metadata.indices.find(function (indexMetadata) { return indexMetadata.name === indexSchema.name; }); })
                                        .map(function (indexSchema) { return __awaiter(_this, void 0, void 0, function () {
                                        return __generator(this, function (_a) {
                                            switch (_a.label) {
                                                case 0:
                                                    this.logger.logSchemaBuild("dropping an index: " + indexSchema.name);
                                                    tableSchema.removeIndex(indexSchema);
                                                    return [4 /*yield*/, this.queryRunner.dropIndex(metadata.table.name, indexSchema.name)];
                                                case 1:
                                                    _a.sent();
                                                    return [2 /*return*/];
                                            }
                                        });
                                    }); });
                                    addQueries = metadata.indices
                                        .filter(function (indexMetadata) { return !tableSchema.indices.find(function (indexSchema) { return indexSchema.name === indexMetadata.name; }); })
                                        .map(function (indexMetadata) { return __awaiter(_this, void 0, void 0, function () {
                                        var indexSchema;
                                        return __generator(this, function (_a) {
                                            switch (_a.label) {
                                                case 0:
                                                    indexSchema = IndexSchema_2.IndexSchema.create(indexMetadata);
                                                    tableSchema.indices.push(indexSchema);
                                                    this.logger.logSchemaBuild("adding new index: " + indexSchema.name);
                                                    return [4 /*yield*/, this.queryRunner.createIndex(indexSchema.tableName, indexSchema)];
                                                case 1:
                                                    _a.sent();
                                                    return [2 /*return*/];
                                            }
                                        });
                                    }); });
                                    return [4 /*yield*/, Promise.all(dropQueries.concat(addQueries))];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    }); });
                };
                /**
                 * Drops all indices where given column of the given table is being used.
                 */
                SchemaBuilder.prototype.dropColumnReferencedIndices = function (tableName, columnName) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var allIndexMetadatas, tableSchema, dependIndices, dependIndicesInTable, dropPromises;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    allIndexMetadatas = this.entityMetadatas.reduce(function (all, metadata) { return all.concat(metadata.indices); }, []);
                                    tableSchema = this.tableSchemas.find(function (table) { return table.name === tableName; });
                                    if (!tableSchema)
                                        return [2 /*return*/];
                                    dependIndices = allIndexMetadatas.filter(function (indexMetadata) {
                                        return indexMetadata.tableName === tableName && indexMetadata.columns.indexOf(columnName) !== -1;
                                    });
                                    if (!dependIndices.length)
                                        return [2 /*return*/];
                                    dependIndicesInTable = tableSchema.indices.filter(function (indexSchema) {
                                        return !!dependIndices.find(function (indexMetadata) { return indexSchema.name === indexMetadata.name; });
                                    });
                                    if (dependIndicesInTable.length === 0)
                                        return [2 /*return*/];
                                    this.logger.logSchemaBuild("dropping related indices of " + tableName + "#" + columnName + ": " + dependIndicesInTable.map(function (index) { return index.name; }).join(", "));
                                    dropPromises = dependIndicesInTable.map(function (index) {
                                        tableSchema.removeIndex(index);
                                        return _this.queryRunner.dropIndex(tableSchema.name, index.name);
                                    });
                                    return [4 /*yield*/, Promise.all(dropPromises)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Drops all foreign keys where given column of the given table is being used.
                 */
                SchemaBuilder.prototype.dropColumnReferencedForeignKeys = function (tableName, columnName) {
                    return __awaiter(this, void 0, void 0, function () {
                        var allForeignKeyMetadatas, tableSchema, dependForeignKeys, dependForeignKeyInTable, foreignKeySchemas;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    allForeignKeyMetadatas = this.entityMetadatas.reduce(function (all, metadata) { return all.concat(metadata.foreignKeys); }, []);
                                    tableSchema = this.tableSchemas.find(function (table) { return table.name === tableName; });
                                    if (!tableSchema)
                                        return [2 /*return*/];
                                    dependForeignKeys = allForeignKeyMetadatas.filter(function (foreignKey) {
                                        if (foreignKey.tableName === tableName) {
                                            return !!foreignKey.columns.find(function (fkColumn) {
                                                return fkColumn.name === columnName;
                                            });
                                        }
                                        else if (foreignKey.referencedTableName === tableName) {
                                            return !!foreignKey.referencedColumns.find(function (fkColumn) {
                                                return fkColumn.name === columnName;
                                            });
                                        }
                                        return false;
                                    });
                                    if (!dependForeignKeys.length)
                                        return [2 /*return*/];
                                    dependForeignKeyInTable = dependForeignKeys.filter(function (fk) {
                                        return !!tableSchema.foreignKeys.find(function (dbForeignKey) { return dbForeignKey.name === fk.name; });
                                    });
                                    if (dependForeignKeyInTable.length === 0)
                                        return [2 /*return*/];
                                    this.logger.logSchemaBuild("dropping related foreign keys of " + tableName + "#" + columnName + ": " + dependForeignKeyInTable.map(function (foreignKey) { return foreignKey.name; }).join(", "));
                                    foreignKeySchemas = dependForeignKeyInTable.map(function (foreignKeyMetadata) { return ForeignKeySchema_2.ForeignKeySchema.create(foreignKeyMetadata); });
                                    tableSchema.removeForeignKeys(foreignKeySchemas);
                                    return [4 /*yield*/, this.queryRunner.dropForeignKeys(tableSchema, foreignKeySchemas)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Creates new column schemas from the given column metadatas.
                 */
                SchemaBuilder.prototype.metadataColumnsToColumnSchemas = function (columns) {
                    var _this = this;
                    return columns.map(function (columnMetadata) {
                        return ColumnSchema_3.ColumnSchema.create(columnMetadata, _this.queryRunner.normalizeType(columnMetadata));
                    });
                };
                return SchemaBuilder;
            }());
            exports_124("SchemaBuilder", SchemaBuilder);
        }
    };
});
System.register("typeorm/metadata-args/error/EntityMetadataNotFound", [], function (exports_125, context_125) {
    "use strict";
    var __moduleName = context_125 && context_125.id;
    var EntityMetadataNotFound;
    return {
        setters: [],
        execute: function () {
            /**
             */
            EntityMetadataNotFound = (function (_super) {
                __extends(EntityMetadataNotFound, _super);
                function EntityMetadataNotFound(target) {
                    var _this = _super.call(this) || this;
                    _this.name = "EntityMetadataNotFound";
                    var targetName = typeof target === "function" && target.name ? target.name : target;
                    _this.message = "No metadata for \"" + targetName + "\" was found.";
                    return _this;
                }
                return EntityMetadataNotFound;
            }(Error));
            exports_125("EntityMetadataNotFound", EntityMetadataNotFound);
        }
    };
});
System.register("typeorm/migration/MigrationInterface", [], function (exports_126, context_126) {
    "use strict";
    var __moduleName = context_126 && context_126.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/migration/Migration", [], function (exports_127, context_127) {
    "use strict";
    var __moduleName = context_127 && context_127.id;
    var Migration;
    return {
        setters: [],
        execute: function () {
            /**
             * Represents entity of the migration in the database.
             */
            Migration = (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function Migration(timestamp, name, instance) {
                    this.timestamp = timestamp;
                    this.name = name;
                    this.instance = instance;
                }
                return Migration;
            }());
            exports_127("Migration", Migration);
        }
    };
});
System.register("typeorm/migration/MigrationExecutor", ["typeorm/schema-builder/schema/TableSchema", "typeorm/schema-builder/schema/ColumnSchema", "typeorm/metadata/types/ColumnTypes", "typeorm/query-builder/QueryBuilder", "typeorm/query-runner/QueryRunnerProvider", "typeorm/migration/Migration", "typeorm/util/PromiseUtils"], function (exports_128, context_128) {
    "use strict";
    var __moduleName = context_128 && context_128.id;
    var TableSchema_3, ColumnSchema_4, ColumnTypes_4, QueryBuilder_4, QueryRunnerProvider_5, Migration_1, PromiseUtils_3, MigrationExecutor;
    return {
        setters: [
            function (TableSchema_3_1) {
                TableSchema_3 = TableSchema_3_1;
            },
            function (ColumnSchema_4_1) {
                ColumnSchema_4 = ColumnSchema_4_1;
            },
            function (ColumnTypes_4_1) {
                ColumnTypes_4 = ColumnTypes_4_1;
            },
            function (QueryBuilder_4_1) {
                QueryBuilder_4 = QueryBuilder_4_1;
            },
            function (QueryRunnerProvider_5_1) {
                QueryRunnerProvider_5 = QueryRunnerProvider_5_1;
            },
            function (Migration_1_1) {
                Migration_1 = Migration_1_1;
            },
            function (PromiseUtils_3_1) {
                PromiseUtils_3 = PromiseUtils_3_1;
            }
        ],
        execute: function () {
            /**
             * Executes migrations: runs pending and reverts previously executed migrations.
             */
            MigrationExecutor = (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function MigrationExecutor(connection, queryRunnerProvider) {
                    this.connection = connection;
                    this.queryRunnerProvider = queryRunnerProvider || new QueryRunnerProvider_5.QueryRunnerProvider(connection.driver, true);
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Executes all pending migrations. Pending migrations are migrations that are not yet executed,
                 * thus not saved in the database.
                 */
                MigrationExecutor.prototype.executePendingMigrations = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var queryRunner, entityManager, executedMigrations, lastTimeExecutedMigration, allMigrations, pendingMigrations, transactionStartedByUs, err_3;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.queryRunnerProvider.provide()];
                                case 1:
                                    queryRunner = _a.sent();
                                    entityManager = this.connection.createEntityManagerWithSingleDatabaseConnection(this.queryRunnerProvider);
                                    // create migrations table if its not created yet
                                    return [4 /*yield*/, this.createMigrationsTableIfNotExist()];
                                case 2:
                                    // create migrations table if its not created yet
                                    _a.sent();
                                    return [4 /*yield*/, this.loadExecutedMigrations()];
                                case 3:
                                    executedMigrations = _a.sent();
                                    lastTimeExecutedMigration = this.getLatestMigration(executedMigrations);
                                    allMigrations = this.getMigrations();
                                    pendingMigrations = allMigrations.filter(function (migration) {
                                        // check if we already have executed migration
                                        var executedMigration = executedMigrations.find(function (executedMigration) { return executedMigration.name === migration.name; });
                                        if (executedMigration)
                                            return false;
                                        // migration is new and not executed. now check if its timestamp is correct
                                        if (lastTimeExecutedMigration && migration.timestamp < lastTimeExecutedMigration.timestamp)
                                            throw new Error("New migration found: " + migration.name + ", however this migration's timestamp is not valid. Migration's timestamp should not be older then migrations already executed in the database.");
                                        // every check is passed means that migration was not run yet and we need to run it
                                        return true;
                                    });
                                    // if no migrations are pending then nothing to do here
                                    if (!pendingMigrations.length) {
                                        this.connection.logger.log("info", "No migrations are pending");
                                        return [2 /*return*/];
                                    }
                                    // log information about migration execution
                                    this.connection.logger.log("info", executedMigrations.length + " migrations are already loaded in the database.");
                                    this.connection.logger.log("info", allMigrations.length + " migrations were found in the source code.");
                                    if (lastTimeExecutedMigration)
                                        this.connection.logger.log("info", lastTimeExecutedMigration.name + " is the last executed migration. It was executed on " + new Date(lastTimeExecutedMigration.timestamp * 1000).toString() + ".");
                                    this.connection.logger.log("info", pendingMigrations.length + " migrations are new migrations that needs to be executed.");
                                    transactionStartedByUs = false;
                                    if (!!queryRunner.isTransactionActive()) return [3 /*break*/, 5];
                                    return [4 /*yield*/, queryRunner.beginTransaction()];
                                case 4:
                                    _a.sent();
                                    transactionStartedByUs = true;
                                    _a.label = 5;
                                case 5:
                                    _a.trys.push([5, 9, , 12]);
                                    return [4 /*yield*/, PromiseUtils_3.PromiseUtils.runInSequence(pendingMigrations, function (migration) {
                                            return migration.instance.up(queryRunner, _this.connection, entityManager)
                                                .then(function () {
                                                return _this.insertExecutedMigration(migration);
                                            })
                                                .then(function () {
                                                _this.connection.logger.log("info", "Migration " + migration.name + " has been executed successfully.");
                                            });
                                        })];
                                case 6:
                                    _a.sent();
                                    if (!transactionStartedByUs) return [3 /*break*/, 8];
                                    return [4 /*yield*/, queryRunner.commitTransaction()];
                                case 7:
                                    _a.sent();
                                    _a.label = 8;
                                case 8: return [3 /*break*/, 12];
                                case 9:
                                    err_3 = _a.sent();
                                    if (!transactionStartedByUs) return [3 /*break*/, 11];
                                    return [4 /*yield*/, queryRunner.rollbackTransaction()];
                                case 10:
                                    _a.sent();
                                    _a.label = 11;
                                case 11: throw err_3;
                                case 12: return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Reverts last migration that were run.
                 */
                MigrationExecutor.prototype.undoLastMigration = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var queryRunner, entityManager, executedMigrations, lastTimeExecutedMigration, allMigrations, migrationToRevert, transactionStartedByUs, err_4;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.queryRunnerProvider.provide()];
                                case 1:
                                    queryRunner = _a.sent();
                                    entityManager = this.connection.createEntityManagerWithSingleDatabaseConnection(this.queryRunnerProvider);
                                    // create migrations table if its not created yet
                                    return [4 /*yield*/, this.createMigrationsTableIfNotExist()];
                                case 2:
                                    // create migrations table if its not created yet
                                    _a.sent();
                                    return [4 /*yield*/, this.loadExecutedMigrations()];
                                case 3:
                                    executedMigrations = _a.sent();
                                    lastTimeExecutedMigration = this.getLatestMigration(executedMigrations);
                                    // if no migrations found in the database then nothing to revert
                                    if (!lastTimeExecutedMigration) {
                                        this.connection.logger.log("info", "No migrations was found in the database. Nothing to revert!");
                                        return [2 /*return*/];
                                    }
                                    allMigrations = this.getMigrations();
                                    migrationToRevert = allMigrations.find(function (migration) { return migration.name === lastTimeExecutedMigration.name; });
                                    // if no migrations found in the database then nothing to revert
                                    if (!migrationToRevert)
                                        throw new Error("No migration " + lastTimeExecutedMigration.name + " was found in the source code. Make sure you have this migration in your codebase and its included in the connection options.");
                                    // log information about migration execution
                                    this.connection.logger.log("info", executedMigrations.length + " migrations are already loaded in the database.");
                                    this.connection.logger.log("info", lastTimeExecutedMigration.name + " is the last executed migration. It was executed on " + new Date(lastTimeExecutedMigration.timestamp * 1000).toString() + ".");
                                    this.connection.logger.log("info", "Now reverting it...");
                                    transactionStartedByUs = false;
                                    if (!!queryRunner.isTransactionActive()) return [3 /*break*/, 5];
                                    return [4 /*yield*/, queryRunner.beginTransaction()];
                                case 4:
                                    _a.sent();
                                    transactionStartedByUs = true;
                                    _a.label = 5;
                                case 5:
                                    _a.trys.push([5, 10, , 13]);
                                    return [4 /*yield*/, migrationToRevert.instance.down(queryRunner, this.connection, entityManager)];
                                case 6:
                                    _a.sent();
                                    return [4 /*yield*/, this.deleteExecutedMigration(migrationToRevert)];
                                case 7:
                                    _a.sent();
                                    this.connection.logger.log("info", "Migration " + migrationToRevert.name + " has been reverted successfully.");
                                    if (!transactionStartedByUs) return [3 /*break*/, 9];
                                    return [4 /*yield*/, queryRunner.commitTransaction()];
                                case 8:
                                    _a.sent();
                                    _a.label = 9;
                                case 9: return [3 /*break*/, 13];
                                case 10:
                                    err_4 = _a.sent();
                                    if (!transactionStartedByUs) return [3 /*break*/, 12];
                                    return [4 /*yield*/, queryRunner.rollbackTransaction()];
                                case 11:
                                    _a.sent();
                                    _a.label = 12;
                                case 12: throw err_4;
                                case 13: return [2 /*return*/];
                            }
                        });
                    });
                };
                // -------------------------------------------------------------------------
                // Protected Methods
                // -------------------------------------------------------------------------
                /**
                 * Creates table "migrations" that will store information about executed migrations.
                 */
                MigrationExecutor.prototype.createMigrationsTableIfNotExist = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var queryRunner, tableExist;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.queryRunnerProvider.provide()];
                                case 1:
                                    queryRunner = _a.sent();
                                    return [4 /*yield*/, queryRunner.hasTable("migrations")];
                                case 2:
                                    tableExist = _a.sent();
                                    if (!!tableExist) return [3 /*break*/, 4];
                                    return [4 /*yield*/, queryRunner.createTable(new TableSchema_3.TableSchema("migrations", [
                                            new ColumnSchema_4.ColumnSchema({
                                                name: "timestamp",
                                                type: queryRunner.normalizeType({
                                                    type: ColumnTypes_4.ColumnTypes.NUMBER
                                                }),
                                                isPrimary: true,
                                                isNullable: false
                                            }),
                                            new ColumnSchema_4.ColumnSchema({
                                                name: "name",
                                                type: queryRunner.normalizeType({
                                                    type: ColumnTypes_4.ColumnTypes.STRING
                                                }),
                                                isNullable: false
                                            }),
                                        ]))];
                                case 3:
                                    _a.sent();
                                    _a.label = 4;
                                case 4: return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Loads all migrations that were executed and saved into the database.
                 */
                MigrationExecutor.prototype.loadExecutedMigrations = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var migrationsRaw;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, new QueryBuilder_4.QueryBuilder(this.connection, this.queryRunnerProvider)
                                        .select()
                                        .fromTable("migrations", "migrations")
                                        .getRawMany()];
                                case 1:
                                    migrationsRaw = _a.sent();
                                    return [2 /*return*/, migrationsRaw.map(function (migrationRaw) {
                                            return new Migration_1.Migration(parseInt(migrationRaw["timestamp"]), migrationRaw["name"]);
                                        })];
                            }
                        });
                    });
                };
                /**
                 * Gets all migrations that setup for this connection.
                 */
                MigrationExecutor.prototype.getMigrations = function () {
                    var migrations = this.connection.getMigrations().map(function (migration) {
                        var migrationClassName = migration.constructor.name;
                        var migrationTimestamp = parseInt(migrationClassName.substr(-13));
                        if (!migrationTimestamp)
                            throw new Error("Migration class name should contain a class name at the end of the file. " + migrationClassName + " migration name is wrong.");
                        return new Migration_1.Migration(migrationTimestamp, migrationClassName, migration);
                    });
                    // sort them by timestamp
                    return migrations.sort(function (a, b) { return a.timestamp - b.timestamp; });
                };
                /**
                 * Finds the latest migration (sorts by timestamp) in the given array of migrations.
                 */
                MigrationExecutor.prototype.getLatestMigration = function (migrations) {
                    var sortedMigrations = migrations.map(function (migration) { return migration; }).sort(function (a, b) { return (a.timestamp - b.timestamp) * -1; });
                    return sortedMigrations.length > 0 ? sortedMigrations[0] : undefined;
                };
                /**
                 * Inserts new executed migration's data into migrations table.
                 */
                MigrationExecutor.prototype.insertExecutedMigration = function (migration) {
                    return __awaiter(this, void 0, void 0, function () {
                        var queryRunner;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.queryRunnerProvider.provide()];
                                case 1:
                                    queryRunner = _a.sent();
                                    return [4 /*yield*/, queryRunner.insert("migrations", {
                                            timestamp: migration.timestamp,
                                            name: migration.name,
                                        })];
                                case 2:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Delete previously executed migration's data from the migrations table.
                 */
                MigrationExecutor.prototype.deleteExecutedMigration = function (migration) {
                    return __awaiter(this, void 0, void 0, function () {
                        var queryRunner;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.queryRunnerProvider.provide()];
                                case 1:
                                    queryRunner = _a.sent();
                                    return [4 /*yield*/, queryRunner.delete("migrations", {
                                            timestamp: migration.timestamp,
                                            name: migration.name,
                                        })];
                                case 2:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                return MigrationExecutor;
            }());
            exports_128("MigrationExecutor", MigrationExecutor);
        }
    };
});
System.register("typeorm/connection/error/CannotRunMigrationNotConnectedError", [], function (exports_129, context_129) {
    "use strict";
    var __moduleName = context_129 && context_129.id;
    var CannotRunMigrationNotConnectedError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown when consumer tries to run/revert migrations without connection set.
             */
            CannotRunMigrationNotConnectedError = (function (_super) {
                __extends(CannotRunMigrationNotConnectedError, _super);
                function CannotRunMigrationNotConnectedError(connectionName) {
                    var _this = _super.call(this) || this;
                    _this.name = "CannotRunMigrationNotConnectedError";
                    _this.message = "Cannot run/revert migrations on \"" + connectionName + "\" connection because connection is not yet established.";
                    _this.stack = new Error().stack;
                    return _this;
                }
                return CannotRunMigrationNotConnectedError;
            }(Error));
            exports_129("CannotRunMigrationNotConnectedError", CannotRunMigrationNotConnectedError);
        }
    };
});
System.register("typeorm/repository/error/CustomRepositoryDoesNotHaveEntityError", [], function (exports_130, context_130) {
    "use strict";
    var __moduleName = context_130 && context_130.id;
    var CustomRepositoryDoesNotHaveEntityError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown if custom repositories that extend AbstractRepository classes does not have managed entity.
             */
            CustomRepositoryDoesNotHaveEntityError = (function (_super) {
                __extends(CustomRepositoryDoesNotHaveEntityError, _super);
                function CustomRepositoryDoesNotHaveEntityError(repository) {
                    var _this = _super.call(this, "Custom repository " + (repository instanceof Function ? repository.name : repository.constructor.name) + " does not have managed entity. " +
                        "Did you forget to specify entity for it @EntityRepository(MyEntity)? ") || this;
                    _this.name = "CustomRepositoryDoesNotHaveEntityError";
                    return _this;
                }
                return CustomRepositoryDoesNotHaveEntityError;
            }(Error));
            exports_130("CustomRepositoryDoesNotHaveEntityError", CustomRepositoryDoesNotHaveEntityError);
        }
    };
});
System.register("typeorm/repository/AbstractRepository", ["typeorm/repository/error/CustomRepositoryDoesNotHaveEntityError"], function (exports_131, context_131) {
    "use strict";
    var __moduleName = context_131 && context_131.id;
    var CustomRepositoryDoesNotHaveEntityError_1, AbstractRepository;
    return {
        setters: [
            function (CustomRepositoryDoesNotHaveEntityError_1_1) {
                CustomRepositoryDoesNotHaveEntityError_1 = CustomRepositoryDoesNotHaveEntityError_1_1;
            }
        ],
        execute: function () {
            /**
             * Provides abstract class for custom repositories that do not inherit from original orm Repository.
             * Contains all most-necessary methods to simplify code in the custom repository.
             * All methods are protected thus not exposed and it allows to create encapsulated custom repository.
             *
             * @experimental
             */
            AbstractRepository = (function () {
                function AbstractRepository() {
                }
                Object.defineProperty(AbstractRepository.prototype, "entityManager", {
                    // -------------------------------------------------------------------------
                    // Protected Accessors
                    // -------------------------------------------------------------------------
                    /**
                     * Gets entity manager that allows to perform repository operations with any entity.
                     */
                    get: function () {
                        return this.connection.entityManager;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(AbstractRepository.prototype, "repository", {
                    /**
                     * Gets the original ORM repository for the entity that is managed by this repository.
                     * If current repository does not manage any entity, then exception will be thrown.
                     */
                    get: function () {
                        var target = this.connection.getCustomRepositoryTarget(this);
                        if (!target)
                            throw new CustomRepositoryDoesNotHaveEntityError_1.CustomRepositoryDoesNotHaveEntityError(this.constructor);
                        return this.connection.getRepository(target);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(AbstractRepository.prototype, "treeRepository", {
                    /**
                     * Gets the original ORM tree repository for the entity that is managed by this repository.
                     * If current repository does not manage any entity, then exception will be thrown.
                     */
                    get: function () {
                        var target = this.connection.getCustomRepositoryTarget(this);
                        if (!target)
                            throw new CustomRepositoryDoesNotHaveEntityError_1.CustomRepositoryDoesNotHaveEntityError(this.constructor);
                        return this.connection.getTreeRepository(target);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(AbstractRepository.prototype, "specificRepository", {
                    /**
                     * Gets the original ORM specific repository for the entity that is managed by this repository.
                     * If current repository does not manage any entity, then exception will be thrown.
                     */
                    get: function () {
                        var target = this.connection.getCustomRepositoryTarget(this);
                        if (!target)
                            throw new CustomRepositoryDoesNotHaveEntityError_1.CustomRepositoryDoesNotHaveEntityError(this.constructor);
                        return this.connection.getSpecificRepository(target);
                    },
                    enumerable: true,
                    configurable: true
                });
                // -------------------------------------------------------------------------
                // Protected Methods
                // -------------------------------------------------------------------------
                /**
                 * Creates a new query builder for the repository's entity that can be used to build a sql query.
                 * If current repository does not manage any entity, then exception will be thrown.
                 */
                AbstractRepository.prototype.createQueryBuilder = function (alias) {
                    var target = this.connection.getCustomRepositoryTarget(this.constructor);
                    if (!target)
                        throw new CustomRepositoryDoesNotHaveEntityError_1.CustomRepositoryDoesNotHaveEntityError(this.constructor);
                    return this.connection.getRepository(target).createQueryBuilder(alias);
                };
                /**
                 * Creates a new query builder for the given entity that can be used to build a sql query.
                 */
                AbstractRepository.prototype.createQueryBuilderFor = function (entity, alias) {
                    return this.getRepositoryFor(entity).createQueryBuilder(alias);
                };
                /**
                 * Gets the original ORM repository for the given entity class.
                 */
                AbstractRepository.prototype.getRepositoryFor = function (entity) {
                    return this.entityManager.getRepository(entity);
                };
                /**
                 * Gets the original ORM tree repository for the given entity class.
                 */
                AbstractRepository.prototype.getTreeRepositoryFor = function (entity) {
                    return this.entityManager.getTreeRepository(entity);
                };
                /**
                 * Gets the original ORM specific repository for the given entity class.
                 */
                AbstractRepository.prototype.getSpecificRepositoryFor = function (entity) {
                    return this.entityManager.getSpecificRepository(entity);
                };
                return AbstractRepository;
            }());
            exports_131("AbstractRepository", AbstractRepository);
        }
    };
});
System.register("typeorm/repository/error/CustomRepositoryNotFoundError", [], function (exports_132, context_132) {
    "use strict";
    var __moduleName = context_132 && context_132.id;
    var CustomRepositoryNotFoundError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown if custom repository was not found.
             */
            CustomRepositoryNotFoundError = (function (_super) {
                __extends(CustomRepositoryNotFoundError, _super);
                function CustomRepositoryNotFoundError(repository) {
                    var _this = _super.call(this) || this;
                    _this.name = "CustomRepositoryNotFoundError";
                    _this.message = "Custom repository " + (repository instanceof Function ? repository.name : repository.constructor.name) + " was not found. " +
                        "Did you forgot to put @EntityRepository decorator on it?";
                    return _this;
                }
                return CustomRepositoryNotFoundError;
            }(Error));
            exports_132("CustomRepositoryNotFoundError", CustomRepositoryNotFoundError);
        }
    };
});
System.register("typeorm/repository/error/CustomRepositoryReusedError", [], function (exports_133, context_133) {
    "use strict";
    var __moduleName = context_133 && context_133.id;
    var CustomRepositoryReusedError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown if same custom repository instance is reused between different connections.
             */
            CustomRepositoryReusedError = (function (_super) {
                __extends(CustomRepositoryReusedError, _super);
                function CustomRepositoryReusedError(repository) {
                    var _this = _super.call(this, "Custom entity repository " + (repository instanceof Function ? repository.name : repository.constructor.name) + " " +
                        "was already used in the different connection. You can't share entity repositories between different connections " +
                        "when useContainer is set to true for the entity repository.") || this;
                    _this.name = "CustomRepositoryReusedError";
                    return _this;
                }
                return CustomRepositoryReusedError;
            }(Error));
            exports_133("CustomRepositoryReusedError", CustomRepositoryReusedError);
        }
    };
});
System.register("typeorm/repository/error/CustomRepositoryCannotInheritRepositoryError", [], function (exports_134, context_134) {
    "use strict";
    var __moduleName = context_134 && context_134.id;
    var CustomRepositoryCannotInheritRepositoryError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown if custom repository inherits Repository class however entity is not set in @EntityRepository decorator.
             */
            CustomRepositoryCannotInheritRepositoryError = (function (_super) {
                __extends(CustomRepositoryCannotInheritRepositoryError, _super);
                function CustomRepositoryCannotInheritRepositoryError(repository) {
                    var _this = _super.call(this, "Custom entity repository " + (repository instanceof Function ? repository.name : repository.constructor.name) + " " +
                        " cannot inherit Repository class without entity being set in the @EntityRepository decorator.") || this;
                    _this.name = "CustomRepositoryCannotInheritRepositoryError";
                    return _this;
                }
                return CustomRepositoryCannotInheritRepositoryError;
            }(Error));
            exports_134("CustomRepositoryCannotInheritRepositoryError", CustomRepositoryCannotInheritRepositoryError);
        }
    };
});
System.register("typeorm/connection/Connection", ["typeorm/repository/Repository", "typeorm/connection/error/RepositoryNotFoundError", "typeorm/metadata/EntityListenerMetadata", "typeorm/entity-manager/EntityManager", "typeorm/util/DirectoryExportedClassesLoader", "typeorm/index", "typeorm/metadata-builder/EntityMetadataBuilder", "typeorm/naming-strategy/DefaultNamingStrategy", "typeorm/connection/error/CannotImportAlreadyConnectedError", "typeorm/connection/error/CannotCloseNotConnectedError", "typeorm/connection/error/CannotConnectAlreadyConnectedError", "typeorm/connection/error/NamingStrategyNotFoundError", "typeorm/connection/error/RepositoryNotTreeError", "typeorm/connection/error/CannotSyncNotConnectedError", "typeorm/connection/error/CannotUseNamingStrategyNotConnectedError", "typeorm/subscriber/Broadcaster", "typeorm/lazy-loading/LazyRelationsWrapper", "typeorm/repository/RepositoryAggregator", "typeorm/schema-builder/SchemaBuilder", "typeorm/query-runner/QueryRunnerProvider", "typeorm/metadata-args/error/EntityMetadataNotFound", "typeorm/migration/MigrationExecutor", "typeorm/connection/error/CannotRunMigrationNotConnectedError", "typeorm/platform/PlatformTools", "typeorm/repository/AbstractRepository", "typeorm/repository/error/CustomRepositoryNotFoundError", "typeorm/repository/error/CustomRepositoryReusedError", "typeorm/repository/error/CustomRepositoryCannotInheritRepositoryError"], function (exports_135, context_135) {
    "use strict";
    var __moduleName = context_135 && context_135.id;
    var Repository_3, RepositoryNotFoundError_1, EntityListenerMetadata_1, EntityManager_1, DirectoryExportedClassesLoader_1, index_3, EntityMetadataBuilder_1, DefaultNamingStrategy_1, CannotImportAlreadyConnectedError_1, CannotCloseNotConnectedError_1, CannotConnectAlreadyConnectedError_1, NamingStrategyNotFoundError_1, RepositoryNotTreeError_2, CannotSyncNotConnectedError_1, CannotUseNamingStrategyNotConnectedError_1, Broadcaster_1, LazyRelationsWrapper_1, RepositoryAggregator_2, SchemaBuilder_1, QueryRunnerProvider_6, EntityMetadataNotFound_1, MigrationExecutor_1, CannotRunMigrationNotConnectedError_1, PlatformTools_4, AbstractRepository_1, CustomRepositoryNotFoundError_1, CustomRepositoryReusedError_1, CustomRepositoryCannotInheritRepositoryError_1, Connection;
    return {
        setters: [
            function (Repository_3_1) {
                Repository_3 = Repository_3_1;
            },
            function (RepositoryNotFoundError_1_1) {
                RepositoryNotFoundError_1 = RepositoryNotFoundError_1_1;
            },
            function (EntityListenerMetadata_1_1) {
                EntityListenerMetadata_1 = EntityListenerMetadata_1_1;
            },
            function (EntityManager_1_1) {
                EntityManager_1 = EntityManager_1_1;
            },
            function (DirectoryExportedClassesLoader_1_1) {
                DirectoryExportedClassesLoader_1 = DirectoryExportedClassesLoader_1_1;
            },
            function (index_3_1) {
                index_3 = index_3_1;
            },
            function (EntityMetadataBuilder_1_1) {
                EntityMetadataBuilder_1 = EntityMetadataBuilder_1_1;
            },
            function (DefaultNamingStrategy_1_1) {
                DefaultNamingStrategy_1 = DefaultNamingStrategy_1_1;
            },
            function (CannotImportAlreadyConnectedError_1_1) {
                CannotImportAlreadyConnectedError_1 = CannotImportAlreadyConnectedError_1_1;
            },
            function (CannotCloseNotConnectedError_1_1) {
                CannotCloseNotConnectedError_1 = CannotCloseNotConnectedError_1_1;
            },
            function (CannotConnectAlreadyConnectedError_1_1) {
                CannotConnectAlreadyConnectedError_1 = CannotConnectAlreadyConnectedError_1_1;
            },
            function (NamingStrategyNotFoundError_1_1) {
                NamingStrategyNotFoundError_1 = NamingStrategyNotFoundError_1_1;
            },
            function (RepositoryNotTreeError_2_1) {
                RepositoryNotTreeError_2 = RepositoryNotTreeError_2_1;
            },
            function (CannotSyncNotConnectedError_1_1) {
                CannotSyncNotConnectedError_1 = CannotSyncNotConnectedError_1_1;
            },
            function (CannotUseNamingStrategyNotConnectedError_1_1) {
                CannotUseNamingStrategyNotConnectedError_1 = CannotUseNamingStrategyNotConnectedError_1_1;
            },
            function (Broadcaster_1_1) {
                Broadcaster_1 = Broadcaster_1_1;
            },
            function (LazyRelationsWrapper_1_1) {
                LazyRelationsWrapper_1 = LazyRelationsWrapper_1_1;
            },
            function (RepositoryAggregator_2_1) {
                RepositoryAggregator_2 = RepositoryAggregator_2_1;
            },
            function (SchemaBuilder_1_1) {
                SchemaBuilder_1 = SchemaBuilder_1_1;
            },
            function (QueryRunnerProvider_6_1) {
                QueryRunnerProvider_6 = QueryRunnerProvider_6_1;
            },
            function (EntityMetadataNotFound_1_1) {
                EntityMetadataNotFound_1 = EntityMetadataNotFound_1_1;
            },
            function (MigrationExecutor_1_1) {
                MigrationExecutor_1 = MigrationExecutor_1_1;
            },
            function (CannotRunMigrationNotConnectedError_1_1) {
                CannotRunMigrationNotConnectedError_1 = CannotRunMigrationNotConnectedError_1_1;
            },
            function (PlatformTools_4_1) {
                PlatformTools_4 = PlatformTools_4_1;
            },
            function (AbstractRepository_1_1) {
                AbstractRepository_1 = AbstractRepository_1_1;
            },
            function (CustomRepositoryNotFoundError_1_1) {
                CustomRepositoryNotFoundError_1 = CustomRepositoryNotFoundError_1_1;
            },
            function (CustomRepositoryReusedError_1_1) {
                CustomRepositoryReusedError_1 = CustomRepositoryReusedError_1_1;
            },
            function (CustomRepositoryCannotInheritRepositoryError_1_1) {
                CustomRepositoryCannotInheritRepositoryError_1 = CustomRepositoryCannotInheritRepositoryError_1_1;
            }
        ],
        execute: function () {
            /**
             * Connection is a single database connection to a specific database of a database management system.
             * You can have multiple connections to multiple databases in your application.
             */
            Connection = (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function Connection(name, driver, logger) {
                    /**
                     * All entity metadatas that are registered for this connection.
                     */
                    this.entityMetadatas = [];
                    /**
                     * Stores all registered repositories.
                     */
                    this.repositoryAggregators = [];
                    /**
                     * Stores all entity repository instances.
                     */
                    this.entityRepositories = [];
                    /**
                     * Entity listeners that are registered for this connection.
                     */
                    this.entityListeners = [];
                    /**
                     * Entity subscribers that are registered for this connection.
                     */
                    this.entitySubscribers = [];
                    /**
                     * Registered entity classes to be used for this connection.
                     */
                    this.entityClasses = [];
                    /**
                     * Registered entity schemas to be used for this connection.
                     */
                    this.entitySchemas = [];
                    /**
                     * Registered subscriber classes to be used for this connection.
                     */
                    this.subscriberClasses = [];
                    /**
                     * Registered naming strategy classes to be used for this connection.
                     */
                    this.namingStrategyClasses = [];
                    /**
                     * Registered migration classes to be used for this connection.
                     */
                    this.migrationClasses = [];
                    /**
                     * Indicates if connection has been done or not.
                     */
                    this._isConnected = false;
                    this.name = name;
                    this.driver = driver;
                    this.logger = logger;
                    this._entityManager = this.createEntityManager();
                    this.broadcaster = this.createBroadcaster();
                }
                Object.defineProperty(Connection.prototype, "isConnected", {
                    // -------------------------------------------------------------------------
                    // Accessors
                    // -------------------------------------------------------------------------
                    /**
                     * Indicates if connection to the database already established for this connection.
                     */
                    get: function () {
                        return this._isConnected;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Connection.prototype, "entityManager", {
                    /**
                     * Gets entity manager that allows to perform repository operations with any entity in this connection.
                     */
                    get: function () {
                        // if (!this.isConnected)
                        //     throw new CannotGetEntityManagerNotConnectedError(this.name);
                        return this._entityManager;
                    },
                    enumerable: true,
                    configurable: true
                });
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Performs connection to the database.
                 */
                Connection.prototype.connect = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var error_4;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isConnected)
                                        throw new CannotConnectAlreadyConnectedError_1.CannotConnectAlreadyConnectedError(this.name);
                                    // connect to the database via its driver
                                    return [4 /*yield*/, this.driver.connect()];
                                case 1:
                                    // connect to the database via its driver
                                    _a.sent();
                                    // set connected status for the current connection
                                    this._isConnected = true;
                                    _a.label = 2;
                                case 2:
                                    _a.trys.push([2, 3, , 5]);
                                    this.buildMetadatas();
                                    return [3 /*break*/, 5];
                                case 3:
                                    error_4 = _a.sent();
                                    // if for some reason build metadata fail (for example validation error during entity metadata check)
                                    // connection needs to be closed
                                    return [4 /*yield*/, this.close()];
                                case 4:
                                    // if for some reason build metadata fail (for example validation error during entity metadata check)
                                    // connection needs to be closed
                                    _a.sent();
                                    throw error_4;
                                case 5: return [2 /*return*/, this];
                            }
                        });
                    });
                };
                /**
                 * Closes connection with the database.
                 * Once connection is closed, you cannot use repositories and perform any operations except
                 * opening connection again.
                 */
                Connection.prototype.close = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!this.isConnected)
                                        throw new CannotCloseNotConnectedError_1.CannotCloseNotConnectedError(this.name);
                                    return [4 /*yield*/, this.driver.disconnect()];
                                case 1:
                                    _a.sent();
                                    this._isConnected = false;
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Drops the database and all its data.
                 */
                Connection.prototype.dropDatabase = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var queryRunner;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.driver.createQueryRunner()];
                                case 1:
                                    queryRunner = _a.sent();
                                    return [4 /*yield*/, queryRunner.clearDatabase()];
                                case 2:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Creates database schema for all entities registered in this connection.
                 *
                 * @param dropBeforeSync If set to true then it drops the database with all its tables and data
                 */
                Connection.prototype.syncSchema = function (dropBeforeSync) {
                    if (dropBeforeSync === void 0) { dropBeforeSync = false; }
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!this.isConnected)
                                        return [2 /*return*/, Promise.reject(new CannotSyncNotConnectedError_1.CannotSyncNotConnectedError(this.name))];
                                    if (!dropBeforeSync) return [3 /*break*/, 2];
                                    return [4 /*yield*/, this.dropDatabase()];
                                case 1:
                                    _a.sent();
                                    _a.label = 2;
                                case 2: return [4 /*yield*/, this.createSchemaBuilder().build()];
                                case 3:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Runs all pending migrations.
                 */
                Connection.prototype.runMigrations = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var migrationExecutor;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!this.isConnected)
                                        return [2 /*return*/, Promise.reject(new CannotRunMigrationNotConnectedError_1.CannotRunMigrationNotConnectedError(this.name))];
                                    migrationExecutor = new MigrationExecutor_1.MigrationExecutor(this);
                                    return [4 /*yield*/, migrationExecutor.executePendingMigrations()];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Reverts last executed migration.
                 */
                Connection.prototype.undoLastMigration = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var migrationExecutor;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!this.isConnected)
                                        return [2 /*return*/, Promise.reject(new CannotRunMigrationNotConnectedError_1.CannotRunMigrationNotConnectedError(this.name))];
                                    migrationExecutor = new MigrationExecutor_1.MigrationExecutor(this);
                                    return [4 /*yield*/, migrationExecutor.undoLastMigration()];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Imports entities from the given paths (directories) and registers them in the current connection.
                 */
                Connection.prototype.importEntitiesFromDirectories = function (paths) {
                    this.importEntities(DirectoryExportedClassesLoader_1.importClassesFromDirectories(paths));
                    return this;
                };
                /**
                 * Imports entity schemas from the given paths (directories) and registers them in the current connection.
                 */
                Connection.prototype.importEntitySchemaFromDirectories = function (paths) {
                    this.importEntitySchemas(DirectoryExportedClassesLoader_1.importJsonsFromDirectories(paths));
                    return this;
                };
                /**
                 * Imports subscribers from the given paths (directories) and registers them in the current connection.
                 */
                Connection.prototype.importSubscribersFromDirectories = function (paths) {
                    this.importSubscribers(DirectoryExportedClassesLoader_1.importClassesFromDirectories(paths));
                    return this;
                };
                /**
                 * Imports naming strategies from the given paths (directories) and registers them in the current connection.
                 */
                Connection.prototype.importNamingStrategiesFromDirectories = function (paths) {
                    this.importEntities(DirectoryExportedClassesLoader_1.importClassesFromDirectories(paths));
                    return this;
                };
                /**
                 * Imports migrations from the given paths (directories) and registers them in the current connection.
                 */
                Connection.prototype.importMigrationsFromDirectories = function (paths) {
                    this.importMigrations(DirectoryExportedClassesLoader_1.importClassesFromDirectories(paths));
                    return this;
                };
                /**
                 * Imports entities and registers them in the current connection.
                 */
                Connection.prototype.importEntities = function (entities) {
                    var _this = this;
                    if (this.isConnected)
                        throw new CannotImportAlreadyConnectedError_1.CannotImportAlreadyConnectedError("entities", this.name);
                    entities.forEach(function (cls) { return _this.entityClasses.push(cls); });
                    return this;
                };
                /**
                 * Imports schemas and registers them in the current connection.
                 */
                Connection.prototype.importEntitySchemas = function (schemas) {
                    var _this = this;
                    if (this.isConnected)
                        throw new CannotImportAlreadyConnectedError_1.CannotImportAlreadyConnectedError("schemas", this.name);
                    schemas.forEach(function (schema) { return _this.entitySchemas.push(schema); });
                    return this;
                };
                /**
                 * Imports subscribers and registers them in the current connection.
                 */
                Connection.prototype.importSubscribers = function (subscriberClasses) {
                    var _this = this;
                    if (this.isConnected)
                        throw new CannotImportAlreadyConnectedError_1.CannotImportAlreadyConnectedError("entity subscribers", this.name);
                    subscriberClasses.forEach(function (cls) { return _this.subscriberClasses.push(cls); });
                    return this;
                };
                /**
                 * Imports naming strategies and registers them in the current connection.
                 */
                Connection.prototype.importNamingStrategies = function (strategies) {
                    var _this = this;
                    if (this.isConnected)
                        throw new CannotImportAlreadyConnectedError_1.CannotImportAlreadyConnectedError("naming strategies", this.name);
                    strategies.forEach(function (cls) { return _this.namingStrategyClasses.push(cls); });
                    return this;
                };
                /**
                 * Imports migrations and registers them in the current connection.
                 */
                Connection.prototype.importMigrations = function (migrations) {
                    var _this = this;
                    if (this.isConnected)
                        throw new CannotImportAlreadyConnectedError_1.CannotImportAlreadyConnectedError("migrations", this.name);
                    migrations.forEach(function (cls) { return _this.migrationClasses.push(cls); });
                    return this;
                };
                /**
                 * Sets given naming strategy to be used.
                 * Naming strategy must be set to be used before connection is established.
                 */
                Connection.prototype.useNamingStrategy = function (strategyClassOrName) {
                    if (this.isConnected)
                        throw new CannotUseNamingStrategyNotConnectedError_1.CannotUseNamingStrategyNotConnectedError(this.name);
                    this.usedNamingStrategy = strategyClassOrName;
                    return this;
                };
                /**
                 Gets entity metadata for the given entity class or schema name.
                 */
                Connection.prototype.getMetadata = function (target) {
                    var metadata = this.entityMetadatas.find(function (metadata) { return metadata.target === target || (typeof target === "string" && metadata.targetName === target); });
                    if (!metadata)
                        throw new EntityMetadataNotFound_1.EntityMetadataNotFound(target);
                    return metadata;
                };
                /**
                 * Gets repository for the given entity class or name.
                 */
                Connection.prototype.getRepository = function (entityClassOrName) {
                    return this.findRepositoryAggregator(entityClassOrName).repository;
                };
                /**
                 * Gets tree repository for the given entity class or name.
                 * Only tree-type entities can have a TreeRepository,
                 * like ones decorated with @ClosureEntity decorator.
                 */
                Connection.prototype.getTreeRepository = function (entityClassOrName) {
                    var repository = this.findRepositoryAggregator(entityClassOrName).treeRepository;
                    if (!repository)
                        throw new RepositoryNotTreeError_2.RepositoryNotTreeError(entityClassOrName);
                    return repository;
                };
                /**
                 * Gets specific repository for the given entity class or name.
                 * SpecificRepository is a special repository that contains specific and non standard repository methods.
                 */
                Connection.prototype.getSpecificRepository = function (entityClassOrName) {
                    return this.findRepositoryAggregator(entityClassOrName).specificRepository;
                };
                /**
                 * Creates a new entity manager with a single opened connection to the database.
                 * This may be useful if you want to perform all db queries within one connection.
                 * After finishing with entity manager, don't forget to release it, to release connection back to pool.
                 */
                Connection.prototype.createEntityManagerWithSingleDatabaseConnection = function (queryRunnerProvider) {
                    if (!queryRunnerProvider)
                        queryRunnerProvider = new QueryRunnerProvider_6.QueryRunnerProvider(this.driver, true);
                    return new EntityManager_1.EntityManager(this, queryRunnerProvider);
                };
                /**
                 * Gets migration instances that are registered for this connection.
                 */
                Connection.prototype.getMigrations = function () {
                    if (this.migrationClasses && this.migrationClasses.length) {
                        return this.migrationClasses.map(function (migrationClass) {
                            return index_3.getFromContainer(migrationClass);
                        });
                    }
                    return [];
                };
                /**
                 * Gets custom entity repository marked with @EntityRepository decorator.
                 */
                Connection.prototype.getCustomRepository = function (customRepository) {
                    var entityRepositoryMetadataArgs = index_3.getMetadataArgsStorage().entityRepositories.toArray().find(function (repository) {
                        return repository.target === (customRepository instanceof Function ? customRepository : customRepository.constructor);
                    });
                    if (!entityRepositoryMetadataArgs)
                        throw new CustomRepositoryNotFoundError_1.CustomRepositoryNotFoundError(customRepository);
                    var entityRepositoryInstance = this.entityRepositories.find(function (entityRepository) { return entityRepository.constructor === customRepository; });
                    if (!entityRepositoryInstance) {
                        if (entityRepositoryMetadataArgs.useContainer) {
                            entityRepositoryInstance = index_3.getFromContainer(entityRepositoryMetadataArgs.target);
                            // if we get custom entity repository from container then there is a risk that it already was used
                            // in some different connection. If it was used there then we check it and throw an exception
                            // because we cant override its connection there again
                            if (entityRepositoryInstance instanceof AbstractRepository_1.AbstractRepository || entityRepositoryInstance instanceof Repository_3.Repository) {
                                // NOTE: dynamic access to protected properties. We need this to prevent unwanted properties in those classes to be exposed,
                                // however we need these properties for internal work of the class
                                if (entityRepositoryInstance["connection"] && entityRepositoryInstance["connection"] !== this)
                                    throw new CustomRepositoryReusedError_1.CustomRepositoryReusedError(customRepository);
                            }
                        }
                        else {
                            entityRepositoryInstance = new entityRepositoryMetadataArgs.target();
                        }
                        if (entityRepositoryInstance instanceof AbstractRepository_1.AbstractRepository) {
                            // NOTE: dynamic access to protected properties. We need this to prevent unwanted properties in those classes to be exposed,
                            // however we need these properties for internal work of the class
                            if (!entityRepositoryInstance["connection"])
                                entityRepositoryInstance["connection"] = this;
                        }
                        if (entityRepositoryInstance instanceof Repository_3.Repository) {
                            if (!entityRepositoryMetadataArgs.entity)
                                throw new CustomRepositoryCannotInheritRepositoryError_1.CustomRepositoryCannotInheritRepositoryError(customRepository);
                            // NOTE: dynamic access to protected properties. We need this to prevent unwanted properties in those classes to be exposed,
                            // however we need these properties for internal work of the class
                            entityRepositoryInstance["connection"] = this;
                            entityRepositoryInstance["metadata"] = this.getMetadata(entityRepositoryMetadataArgs.entity);
                        }
                        // register entity repository
                        this.entityRepositories.push(entityRepositoryInstance);
                    }
                    return entityRepositoryInstance;
                };
                /**
                 * Gets custom repository's managed entity.
                 * If given custom repository does not manage any entity then undefined will be returned.
                 */
                Connection.prototype.getCustomRepositoryTarget = function (customRepository) {
                    var entityRepositoryMetadataArgs = index_3.getMetadataArgsStorage().entityRepositories.toArray().find(function (repository) {
                        return repository.target === (customRepository instanceof Function ? customRepository : customRepository.constructor);
                    });
                    if (!entityRepositoryMetadataArgs)
                        throw new CustomRepositoryNotFoundError_1.CustomRepositoryNotFoundError(customRepository);
                    return entityRepositoryMetadataArgs.entity;
                };
                // -------------------------------------------------------------------------
                // Protected Methods
                // -------------------------------------------------------------------------
                /**
                 * Finds repository aggregator of the given entity class or name.
                 */
                Connection.prototype.findRepositoryAggregator = function (entityClassOrName) {
                    // if (!this.isConnected)
                    //     throw new NoConnectionForRepositoryError(this.name);
                    if (!this.entityMetadatas.find(function (metadata) { return metadata.target === entityClassOrName || (typeof entityClassOrName === "string" && metadata.targetName === entityClassOrName); }))
                        throw new RepositoryNotFoundError_1.RepositoryNotFoundError(this.name, entityClassOrName);
                    var metadata = this.getMetadata(entityClassOrName);
                    var repositoryAggregator = this.repositoryAggregators.find(function (repositoryAggregate) { return repositoryAggregate.metadata === metadata; });
                    if (!repositoryAggregator)
                        throw new RepositoryNotFoundError_1.RepositoryNotFoundError(this.name, entityClassOrName);
                    return repositoryAggregator;
                };
                /**
                 * Builds all registered metadatas.
                 */
                Connection.prototype.buildMetadatas = function () {
                    var _this = this;
                    this.entitySubscribers.length = 0;
                    this.entityListeners.length = 0;
                    this.repositoryAggregators.length = 0;
                    this.entityMetadatas.length = 0;
                    var namingStrategy = this.createNamingStrategy();
                    this.driver.namingStrategy = namingStrategy;
                    var lazyRelationsWrapper = this.createLazyRelationsWrapper();
                    // take imported event subscribers
                    if (this.subscriberClasses && this.subscriberClasses.length && !PlatformTools_4.PlatformTools.getEnvVariable("SKIP_SUBSCRIBERS_LOADING")) {
                        index_3.getMetadataArgsStorage()
                            .entitySubscribers
                            .filterByTargets(this.subscriberClasses)
                            .toArray()
                            .map(function (metadata) { return index_3.getFromContainer(metadata.target); })
                            .forEach(function (subscriber) { return _this.entitySubscribers.push(subscriber); });
                    }
                    // take imported entity listeners
                    if (this.entityClasses && this.entityClasses.length) {
                        index_3.getMetadataArgsStorage()
                            .entityListeners
                            .filterByTargets(this.entityClasses)
                            .toArray()
                            .forEach(function (metadata) { return _this.entityListeners.push(new EntityListenerMetadata_1.EntityListenerMetadata(metadata)); });
                    }
                    // build entity metadatas from metadata args storage (collected from decorators)
                    if (this.entityClasses && this.entityClasses.length) {
                        index_3.getFromContainer(EntityMetadataBuilder_1.EntityMetadataBuilder)
                            .buildFromMetadataArgsStorage(this.driver, lazyRelationsWrapper, namingStrategy, this.entityClasses)
                            .forEach(function (metadata) {
                            _this.entityMetadatas.push(metadata);
                            _this.repositoryAggregators.push(new RepositoryAggregator_2.RepositoryAggregator(_this, metadata));
                        });
                    }
                    // build entity metadatas from given entity schemas
                    if (this.entitySchemas && this.entitySchemas.length) {
                        index_3.getFromContainer(EntityMetadataBuilder_1.EntityMetadataBuilder)
                            .buildFromSchemas(this.driver, lazyRelationsWrapper, namingStrategy, this.entitySchemas)
                            .forEach(function (metadata) {
                            _this.entityMetadatas.push(metadata);
                            _this.repositoryAggregators.push(new RepositoryAggregator_2.RepositoryAggregator(_this, metadata));
                        });
                    }
                };
                /**
                 * Creates a naming strategy to be used for this connection.
                 */
                Connection.prototype.createNamingStrategy = function () {
                    var _this = this;
                    // if naming strategies are not loaded, or used naming strategy is not set then use default naming strategy
                    if (!this.namingStrategyClasses || !this.namingStrategyClasses.length || !this.usedNamingStrategy)
                        return index_3.getFromContainer(DefaultNamingStrategy_1.DefaultNamingStrategy);
                    // try to find used naming strategy in the list of loaded naming strategies
                    var namingMetadata = index_3.getMetadataArgsStorage()
                        .namingStrategies
                        .filterByTargets(this.namingStrategyClasses)
                        .toArray()
                        .find(function (strategy) {
                        if (typeof _this.usedNamingStrategy === "string") {
                            return strategy.name === _this.usedNamingStrategy;
                        }
                        else {
                            return strategy.target === _this.usedNamingStrategy;
                        }
                    });
                    // throw an error if not found
                    if (!namingMetadata)
                        throw new NamingStrategyNotFoundError_1.NamingStrategyNotFoundError(this.usedNamingStrategy, this.name);
                    // initialize a naming strategy instance
                    return index_3.getFromContainer(namingMetadata.target);
                };
                /**
                 * Creates a new default entity manager without single connection setup.
                 */
                Connection.prototype.createEntityManager = function () {
                    return new EntityManager_1.EntityManager(this);
                };
                /**
                 * Creates a new entity broadcaster using in this connection.
                 */
                Connection.prototype.createBroadcaster = function () {
                    return new Broadcaster_1.Broadcaster(this, this.entitySubscribers, this.entityListeners);
                };
                /**
                 * Creates a schema builder used to build a database schema for the entities of the current connection.
                 */
                Connection.prototype.createSchemaBuilder = function () {
                    return new SchemaBuilder_1.SchemaBuilder(this.driver, this.logger, this.entityMetadatas);
                };
                /**
                 * Creates a lazy relations wrapper.
                 */
                Connection.prototype.createLazyRelationsWrapper = function () {
                    return new LazyRelationsWrapper_1.LazyRelationsWrapper(this);
                };
                return Connection;
            }());
            exports_135("Connection", Connection);
        }
    };
});
System.register("typeorm/connection/error/ConnectionNotFoundError", [], function (exports_136, context_136) {
    "use strict";
    var __moduleName = context_136 && context_136.id;
    var ConnectionNotFoundError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown when consumer tries to get connection that does not exist.
             */
            ConnectionNotFoundError = (function (_super) {
                __extends(ConnectionNotFoundError, _super);
                function ConnectionNotFoundError(name) {
                    var _this = _super.call(this) || this;
                    _this.name = "ConnectionNotFoundError";
                    _this.message = "Connection \"" + name + "\" was not found.";
                    _this.stack = new Error().stack;
                    return _this;
                }
                return ConnectionNotFoundError;
            }(Error));
            exports_136("ConnectionNotFoundError", ConnectionNotFoundError);
        }
    };
});
System.register("typeorm/driver/mysql/MysqlQueryRunner", ["typeorm/driver/error/TransactionAlreadyStartedError", "typeorm/driver/error/TransactionNotStartedError", "typeorm/driver/error/DataTypeNotSupportedByDriverError", "typeorm/schema-builder/schema/ColumnSchema", "typeorm/schema-builder/schema/TableSchema", "typeorm/schema-builder/schema/ForeignKeySchema", "typeorm/schema-builder/schema/PrimaryKeySchema", "typeorm/schema-builder/schema/IndexSchema", "typeorm/query-runner/error/QueryRunnerAlreadyReleasedError"], function (exports_137, context_137) {
    "use strict";
    var __moduleName = context_137 && context_137.id;
    var TransactionAlreadyStartedError_2, TransactionNotStartedError_2, DataTypeNotSupportedByDriverError_2, ColumnSchema_5, TableSchema_4, ForeignKeySchema_3, PrimaryKeySchema_3, IndexSchema_3, QueryRunnerAlreadyReleasedError_2, MysqlQueryRunner;
    return {
        setters: [
            function (TransactionAlreadyStartedError_2_1) {
                TransactionAlreadyStartedError_2 = TransactionAlreadyStartedError_2_1;
            },
            function (TransactionNotStartedError_2_1) {
                TransactionNotStartedError_2 = TransactionNotStartedError_2_1;
            },
            function (DataTypeNotSupportedByDriverError_2_1) {
                DataTypeNotSupportedByDriverError_2 = DataTypeNotSupportedByDriverError_2_1;
            },
            function (ColumnSchema_5_1) {
                ColumnSchema_5 = ColumnSchema_5_1;
            },
            function (TableSchema_4_1) {
                TableSchema_4 = TableSchema_4_1;
            },
            function (ForeignKeySchema_3_1) {
                ForeignKeySchema_3 = ForeignKeySchema_3_1;
            },
            function (PrimaryKeySchema_3_1) {
                PrimaryKeySchema_3 = PrimaryKeySchema_3_1;
            },
            function (IndexSchema_3_1) {
                IndexSchema_3 = IndexSchema_3_1;
            },
            function (QueryRunnerAlreadyReleasedError_2_1) {
                QueryRunnerAlreadyReleasedError_2 = QueryRunnerAlreadyReleasedError_2_1;
            }
        ],
        execute: function () {
            /**
             * Runs queries on a single mysql database connection.
             */
            MysqlQueryRunner = (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function MysqlQueryRunner(databaseConnection, driver, logger) {
                    this.databaseConnection = databaseConnection;
                    this.driver = driver;
                    this.logger = logger;
                    // -------------------------------------------------------------------------
                    // Protected Properties
                    // -------------------------------------------------------------------------
                    /**
                     * Indicates if connection for this query runner is released.
                     * Once its released, query runner cannot run queries anymore.
                     */
                    this.isReleased = false;
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Releases database connection. This is needed when using connection pooling.
                 * If connection is not from a pool, it should not be released.
                 * You cannot use this class's methods after its released.
                 */
                MysqlQueryRunner.prototype.release = function () {
                    if (this.databaseConnection.releaseCallback) {
                        this.isReleased = true;
                        return this.databaseConnection.releaseCallback();
                    }
                    return Promise.resolve();
                };
                /**
                 * Removes all tables from the currently connected database.
                 * Be careful with using this method and avoid using it in production or migrations
                 * (because it can clear all your database).
                 */
                MysqlQueryRunner.prototype.clearDatabase = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var disableForeignKeysCheckQuery, dropTablesQuery, enableForeignKeysCheckQuery, dropQueries, error_5;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_2.QueryRunnerAlreadyReleasedError();
                                    return [4 /*yield*/, this.beginTransaction()];
                                case 1:
                                    _a.sent();
                                    _a.label = 2;
                                case 2:
                                    _a.trys.push([2, 8, 10, 12]);
                                    disableForeignKeysCheckQuery = "SET FOREIGN_KEY_CHECKS = 0;";
                                    dropTablesQuery = "SELECT concat('DROP TABLE IF EXISTS ', table_name, ';') AS query FROM information_schema.tables WHERE table_schema = '" + this.dbName + "'";
                                    enableForeignKeysCheckQuery = "SET FOREIGN_KEY_CHECKS = 1;";
                                    return [4 /*yield*/, this.query(disableForeignKeysCheckQuery)];
                                case 3:
                                    _a.sent();
                                    return [4 /*yield*/, this.query(dropTablesQuery)];
                                case 4:
                                    dropQueries = _a.sent();
                                    return [4 /*yield*/, Promise.all(dropQueries.map(function (query) { return _this.query(query["query"]); }))];
                                case 5:
                                    _a.sent();
                                    return [4 /*yield*/, this.query(enableForeignKeysCheckQuery)];
                                case 6:
                                    _a.sent();
                                    return [4 /*yield*/, this.commitTransaction()];
                                case 7:
                                    _a.sent();
                                    return [3 /*break*/, 12];
                                case 8:
                                    error_5 = _a.sent();
                                    return [4 /*yield*/, this.rollbackTransaction()];
                                case 9:
                                    _a.sent();
                                    throw error_5;
                                case 10: return [4 /*yield*/, this.release()];
                                case 11:
                                    _a.sent();
                                    return [7 /*endfinally*/];
                                case 12: return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Starts transaction.
                 */
                MysqlQueryRunner.prototype.beginTransaction = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_2.QueryRunnerAlreadyReleasedError();
                                    if (this.databaseConnection.isTransactionActive)
                                        throw new TransactionAlreadyStartedError_2.TransactionAlreadyStartedError();
                                    this.databaseConnection.isTransactionActive = true;
                                    return [4 /*yield*/, this.query("START TRANSACTION")];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Commits transaction.
                 */
                MysqlQueryRunner.prototype.commitTransaction = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_2.QueryRunnerAlreadyReleasedError();
                                    if (!this.databaseConnection.isTransactionActive)
                                        throw new TransactionNotStartedError_2.TransactionNotStartedError();
                                    return [4 /*yield*/, this.query("COMMIT")];
                                case 1:
                                    _a.sent();
                                    this.databaseConnection.isTransactionActive = false;
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Rollbacks transaction.
                 */
                MysqlQueryRunner.prototype.rollbackTransaction = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_2.QueryRunnerAlreadyReleasedError();
                                    if (!this.databaseConnection.isTransactionActive)
                                        throw new TransactionNotStartedError_2.TransactionNotStartedError();
                                    return [4 /*yield*/, this.query("ROLLBACK")];
                                case 1:
                                    _a.sent();
                                    this.databaseConnection.isTransactionActive = false;
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Checks if transaction is in progress.
                 */
                MysqlQueryRunner.prototype.isTransactionActive = function () {
                    return this.databaseConnection.isTransactionActive;
                };
                /**
                 * Executes a given SQL query.
                 */
                MysqlQueryRunner.prototype.query = function (query, parameters) {
                    var _this = this;
                    if (this.isReleased)
                        throw new QueryRunnerAlreadyReleasedError_2.QueryRunnerAlreadyReleasedError();
                    return new Promise(function (ok, fail) {
                        _this.logger.logQuery(query, parameters);
                        _this.databaseConnection.connection.query(query, parameters, function (err, result) {
                            if (err) {
                                _this.logger.logFailedQuery(query, parameters);
                                _this.logger.logQueryError(err);
                                return fail(err);
                            }
                            ok(result);
                        });
                    });
                };
                /**
                 * Insert a new row with given values into given table.
                 */
                MysqlQueryRunner.prototype.insert = function (tableName, keyValues, generatedColumn) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var keys, columns, values, parameters, sql, result;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_2.QueryRunnerAlreadyReleasedError();
                                    keys = Object.keys(keyValues);
                                    columns = keys.map(function (key) { return _this.driver.escapeColumnName(key); }).join(", ");
                                    values = keys.map(function (key) { return "?"; }).join(",");
                                    parameters = keys.map(function (key) { return keyValues[key]; });
                                    sql = "INSERT INTO " + this.driver.escapeTableName(tableName) + "(" + columns + ") VALUES (" + values + ")";
                                    return [4 /*yield*/, this.query(sql, parameters)];
                                case 1:
                                    result = _a.sent();
                                    return [2 /*return*/, generatedColumn ? result.insertId : undefined];
                            }
                        });
                    });
                };
                /**
                 * Updates rows that match given conditions in the given table.
                 */
                MysqlQueryRunner.prototype.update = function (tableName, valuesMap, conditions) {
                    return __awaiter(this, void 0, void 0, function () {
                        var updateValues, conditionString, sql, conditionParams, updateParams, allParameters;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_2.QueryRunnerAlreadyReleasedError();
                                    updateValues = this.parametrize(valuesMap).join(", ");
                                    conditionString = this.parametrize(conditions).join(" AND ");
                                    sql = "UPDATE " + this.driver.escapeTableName(tableName) + " SET " + updateValues + " " + (conditionString ? (" WHERE " + conditionString) : "");
                                    conditionParams = Object.keys(conditions).map(function (key) { return conditions[key]; });
                                    updateParams = Object.keys(valuesMap).map(function (key) { return valuesMap[key]; });
                                    allParameters = updateParams.concat(conditionParams);
                                    return [4 /*yield*/, this.query(sql, allParameters)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Deletes from the given table by a given conditions.
                 */
                MysqlQueryRunner.prototype.delete = function (tableName, conditions, maybeParameters) {
                    return __awaiter(this, void 0, void 0, function () {
                        var conditionString, parameters, sql;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_2.QueryRunnerAlreadyReleasedError();
                                    conditionString = typeof conditions === "string" ? conditions : this.parametrize(conditions).join(" AND ");
                                    parameters = conditions instanceof Object ? Object.keys(conditions).map(function (key) { return conditions[key]; }) : maybeParameters;
                                    sql = "DELETE FROM " + this.driver.escapeTableName(tableName) + " WHERE " + conditionString;
                                    return [4 /*yield*/, this.query(sql, parameters)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Inserts rows into the closure table.
                 */
                MysqlQueryRunner.prototype.insertIntoClosureTable = function (tableName, newEntityId, parentId, hasLevel) {
                    return __awaiter(this, void 0, void 0, function () {
                        var sql, results;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_2.QueryRunnerAlreadyReleasedError();
                                    sql = "";
                                    if (hasLevel) {
                                        sql = "INSERT INTO " + this.driver.escapeTableName(tableName) + "(ancestor, descendant, level) " +
                                            ("SELECT ancestor, " + newEntityId + ", level + 1 FROM " + this.driver.escapeTableName(tableName) + " WHERE descendant = " + parentId + " ") +
                                            ("UNION ALL SELECT " + newEntityId + ", " + newEntityId + ", 1");
                                    }
                                    else {
                                        sql = "INSERT INTO " + this.driver.escapeTableName(tableName) + "(ancestor, descendant) " +
                                            ("SELECT ancestor, " + newEntityId + " FROM " + this.driver.escapeTableName(tableName) + " WHERE descendant = " + parentId + " ") +
                                            ("UNION ALL SELECT " + newEntityId + ", " + newEntityId);
                                    }
                                    return [4 /*yield*/, this.query(sql)];
                                case 1:
                                    _a.sent();
                                    return [4 /*yield*/, this.query("SELECT MAX(level) as level FROM " + this.driver.escapeTableName(tableName) + " WHERE descendant = " + parentId)];
                                case 2:
                                    results = _a.sent();
                                    return [2 /*return*/, results && results[0] && results[0]["level"] ? parseInt(results[0]["level"]) + 1 : 1];
                            }
                        });
                    });
                };
                /**
                 * Loads given table's data from the database.
                 */
                MysqlQueryRunner.prototype.loadTableSchema = function (tableName) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableSchemas;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.loadTableSchemas([tableName])];
                                case 1:
                                    tableSchemas = _a.sent();
                                    return [2 /*return*/, tableSchemas.length > 0 ? tableSchemas[0] : undefined];
                            }
                        });
                    });
                };
                /**
                 * Loads all tables (with given names) from the database and creates a TableSchema from them.
                 */
                MysqlQueryRunner.prototype.loadTableSchemas = function (tableNames) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var tableNamesString, tablesSql, columnsSql, indicesSql, foreignKeysSql, _a, dbTables, dbColumns, dbIndices, dbForeignKeys;
                        return __generator(this, function (_b) {
                            switch (_b.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_2.QueryRunnerAlreadyReleasedError();
                                    // if no tables given then no need to proceed
                                    if (!tableNames || !tableNames.length)
                                        return [2 /*return*/, []];
                                    tableNamesString = tableNames.map(function (tableName) { return "'" + tableName + "'"; }).join(", ");
                                    tablesSql = "SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA = '" + this.dbName + "' AND TABLE_NAME IN (" + tableNamesString + ")";
                                    columnsSql = "SELECT * FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_SCHEMA = '" + this.dbName + "'";
                                    indicesSql = "SELECT * FROM INFORMATION_SCHEMA.STATISTICS WHERE TABLE_SCHEMA = '" + this.dbName + "' AND INDEX_NAME != 'PRIMARY'";
                                    foreignKeysSql = "SELECT * FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE WHERE TABLE_SCHEMA = '" + this.dbName + "' AND REFERENCED_COLUMN_NAME IS NOT NULL";
                                    return [4 /*yield*/, Promise.all([
                                            this.query(tablesSql),
                                            this.query(columnsSql),
                                            this.query(indicesSql),
                                            this.query(foreignKeysSql)
                                        ])];
                                case 1:
                                    _a = _b.sent(), dbTables = _a[0], dbColumns = _a[1], dbIndices = _a[2], dbForeignKeys = _a[3];
                                    // if tables were not found in the db, no need to proceed
                                    if (!dbTables.length)
                                        return [2 /*return*/, []];
                                    // create table schemas for loaded tables
                                    return [2 /*return*/, Promise.all(dbTables.map(function (dbTable) { return __awaiter(_this, void 0, void 0, function () {
                                            var tableSchema, primaryKeys;
                                            return __generator(this, function (_a) {
                                                switch (_a.label) {
                                                    case 0:
                                                        tableSchema = new TableSchema_4.TableSchema(dbTable["TABLE_NAME"]);
                                                        return [4 /*yield*/, this.query("SHOW INDEX FROM `" + dbTable["TABLE_NAME"] + "` WHERE Key_name = 'PRIMARY'")];
                                                    case 1:
                                                        primaryKeys = _a.sent();
                                                        // create column schemas from the loaded columns
                                                        tableSchema.columns = dbColumns
                                                            .filter(function (dbColumn) { return dbColumn["TABLE_NAME"] === tableSchema.name; })
                                                            .map(function (dbColumn) {
                                                            var columnSchema = new ColumnSchema_5.ColumnSchema();
                                                            columnSchema.name = dbColumn["COLUMN_NAME"];
                                                            columnSchema.type = dbColumn["COLUMN_TYPE"].toLowerCase();
                                                            columnSchema.default = dbColumn["COLUMN_DEFAULT"] !== null && dbColumn["COLUMN_DEFAULT"] !== undefined ? dbColumn["COLUMN_DEFAULT"] : undefined;
                                                            columnSchema.isNullable = dbColumn["IS_NULLABLE"] === "YES";
                                                            columnSchema.isPrimary = dbColumn["COLUMN_KEY"].indexOf("PRI") !== -1;
                                                            columnSchema.isUnique = dbColumn["COLUMN_KEY"].indexOf("UNI") !== -1;
                                                            columnSchema.isGenerated = dbColumn["EXTRA"].indexOf("auto_increment") !== -1;
                                                            columnSchema.comment = dbColumn["COLUMN_COMMENT"];
                                                            return columnSchema;
                                                        });
                                                        // create primary keys
                                                        tableSchema.primaryKeys = primaryKeys.map(function (primaryKey) {
                                                            return new PrimaryKeySchema_3.PrimaryKeySchema(primaryKey["Key_name"], primaryKey["Column_name"]);
                                                        });
                                                        // create foreign key schemas from the loaded indices
                                                        tableSchema.foreignKeys = dbForeignKeys
                                                            .filter(function (dbForeignKey) { return dbForeignKey["TABLE_NAME"] === tableSchema.name; })
                                                            .map(function (dbForeignKey) { return new ForeignKeySchema_3.ForeignKeySchema(dbForeignKey["CONSTRAINT_NAME"], [], [], "", ""); }); // todo: fix missing params
                                                        // create index schemas from the loaded indices
                                                        tableSchema.indices = dbIndices
                                                            .filter(function (dbIndex) {
                                                            return dbIndex["TABLE_NAME"] === tableSchema.name &&
                                                                (!tableSchema.foreignKeys.find(function (foreignKey) { return foreignKey.name === dbIndex["INDEX_NAME"]; })) &&
                                                                (!tableSchema.primaryKeys.find(function (primaryKey) { return primaryKey.name === dbIndex["INDEX_NAME"]; }));
                                                        })
                                                            .map(function (dbIndex) { return dbIndex["INDEX_NAME"]; })
                                                            .filter(function (value, index, self) { return self.indexOf(value) === index; }) // unqiue
                                                            .map(function (dbIndexName) {
                                                            var currentDbIndices = dbIndices.filter(function (dbIndex) { return dbIndex["TABLE_NAME"] === tableSchema.name && dbIndex["INDEX_NAME"] === dbIndexName; });
                                                            var columnNames = currentDbIndices.map(function (dbIndex) { return dbIndex["COLUMN_NAME"]; });
                                                            // find a special index - unique index and
                                                            if (currentDbIndices.length === 1 && currentDbIndices[0]["NON_UNIQUE"] === 0) {
                                                                var column = tableSchema.columns.find(function (column) { return column.name === currentDbIndices[0]["INDEX_NAME"] && column.name === currentDbIndices[0]["COLUMN_NAME"]; });
                                                                if (column) {
                                                                    column.isUnique = true;
                                                                    return;
                                                                }
                                                            }
                                                            return new IndexSchema_3.IndexSchema(dbTable["TABLE_NAME"], dbIndexName, columnNames, false /* todo: uniqueness */);
                                                        })
                                                            .filter(function (index) { return !!index; }); // remove empty returns
                                                        return [2 /*return*/, tableSchema];
                                                }
                                            });
                                        }); }))];
                            }
                        });
                    });
                };
                /**
                 * Checks if table with the given name exist in the database.
                 */
                MysqlQueryRunner.prototype.hasTable = function (tableName) {
                    return __awaiter(this, void 0, void 0, function () {
                        var sql, result;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    sql = "SELECT * FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_SCHEMA = '" + this.dbName + "' AND TABLE_NAME = '" + tableName + "'";
                                    return [4 /*yield*/, this.query(sql)];
                                case 1:
                                    result = _a.sent();
                                    return [2 /*return*/, result.length ? true : false];
                            }
                        });
                    });
                };
                /**
                 * Creates a new table from the given table schema and column schemas inside it.
                 */
                MysqlQueryRunner.prototype.createTable = function (table) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var columnDefinitions, sql, primaryKeyColumns;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_2.QueryRunnerAlreadyReleasedError();
                                    columnDefinitions = table.columns.map(function (column) { return _this.buildCreateColumnSql(column, false); }).join(", ");
                                    sql = "CREATE TABLE `" + table.name + "` (" + columnDefinitions;
                                    primaryKeyColumns = table.columns.filter(function (column) { return column.isPrimary && !column.isGenerated; });
                                    if (primaryKeyColumns.length > 0)
                                        sql += ", PRIMARY KEY(" + primaryKeyColumns.map(function (column) { return "`" + column.name + "`"; }).join(", ") + ")";
                                    sql += ") ENGINE=InnoDB;"; // todo: remove engine from here
                                    return [4 /*yield*/, this.query(sql)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Checks if column with the given name exist in the given table.
                 */
                MysqlQueryRunner.prototype.hasColumn = function (tableName, columnName) {
                    return __awaiter(this, void 0, void 0, function () {
                        var sql, result;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    sql = "SELECT * FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_SCHEMA = '" + this.dbName + "' AND TABLE_NAME = '" + tableName + "' AND COLUMN_NAME = '" + columnName + "'";
                                    return [4 /*yield*/, this.query(sql)];
                                case 1:
                                    result = _a.sent();
                                    return [2 /*return*/, result.length ? true : false];
                            }
                        });
                    });
                };
                /**
                 * Creates a new column from the column schema in the table.
                 */
                MysqlQueryRunner.prototype.addColumn = function (tableSchemaOrName, column) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableName, sql;
                        return __generator(this, function (_a) {
                            if (this.isReleased)
                                throw new QueryRunnerAlreadyReleasedError_2.QueryRunnerAlreadyReleasedError();
                            tableName = tableSchemaOrName instanceof TableSchema_4.TableSchema ? tableSchemaOrName.name : tableSchemaOrName;
                            sql = "ALTER TABLE `" + tableName + "` ADD " + this.buildCreateColumnSql(column, false);
                            return [2 /*return*/, this.query(sql)];
                        });
                    });
                };
                /**
                 * Creates a new columns from the column schema in the table.
                 */
                MysqlQueryRunner.prototype.addColumns = function (tableSchemaOrName, columns) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var queries;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_2.QueryRunnerAlreadyReleasedError();
                                    queries = columns.map(function (column) { return _this.addColumn(tableSchemaOrName, column); });
                                    return [4 /*yield*/, Promise.all(queries)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Renames column in the given table.
                 */
                MysqlQueryRunner.prototype.renameColumn = function (tableSchemaOrName, oldColumnSchemaOrName, newColumnSchemaOrName) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableSchema, oldColumn, newColumn;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    tableSchema = undefined;
                                    if (!(tableSchemaOrName instanceof TableSchema_4.TableSchema)) return [3 /*break*/, 1];
                                    tableSchema = tableSchemaOrName;
                                    return [3 /*break*/, 3];
                                case 1: return [4 /*yield*/, this.loadTableSchema(tableSchemaOrName)];
                                case 2:
                                    tableSchema = _a.sent();
                                    _a.label = 3;
                                case 3:
                                    if (!tableSchema)
                                        throw new Error("Table " + tableSchemaOrName + " was not found.");
                                    oldColumn = undefined;
                                    if (oldColumnSchemaOrName instanceof ColumnSchema_5.ColumnSchema) {
                                        oldColumn = oldColumnSchemaOrName;
                                    }
                                    else {
                                        oldColumn = tableSchema.columns.find(function (column) { return column.name === oldColumnSchemaOrName; });
                                    }
                                    if (!oldColumn)
                                        throw new Error("Column \"" + oldColumnSchemaOrName + "\" was not found in the \"" + tableSchemaOrName + "\" table.");
                                    newColumn = undefined;
                                    if (newColumnSchemaOrName instanceof ColumnSchema_5.ColumnSchema) {
                                        newColumn = newColumnSchemaOrName;
                                    }
                                    else {
                                        newColumn = oldColumn.clone();
                                        newColumn.name = newColumnSchemaOrName;
                                    }
                                    return [2 /*return*/, this.changeColumn(tableSchema, oldColumn, newColumn)];
                            }
                        });
                    });
                };
                /**
                 * Changes a column in the table.
                 */
                MysqlQueryRunner.prototype.changeColumn = function (tableSchemaOrName, oldColumnSchemaOrName, newColumn) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableSchema, oldColumn;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_2.QueryRunnerAlreadyReleasedError();
                                    tableSchema = undefined;
                                    if (!(tableSchemaOrName instanceof TableSchema_4.TableSchema)) return [3 /*break*/, 1];
                                    tableSchema = tableSchemaOrName;
                                    return [3 /*break*/, 3];
                                case 1: return [4 /*yield*/, this.loadTableSchema(tableSchemaOrName)];
                                case 2:
                                    tableSchema = _a.sent();
                                    _a.label = 3;
                                case 3:
                                    if (!tableSchema)
                                        throw new Error("Table " + tableSchemaOrName + " was not found.");
                                    oldColumn = undefined;
                                    if (oldColumnSchemaOrName instanceof ColumnSchema_5.ColumnSchema) {
                                        oldColumn = oldColumnSchemaOrName;
                                    }
                                    else {
                                        oldColumn = tableSchema.columns.find(function (column) { return column.name === oldColumnSchemaOrName; });
                                    }
                                    if (!oldColumn)
                                        throw new Error("Column \"" + oldColumnSchemaOrName + "\" was not found in the \"" + tableSchemaOrName + "\" table.");
                                    if (!(newColumn.isUnique === false && oldColumn.isUnique === true)) return [3 /*break*/, 5];
                                    return [4 /*yield*/, this.query("ALTER TABLE `" + tableSchema.name + "` DROP INDEX `" + oldColumn.name + "`")];
                                case 4:
                                    _a.sent();
                                    _a.label = 5;
                                case 5: return [2 /*return*/, this.query("ALTER TABLE `" + tableSchema.name + "` CHANGE `" + oldColumn.name + "` " + this.buildCreateColumnSql(newColumn, oldColumn.isPrimary))];
                            }
                        });
                    });
                };
                /**
                 * Changes a column in the table.
                 */
                MysqlQueryRunner.prototype.changeColumns = function (tableSchema, changedColumns) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var updatePromises;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_2.QueryRunnerAlreadyReleasedError();
                                    updatePromises = changedColumns.map(function (changedColumn) { return __awaiter(_this, void 0, void 0, function () {
                                        return __generator(this, function (_a) {
                                            return [2 /*return*/, this.changeColumn(tableSchema, changedColumn.oldColumn, changedColumn.newColumn)];
                                        });
                                    }); });
                                    return [4 /*yield*/, Promise.all(updatePromises)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Drops column in the table.
                 */
                MysqlQueryRunner.prototype.dropColumn = function (tableSchemaOrName, columnSchemaOrName) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableName, columnName;
                        return __generator(this, function (_a) {
                            tableName = tableSchemaOrName instanceof TableSchema_4.TableSchema ? tableSchemaOrName.name : tableSchemaOrName;
                            columnName = columnSchemaOrName instanceof ColumnSchema_5.ColumnSchema ? columnSchemaOrName.name : columnSchemaOrName;
                            return [2 /*return*/, this.query("ALTER TABLE `" + tableName + "` DROP `" + columnName + "`")];
                        });
                    });
                };
                /**
                 * Drops the columns in the table.
                 */
                MysqlQueryRunner.prototype.dropColumns = function (tableSchemaOrName, columnSchemasOrNames) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var dropPromises;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_2.QueryRunnerAlreadyReleasedError();
                                    dropPromises = columnSchemasOrNames.map(function (column) { return _this.dropColumn(tableSchemaOrName, column); });
                                    return [4 /*yield*/, Promise.all(dropPromises)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Updates table's primary keys.
                 */
                MysqlQueryRunner.prototype.updatePrimaryKeys = function (tableSchema) {
                    return __awaiter(this, void 0, void 0, function () {
                        var primaryColumnNames;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_2.QueryRunnerAlreadyReleasedError();
                                    if (!!tableSchema.hasGeneratedColumn) return [3 /*break*/, 2];
                                    return [4 /*yield*/, this.query("ALTER TABLE " + tableSchema.name + " DROP PRIMARY KEY")];
                                case 1:
                                    _a.sent();
                                    _a.label = 2;
                                case 2:
                                    primaryColumnNames = tableSchema.columns.filter(function (column) { return column.isPrimary && !column.isGenerated; }).map(function (column) { return "`" + column.name + "`"; });
                                    if (!(primaryColumnNames.length > 0)) return [3 /*break*/, 4];
                                    return [4 /*yield*/, this.query("ALTER TABLE " + tableSchema.name + " ADD PRIMARY KEY (" + primaryColumnNames.join(", ") + ")")];
                                case 3:
                                    _a.sent();
                                    _a.label = 4;
                                case 4: return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Creates a new foreign key.
                 */
                MysqlQueryRunner.prototype.createForeignKey = function (tableSchemaOrName, foreignKey) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableName, columnNames, referencedColumnNames, sql;
                        return __generator(this, function (_a) {
                            if (this.isReleased)
                                throw new QueryRunnerAlreadyReleasedError_2.QueryRunnerAlreadyReleasedError();
                            tableName = tableSchemaOrName instanceof TableSchema_4.TableSchema ? tableSchemaOrName.name : tableSchemaOrName;
                            columnNames = foreignKey.columnNames.map(function (column) { return "`" + column + "`"; }).join(", ");
                            referencedColumnNames = foreignKey.referencedColumnNames.map(function (column) { return "`" + column + "`"; }).join(",");
                            sql = "ALTER TABLE " + tableName + " ADD CONSTRAINT `" + foreignKey.name + "` " +
                                ("FOREIGN KEY (" + columnNames + ") ") +
                                ("REFERENCES `" + foreignKey.referencedTableName + "`(" + referencedColumnNames + ")");
                            if (foreignKey.onDelete)
                                sql += " ON DELETE " + foreignKey.onDelete;
                            return [2 /*return*/, this.query(sql)];
                        });
                    });
                };
                /**
                 * Creates a new foreign keys.
                 */
                MysqlQueryRunner.prototype.createForeignKeys = function (tableSchemaOrName, foreignKeys) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var promises;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_2.QueryRunnerAlreadyReleasedError();
                                    promises = foreignKeys.map(function (foreignKey) { return _this.createForeignKey(tableSchemaOrName, foreignKey); });
                                    return [4 /*yield*/, Promise.all(promises)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Drops a foreign key from the table.
                 */
                MysqlQueryRunner.prototype.dropForeignKey = function (tableSchemaOrName, foreignKey) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableName;
                        return __generator(this, function (_a) {
                            if (this.isReleased)
                                throw new QueryRunnerAlreadyReleasedError_2.QueryRunnerAlreadyReleasedError();
                            tableName = tableSchemaOrName instanceof TableSchema_4.TableSchema ? tableSchemaOrName.name : tableSchemaOrName;
                            return [2 /*return*/, this.query("ALTER TABLE `" + tableName + "` DROP FOREIGN KEY `" + foreignKey.name + "`")];
                        });
                    });
                };
                /**
                 * Drops a foreign keys from the table.
                 */
                MysqlQueryRunner.prototype.dropForeignKeys = function (tableSchemaOrName, foreignKeys) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var promises;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_2.QueryRunnerAlreadyReleasedError();
                                    promises = foreignKeys.map(function (foreignKey) { return _this.dropForeignKey(tableSchemaOrName, foreignKey); });
                                    return [4 /*yield*/, Promise.all(promises)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Creates a new index.
                 */
                MysqlQueryRunner.prototype.createIndex = function (tableName, index) {
                    return __awaiter(this, void 0, void 0, function () {
                        var columns, sql;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_2.QueryRunnerAlreadyReleasedError();
                                    columns = index.columnNames.map(function (columnName) { return "`" + columnName + "`"; }).join(", ");
                                    sql = "CREATE " + (index.isUnique ? "UNIQUE " : "") + "INDEX `" + index.name + "` ON `" + tableName + "`(" + columns + ")";
                                    return [4 /*yield*/, this.query(sql)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Drops an index from the table.
                 */
                MysqlQueryRunner.prototype.dropIndex = function (tableName, indexName) {
                    return __awaiter(this, void 0, void 0, function () {
                        var sql;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_2.QueryRunnerAlreadyReleasedError();
                                    sql = "ALTER TABLE `" + tableName + "` DROP INDEX `" + indexName + "`";
                                    return [4 /*yield*/, this.query(sql)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Creates a database type from a given column metadata.
                 */
                MysqlQueryRunner.prototype.normalizeType = function (typeOptions) {
                    switch (typeOptions.type) {
                        case "string":
                            return "varchar(" + (typeOptions.length ? typeOptions.length : 255) + ")";
                        case "text":
                            return "text";
                        case "boolean":
                            return "tinyint(1)";
                        case "integer":
                        case "int":
                            return "int(" + (typeOptions.length ? typeOptions.length : 11) + ")";
                        case "smallint":
                            return "smallint(" + (typeOptions.length ? typeOptions.length : 11) + ")";
                        case "bigint":
                            return "bigint(" + (typeOptions.length ? typeOptions.length : 11) + ")";
                        case "float":
                            return "float";
                        case "double":
                        case "number":
                            return "double";
                        case "decimal":
                            if (typeOptions.precision && typeOptions.scale) {
                                return "decimal(" + typeOptions.precision + "," + typeOptions.scale + ")";
                            }
                            else if (typeOptions.scale) {
                                return "decimal(" + typeOptions.scale + ")";
                            }
                            else if (typeOptions.precision) {
                                return "decimal(" + typeOptions.precision + ")";
                            }
                            else {
                                return "decimal";
                            }
                        case "date":
                            return "date";
                        case "time":
                            return "time";
                        case "datetime":
                            return "datetime";
                        case "json":
                            return "text";
                        case "simple_array":
                            return typeOptions.length ? "varchar(" + typeOptions.length + ")" : "text";
                    }
                    throw new DataTypeNotSupportedByDriverError_2.DataTypeNotSupportedByDriverError(typeOptions.type, "MySQL/MariaDB");
                };
                /**
                 * Checks if "DEFAULT" values in the column metadata and in the database schema are equal.
                 */
                MysqlQueryRunner.prototype.compareDefaultValues = function (columnMetadataValue, databaseValue) {
                    if (typeof columnMetadataValue === "number")
                        return columnMetadataValue === parseInt(databaseValue);
                    if (typeof columnMetadataValue === "boolean")
                        return columnMetadataValue === (!!databaseValue || databaseValue === "false");
                    if (typeof columnMetadataValue === "function")
                        return columnMetadataValue() === databaseValue;
                    return columnMetadataValue === databaseValue;
                };
                /**
                 * Truncates table.
                 */
                MysqlQueryRunner.prototype.truncate = function (tableName) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.query("TRUNCATE TABLE " + this.driver.escapeTableName(tableName))];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                Object.defineProperty(MysqlQueryRunner.prototype, "dbName", {
                    // -------------------------------------------------------------------------
                    // Protected Methods
                    // -------------------------------------------------------------------------
                    /**
                     * Database name shortcut.
                     */
                    get: function () {
                        return this.driver.options.database;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Parametrizes given object of values. Used to create column=value queries.
                 */
                MysqlQueryRunner.prototype.parametrize = function (objectLiteral) {
                    var _this = this;
                    return Object.keys(objectLiteral).map(function (key) { return _this.driver.escapeColumnName(key) + "=?"; });
                };
                /**
                 * Builds a query for create column.
                 */
                MysqlQueryRunner.prototype.buildCreateColumnSql = function (column, skipPrimary) {
                    var c = "`" + column.name + "` " + column.type;
                    if (column.isNullable !== true)
                        c += " NOT NULL";
                    if (column.isUnique === true)
                        c += " UNIQUE";
                    if (column.isGenerated && column.isPrimary && !skipPrimary)
                        c += " PRIMARY KEY";
                    if (column.isGenerated === true)
                        c += " AUTO_INCREMENT";
                    if (column.comment)
                        c += " COMMENT '" + column.comment + "'";
                    if (column.default !== undefined && column.default !== null) {
                        if (typeof column.default === "number") {
                            c += " DEFAULT " + column.default + "";
                        }
                        else if (typeof column.default === "boolean") {
                            c += " DEFAULT " + (column.default === true ? "TRUE" : "FALSE") + "";
                        }
                        else if (typeof column.default === "function") {
                            c += " DEFAULT " + column.default() + "";
                        }
                        else if (typeof column.default === "string") {
                            c += " DEFAULT '" + column.default + "'";
                        }
                        else {
                            c += " DEFAULT " + column.default + "";
                        }
                    }
                    return c;
                };
                return MysqlQueryRunner;
            }());
            exports_137("MysqlQueryRunner", MysqlQueryRunner);
        }
    };
});
System.register("typeorm/driver/mysql/MysqlDriver", ["typeorm/driver/error/ConnectionIsNotSetError", "typeorm/driver/error/DriverPackageNotInstalledError", "typeorm/driver/DriverUtils", "typeorm/driver/mysql/MysqlQueryRunner", "typeorm/metadata/types/ColumnTypes", "typeorm/driver/error/DriverOptionNotSetError", "typeorm/util/DataTransformationUtils", "typeorm/platform/PlatformTools"], function (exports_138, context_138) {
    "use strict";
    var __moduleName = context_138 && context_138.id;
    var ConnectionIsNotSetError_2, DriverPackageNotInstalledError_2, DriverUtils_2, MysqlQueryRunner_1, ColumnTypes_5, DriverOptionNotSetError_2, DataTransformationUtils_3, PlatformTools_5, MysqlDriver;
    return {
        setters: [
            function (ConnectionIsNotSetError_2_1) {
                ConnectionIsNotSetError_2 = ConnectionIsNotSetError_2_1;
            },
            function (DriverPackageNotInstalledError_2_1) {
                DriverPackageNotInstalledError_2 = DriverPackageNotInstalledError_2_1;
            },
            function (DriverUtils_2_1) {
                DriverUtils_2 = DriverUtils_2_1;
            },
            function (MysqlQueryRunner_1_1) {
                MysqlQueryRunner_1 = MysqlQueryRunner_1_1;
            },
            function (ColumnTypes_5_1) {
                ColumnTypes_5 = ColumnTypes_5_1;
            },
            function (DriverOptionNotSetError_2_1) {
                DriverOptionNotSetError_2 = DriverOptionNotSetError_2_1;
            },
            function (DataTransformationUtils_3_1) {
                DataTransformationUtils_3 = DataTransformationUtils_3_1;
            },
            function (PlatformTools_5_1) {
                PlatformTools_5 = PlatformTools_5_1;
            }
        ],
        execute: function () {
            /**
             * Organizes communication with MySQL DBMS.
             */
            MysqlDriver = (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function MysqlDriver(options, logger, mysql) {
                    /**
                     * Pool of database connections.
                     */
                    this.databaseConnectionPool = [];
                    this.options = DriverUtils_2.DriverUtils.buildDriverOptions(options);
                    this.logger = logger;
                    this.mysql = mysql;
                    // validate options to make sure everything is set
                    if (!(this.options.host || (this.options.extra && this.options.extra.socketPath)))
                        throw new DriverOptionNotSetError_2.DriverOptionNotSetError("socketPath and host");
                    if (!this.options.username)
                        throw new DriverOptionNotSetError_2.DriverOptionNotSetError("username");
                    if (!this.options.database)
                        throw new DriverOptionNotSetError_2.DriverOptionNotSetError("database");
                    // if mysql package instance was not set explicitly then try to load it
                    if (!mysql)
                        this.loadDependencies();
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Performs connection to the database.
                 * Based on pooling options, it can either create connection immediately,
                 * either create a pool and create connection when needed.
                 */
                MysqlDriver.prototype.connect = function () {
                    var _this = this;
                    // build connection options for the driver
                    var options = Object.assign({}, {
                        host: this.options.host,
                        user: this.options.username,
                        password: this.options.password,
                        database: this.options.database,
                        port: this.options.port
                    }, this.options.extra || {});
                    // pooling is enabled either when its set explicitly to true,
                    // either when its not defined at all (e.g. enabled by default)
                    if (this.options.usePool === undefined || this.options.usePool === true) {
                        this.pool = this.mysql.createPool(options);
                        return Promise.resolve();
                    }
                    else {
                        return new Promise(function (ok, fail) {
                            var connection = _this.mysql.createConnection(options);
                            _this.databaseConnection = {
                                id: 1,
                                connection: connection,
                                isTransactionActive: false
                            };
                            _this.databaseConnection.connection.connect(function (err) { return err ? fail(err) : ok(); });
                        });
                    }
                };
                /**
                 * Closes connection with the database.
                 */
                MysqlDriver.prototype.disconnect = function () {
                    var _this = this;
                    if (!this.databaseConnection && !this.pool)
                        throw new ConnectionIsNotSetError_2.ConnectionIsNotSetError("mysql");
                    return new Promise(function (ok, fail) {
                        var handler = function (err) { return err ? fail(err) : ok(); };
                        // if pooling is used, then disconnect from it
                        if (_this.pool) {
                            _this.pool.end(handler);
                            _this.pool = undefined;
                            _this.databaseConnectionPool = [];
                        }
                        // if single connection is opened, then close it
                        if (_this.databaseConnection) {
                            _this.databaseConnection.connection.end(handler);
                            _this.databaseConnection = undefined;
                        }
                    });
                };
                /**
                 * Creates a query runner used for common queries.
                 */
                MysqlDriver.prototype.createQueryRunner = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var databaseConnection;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!this.databaseConnection && !this.pool)
                                        return [2 /*return*/, Promise.reject(new ConnectionIsNotSetError_2.ConnectionIsNotSetError("mysql"))];
                                    return [4 /*yield*/, this.retrieveDatabaseConnection()];
                                case 1:
                                    databaseConnection = _a.sent();
                                    return [2 /*return*/, new MysqlQueryRunner_1.MysqlQueryRunner(databaseConnection, this, this.logger)];
                            }
                        });
                    });
                };
                /**
                 * Access to the native implementation of the database.
                 */
                MysqlDriver.prototype.nativeInterface = function () {
                    return {
                        driver: this.mysql,
                        connection: this.databaseConnection ? this.databaseConnection.connection : undefined,
                        pool: this.pool
                    };
                };
                /**
                 * Replaces parameters in the given sql with special escaping character
                 * and an array of parameter names to be passed to a query.
                 */
                MysqlDriver.prototype.escapeQueryWithParameters = function (sql, parameters) {
                    if (!parameters || !Object.keys(parameters).length)
                        return [sql, []];
                    var escapedParameters = [];
                    var keys = Object.keys(parameters).map(function (parameter) { return "(:" + parameter + "\\b)"; }).join("|");
                    sql = sql.replace(new RegExp(keys, "g"), function (key) {
                        escapedParameters.push(parameters[key.substr(1)]);
                        return "?";
                    }); // todo: make replace only in value statements, otherwise problems
                    return [sql, escapedParameters];
                };
                /**
                 * Escapes a column name.
                 */
                MysqlDriver.prototype.escapeColumnName = function (columnName) {
                    return "`" + columnName + "`";
                };
                /**
                 * Escapes an alias.
                 */
                MysqlDriver.prototype.escapeAliasName = function (aliasName) {
                    return "`" + aliasName + "`";
                };
                /**
                 * Escapes a table name.
                 */
                MysqlDriver.prototype.escapeTableName = function (tableName) {
                    return "`" + tableName + "`";
                };
                /**
                 * Prepares given value to a value to be persisted, based on its column type and metadata.
                 */
                MysqlDriver.prototype.preparePersistentValue = function (value, columnMetadata) {
                    if (value === null || value === undefined)
                        return null;
                    switch (columnMetadata.type) {
                        case ColumnTypes_5.ColumnTypes.BOOLEAN:
                            return value === true ? 1 : 0;
                        case ColumnTypes_5.ColumnTypes.DATE:
                            return DataTransformationUtils_3.DataTransformationUtils.mixedDateToDateString(value);
                        case ColumnTypes_5.ColumnTypes.TIME:
                            return DataTransformationUtils_3.DataTransformationUtils.mixedDateToTimeString(value);
                        case ColumnTypes_5.ColumnTypes.DATETIME:
                            if (columnMetadata.localTimezone) {
                                return DataTransformationUtils_3.DataTransformationUtils.mixedDateToDatetimeString(value);
                            }
                            else {
                                return DataTransformationUtils_3.DataTransformationUtils.mixedDateToUtcDatetimeString(value);
                            }
                        case ColumnTypes_5.ColumnTypes.JSON:
                            return JSON.stringify(value);
                        case ColumnTypes_5.ColumnTypes.SIMPLE_ARRAY:
                            return DataTransformationUtils_3.DataTransformationUtils.simpleArrayToString(value);
                    }
                    return value;
                };
                /**
                 * Prepares given value to a value to be persisted, based on its column type or metadata.
                 */
                MysqlDriver.prototype.prepareHydratedValue = function (value, columnMetadata) {
                    switch (columnMetadata.type) {
                        case ColumnTypes_5.ColumnTypes.BOOLEAN:
                            return value ? true : false;
                        case ColumnTypes_5.ColumnTypes.DATETIME:
                            return DataTransformationUtils_3.DataTransformationUtils.normalizeHydratedDate(value, columnMetadata.localTimezone === true);
                        case ColumnTypes_5.ColumnTypes.TIME:
                            return DataTransformationUtils_3.DataTransformationUtils.mixedTimeToString(value);
                        case ColumnTypes_5.ColumnTypes.JSON:
                            return JSON.parse(value);
                        case ColumnTypes_5.ColumnTypes.SIMPLE_ARRAY:
                            return DataTransformationUtils_3.DataTransformationUtils.stringToSimpleArray(value);
                    }
                    return value;
                };
                // -------------------------------------------------------------------------
                // Protected Methods
                // -------------------------------------------------------------------------
                /**
                 * Retrieves a new database connection.
                 * If pooling is enabled then connection from the pool will be retrieved.
                 * Otherwise active connection will be returned.
                 */
                MysqlDriver.prototype.retrieveDatabaseConnection = function () {
                    var _this = this;
                    if (this.pool) {
                        return new Promise(function (ok, fail) {
                            _this.pool.getConnection(function (err, connection) {
                                if (err)
                                    return fail(err);
                                var dbConnection = _this.databaseConnectionPool.find(function (dbConnection) { return dbConnection.connection === connection; });
                                if (!dbConnection) {
                                    dbConnection = {
                                        id: _this.databaseConnectionPool.length,
                                        connection: connection,
                                        isTransactionActive: false
                                    };
                                    dbConnection.releaseCallback = function () {
                                        if (_this.pool && dbConnection) {
                                            connection.release();
                                            _this.databaseConnectionPool.splice(_this.databaseConnectionPool.indexOf(dbConnection), 1);
                                        }
                                        return Promise.resolve();
                                    };
                                    _this.databaseConnectionPool.push(dbConnection);
                                }
                                ok(dbConnection);
                            });
                        });
                    }
                    if (this.databaseConnection)
                        return Promise.resolve(this.databaseConnection);
                    throw new ConnectionIsNotSetError_2.ConnectionIsNotSetError("mysql");
                };
                /**
                 * If driver dependency is not given explicitly, then try to load it via "require".
                 */
                MysqlDriver.prototype.loadDependencies = function () {
                    try {
                        this.mysql = PlatformTools_5.PlatformTools.load("mysql"); // try to load first supported package
                    }
                    catch (e) {
                        try {
                            this.mysql = PlatformTools_5.PlatformTools.load("mysql2"); // try to load second supported package
                        }
                        catch (e) {
                            throw new DriverPackageNotInstalledError_2.DriverPackageNotInstalledError("Mysql", "mysql");
                        }
                    }
                };
                return MysqlDriver;
            }());
            exports_138("MysqlDriver", MysqlDriver);
        }
    };
});
System.register("typeorm/connection/ConnectionOptions", [], function (exports_139, context_139) {
    "use strict";
    var __moduleName = context_139 && context_139.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/connection/error/MissingDriverError", [], function (exports_140, context_140) {
    "use strict";
    var __moduleName = context_140 && context_140.id;
    var MissingDriverError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown when consumer specifies driver type that does not exist or supported.
             */
            MissingDriverError = (function (_super) {
                __extends(MissingDriverError, _super);
                function MissingDriverError(driverType) {
                    var _this = _super.call(this) || this;
                    _this.name = "MissingDriverError";
                    _this.message = "Wrong driver " + driverType + " given. Supported drivers are: \"mysql\", \"postgres\", \"mssql\", \"oracle\", \"mariadb\", \"sqlite\".";
                    _this.stack = new Error().stack;
                    return _this;
                }
                return MissingDriverError;
            }(Error));
            exports_140("MissingDriverError", MissingDriverError);
        }
    };
});
System.register("typeorm/driver/postgres/PostgresQueryRunner", ["typeorm/driver/error/TransactionAlreadyStartedError", "typeorm/driver/error/TransactionNotStartedError", "typeorm/driver/error/DataTypeNotSupportedByDriverError", "typeorm/schema-builder/schema/ColumnSchema", "typeorm/schema-builder/schema/TableSchema", "typeorm/schema-builder/schema/IndexSchema", "typeorm/schema-builder/schema/ForeignKeySchema", "typeorm/schema-builder/schema/PrimaryKeySchema", "typeorm/query-runner/error/QueryRunnerAlreadyReleasedError"], function (exports_141, context_141) {
    "use strict";
    var __moduleName = context_141 && context_141.id;
    var TransactionAlreadyStartedError_3, TransactionNotStartedError_3, DataTypeNotSupportedByDriverError_3, ColumnSchema_6, TableSchema_5, IndexSchema_4, ForeignKeySchema_4, PrimaryKeySchema_4, QueryRunnerAlreadyReleasedError_3, PostgresQueryRunner;
    return {
        setters: [
            function (TransactionAlreadyStartedError_3_1) {
                TransactionAlreadyStartedError_3 = TransactionAlreadyStartedError_3_1;
            },
            function (TransactionNotStartedError_3_1) {
                TransactionNotStartedError_3 = TransactionNotStartedError_3_1;
            },
            function (DataTypeNotSupportedByDriverError_3_1) {
                DataTypeNotSupportedByDriverError_3 = DataTypeNotSupportedByDriverError_3_1;
            },
            function (ColumnSchema_6_1) {
                ColumnSchema_6 = ColumnSchema_6_1;
            },
            function (TableSchema_5_1) {
                TableSchema_5 = TableSchema_5_1;
            },
            function (IndexSchema_4_1) {
                IndexSchema_4 = IndexSchema_4_1;
            },
            function (ForeignKeySchema_4_1) {
                ForeignKeySchema_4 = ForeignKeySchema_4_1;
            },
            function (PrimaryKeySchema_4_1) {
                PrimaryKeySchema_4 = PrimaryKeySchema_4_1;
            },
            function (QueryRunnerAlreadyReleasedError_3_1) {
                QueryRunnerAlreadyReleasedError_3 = QueryRunnerAlreadyReleasedError_3_1;
            }
        ],
        execute: function () {
            /**
             * Runs queries on a single postgres database connection.
             */
            PostgresQueryRunner = (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function PostgresQueryRunner(databaseConnection, driver, logger) {
                    this.databaseConnection = databaseConnection;
                    this.driver = driver;
                    this.logger = logger;
                    // -------------------------------------------------------------------------
                    // Protected Properties
                    // -------------------------------------------------------------------------
                    /**
                     * Indicates if connection for this query runner is released.
                     * Once its released, query runner cannot run queries anymore.
                     */
                    this.isReleased = false;
                    this.schemaName = driver.schemaName || "public";
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Releases database connection. This is needed when using connection pooling.
                 * If connection is not from a pool, it should not be released.
                 */
                PostgresQueryRunner.prototype.release = function () {
                    if (this.databaseConnection.releaseCallback) {
                        this.isReleased = true;
                        return this.databaseConnection.releaseCallback();
                    }
                    return Promise.resolve();
                };
                /**
                 * Removes all tables from the currently connected database.
                 */
                PostgresQueryRunner.prototype.clearDatabase = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var selectDropsQuery, dropQueries, error_6;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_3.QueryRunnerAlreadyReleasedError();
                                    return [4 /*yield*/, this.beginTransaction()];
                                case 1:
                                    _a.sent();
                                    _a.label = 2;
                                case 2:
                                    _a.trys.push([2, 6, 8, 10]);
                                    selectDropsQuery = "SELECT 'DROP TABLE IF EXISTS \"' || tablename || '\" CASCADE;' as query FROM pg_tables WHERE schemaname = '" + this.schemaName + "'";
                                    return [4 /*yield*/, this.query(selectDropsQuery)];
                                case 3:
                                    dropQueries = _a.sent();
                                    return [4 /*yield*/, Promise.all(dropQueries.map(function (q) { return _this.query(q["query"]); }))];
                                case 4:
                                    _a.sent();
                                    return [4 /*yield*/, this.commitTransaction()];
                                case 5:
                                    _a.sent();
                                    return [3 /*break*/, 10];
                                case 6:
                                    error_6 = _a.sent();
                                    return [4 /*yield*/, this.rollbackTransaction()];
                                case 7:
                                    _a.sent();
                                    throw error_6;
                                case 8: return [4 /*yield*/, this.release()];
                                case 9:
                                    _a.sent();
                                    return [7 /*endfinally*/];
                                case 10: return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Starts transaction.
                 */
                PostgresQueryRunner.prototype.beginTransaction = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_3.QueryRunnerAlreadyReleasedError();
                                    if (this.databaseConnection.isTransactionActive)
                                        throw new TransactionAlreadyStartedError_3.TransactionAlreadyStartedError();
                                    this.databaseConnection.isTransactionActive = true;
                                    return [4 /*yield*/, this.query("START TRANSACTION")];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Commits transaction.
                 */
                PostgresQueryRunner.prototype.commitTransaction = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_3.QueryRunnerAlreadyReleasedError();
                                    if (!this.databaseConnection.isTransactionActive)
                                        throw new TransactionNotStartedError_3.TransactionNotStartedError();
                                    return [4 /*yield*/, this.query("COMMIT")];
                                case 1:
                                    _a.sent();
                                    this.databaseConnection.isTransactionActive = false;
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Rollbacks transaction.
                 */
                PostgresQueryRunner.prototype.rollbackTransaction = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_3.QueryRunnerAlreadyReleasedError();
                                    if (!this.databaseConnection.isTransactionActive)
                                        throw new TransactionNotStartedError_3.TransactionNotStartedError();
                                    return [4 /*yield*/, this.query("ROLLBACK")];
                                case 1:
                                    _a.sent();
                                    this.databaseConnection.isTransactionActive = false;
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Checks if transaction is in progress.
                 */
                PostgresQueryRunner.prototype.isTransactionActive = function () {
                    return this.databaseConnection.isTransactionActive;
                };
                /**
                 * Executes a given SQL query.
                 */
                PostgresQueryRunner.prototype.query = function (query, parameters) {
                    var _this = this;
                    if (this.isReleased)
                        throw new QueryRunnerAlreadyReleasedError_3.QueryRunnerAlreadyReleasedError();
                    // console.log("query: ", query);
                    // console.log("parameters: ", parameters);
                    return new Promise(function (ok, fail) {
                        _this.logger.logQuery(query, parameters);
                        _this.databaseConnection.connection.query(query, parameters, function (err, result) {
                            if (err) {
                                _this.logger.logFailedQuery(query, parameters);
                                _this.logger.logQueryError(err);
                                fail(err);
                            }
                            else {
                                ok(result.rows);
                            }
                        });
                    });
                };
                /**
                 * Insert a new row into given table.
                 */
                PostgresQueryRunner.prototype.insert = function (tableName, keyValues, generatedColumn) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var keys, columns, values, sql, parameters, result;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_3.QueryRunnerAlreadyReleasedError();
                                    keys = Object.keys(keyValues);
                                    columns = keys.map(function (key) { return _this.driver.escapeColumnName(key); }).join(", ");
                                    values = keys.map(function (key, index) { return "$" + (index + 1); }).join(",");
                                    sql = columns.length > 0
                                        ? "INSERT INTO " + this.driver.escapeTableName(tableName) + "(" + columns + ") VALUES (" + values + ") " + (generatedColumn ? " RETURNING " + this.driver.escapeColumnName(generatedColumn.name) : "")
                                        : "INSERT INTO " + this.driver.escapeTableName(tableName) + " DEFAULT VALUES " + (generatedColumn ? " RETURNING " + this.driver.escapeColumnName(generatedColumn.name) : "");
                                    parameters = keys.map(function (key) { return keyValues[key]; });
                                    return [4 /*yield*/, this.query(sql, parameters)];
                                case 1:
                                    result = _a.sent();
                                    if (generatedColumn)
                                        return [2 /*return*/, result[0][generatedColumn.name]];
                                    return [2 /*return*/, result];
                            }
                        });
                    });
                };
                /**
                 * Updates rows that match given conditions in the given table.
                 */
                PostgresQueryRunner.prototype.update = function (tableName, valuesMap, conditions) {
                    return __awaiter(this, void 0, void 0, function () {
                        var updateValues, conditionString, query, updateParams, conditionParams, allParameters;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_3.QueryRunnerAlreadyReleasedError();
                                    updateValues = this.parametrize(valuesMap).join(", ");
                                    conditionString = this.parametrize(conditions, Object.keys(valuesMap).length).join(" AND ");
                                    query = "UPDATE " + this.driver.escapeTableName(tableName) + " SET " + updateValues + " " + (conditionString ? (" WHERE " + conditionString) : "");
                                    updateParams = Object.keys(valuesMap).map(function (key) { return valuesMap[key]; });
                                    conditionParams = Object.keys(conditions).map(function (key) { return conditions[key]; });
                                    allParameters = updateParams.concat(conditionParams);
                                    return [4 /*yield*/, this.query(query, allParameters)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Deletes from the given table by a given conditions.
                 */
                PostgresQueryRunner.prototype.delete = function (tableName, conditions, maybeParameters) {
                    return __awaiter(this, void 0, void 0, function () {
                        var conditionString, parameters, sql;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_3.QueryRunnerAlreadyReleasedError();
                                    conditionString = typeof conditions === "string" ? conditions : this.parametrize(conditions).join(" AND ");
                                    parameters = conditions instanceof Object ? Object.keys(conditions).map(function (key) { return conditions[key]; }) : maybeParameters;
                                    sql = "DELETE FROM " + this.driver.escapeTableName(tableName) + " WHERE " + conditionString;
                                    return [4 /*yield*/, this.query(sql, parameters)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Inserts rows into closure table.
                 */
                PostgresQueryRunner.prototype.insertIntoClosureTable = function (tableName, newEntityId, parentId, hasLevel) {
                    return __awaiter(this, void 0, void 0, function () {
                        var sql, results;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_3.QueryRunnerAlreadyReleasedError();
                                    sql = "";
                                    if (hasLevel) {
                                        sql = "INSERT INTO " + this.driver.escapeTableName(tableName) + "(ancestor, descendant, level) " +
                                            ("SELECT ancestor, " + newEntityId + ", level + 1 FROM " + this.driver.escapeTableName(tableName) + " WHERE descendant = " + parentId + " ") +
                                            ("UNION ALL SELECT " + newEntityId + ", " + newEntityId + ", 1");
                                    }
                                    else {
                                        sql = "INSERT INTO " + this.driver.escapeTableName(tableName) + "(ancestor, descendant) " +
                                            ("SELECT ancestor, " + newEntityId + " FROM " + this.driver.escapeTableName(tableName) + " WHERE descendant = " + parentId + " ") +
                                            ("UNION ALL SELECT " + newEntityId + ", " + newEntityId);
                                    }
                                    return [4 /*yield*/, this.query(sql)];
                                case 1:
                                    _a.sent();
                                    return [4 /*yield*/, this.query("SELECT MAX(level) as level FROM " + tableName + " WHERE descendant = " + parentId)];
                                case 2:
                                    results = _a.sent();
                                    return [2 /*return*/, results && results[0] && results[0]["level"] ? parseInt(results[0]["level"]) + 1 : 1];
                            }
                        });
                    });
                };
                /**
                 * Loads given table's data from the database.
                 */
                PostgresQueryRunner.prototype.loadTableSchema = function (tableName) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableSchemas;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.loadTableSchemas([tableName])];
                                case 1:
                                    tableSchemas = _a.sent();
                                    return [2 /*return*/, tableSchemas.length > 0 ? tableSchemas[0] : undefined];
                            }
                        });
                    });
                };
                /**
                 * Loads all tables (with given names) from the database and creates a TableSchema from them.
                 */
                PostgresQueryRunner.prototype.loadTableSchemas = function (tableNames) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableNamesString, tablesSql, columnsSql, indicesSql, foreignKeysSql, uniqueKeysSql, primaryKeysSql, _a, dbTables, dbColumns, dbIndices, dbForeignKeys, dbUniqueKeys, primaryKeys;
                        return __generator(this, function (_b) {
                            switch (_b.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_3.QueryRunnerAlreadyReleasedError();
                                    // if no tables given then no need to proceed
                                    if (!tableNames || !tableNames.length)
                                        return [2 /*return*/, []];
                                    tableNamesString = tableNames.map(function (name) { return "'" + name + "'"; }).join(", ");
                                    tablesSql = "SELECT * FROM information_schema.tables WHERE table_catalog = '" + this.dbName + "' AND table_schema = '" + this.schemaName + "' AND table_name IN (" + tableNamesString + ")";
                                    columnsSql = "SELECT * FROM information_schema.columns WHERE table_catalog = '" + this.dbName + "' AND table_schema = '" + this.schemaName + "'";
                                    indicesSql = "SELECT t.relname AS table_name, i.relname AS index_name, a.attname AS column_name  FROM pg_class t, pg_class i, pg_index ix, pg_attribute a\nWHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid\nAND a.attnum = ANY(ix.indkey) AND t.relkind = 'r' AND t.relname IN (" + tableNamesString + ") ORDER BY t.relname, i.relname";
                                    foreignKeysSql = "SELECT table_name, constraint_name FROM information_schema.table_constraints WHERE table_catalog = '" + this.dbName + "' AND constraint_type = 'FOREIGN KEY'";
                                    uniqueKeysSql = "SELECT * FROM information_schema.table_constraints WHERE table_catalog = '" + this.dbName + "' AND constraint_type = 'UNIQUE'";
                                    primaryKeysSql = "SELECT c.column_name, tc.table_name, tc.constraint_name FROM information_schema.table_constraints tc\nJOIN information_schema.constraint_column_usage AS ccu USING (constraint_schema, constraint_name)\nJOIN information_schema.columns AS c ON c.table_schema = tc.constraint_schema AND tc.table_name = c.table_name AND ccu.column_name = c.column_name\nwhere constraint_type = 'PRIMARY KEY' and tc.table_catalog = '" + this.dbName + "'";
                                    return [4 /*yield*/, Promise.all([
                                            this.query(tablesSql),
                                            this.query(columnsSql),
                                            this.query(indicesSql),
                                            this.query(foreignKeysSql),
                                            this.query(uniqueKeysSql),
                                            this.query(primaryKeysSql),
                                        ])];
                                case 1:
                                    _a = _b.sent(), dbTables = _a[0], dbColumns = _a[1], dbIndices = _a[2], dbForeignKeys = _a[3], dbUniqueKeys = _a[4], primaryKeys = _a[5];
                                    // if tables were not found in the db, no need to proceed
                                    if (!dbTables.length)
                                        return [2 /*return*/, []];
                                    // create table schemas for loaded tables
                                    return [2 /*return*/, dbTables.map(function (dbTable) {
                                            var tableSchema = new TableSchema_5.TableSchema(dbTable["table_name"]);
                                            // create column schemas from the loaded columns
                                            tableSchema.columns = dbColumns
                                                .filter(function (dbColumn) { return dbColumn["table_name"] === tableSchema.name; })
                                                .map(function (dbColumn) {
                                                var columnType = dbColumn["data_type"].toLowerCase() + (dbColumn["character_maximum_length"] !== undefined && dbColumn["character_maximum_length"] !== null ? ("(" + dbColumn["character_maximum_length"] + ")") : "");
                                                var isGenerated = dbColumn["column_default"] === "nextval('" + dbColumn["table_name"] + "_id_seq'::regclass)"
                                                    || dbColumn["column_default"] === "nextval('\"" + dbColumn["table_name"] + "_id_seq\"'::regclass)"
                                                    || /^uuid\_generate\_v\d\(\)/.test(dbColumn["column_default"]);
                                                var columnSchema = new ColumnSchema_6.ColumnSchema();
                                                columnSchema.name = dbColumn["column_name"];
                                                columnSchema.type = columnType;
                                                columnSchema.default = dbColumn["column_default"] !== null && dbColumn["column_default"] !== undefined ? dbColumn["column_default"] : undefined;
                                                columnSchema.isNullable = dbColumn["is_nullable"] === "YES";
                                                // columnSchema.isPrimary = dbColumn["column_key"].indexOf("PRI") !== -1;
                                                columnSchema.isGenerated = isGenerated;
                                                columnSchema.comment = ""; // dbColumn["COLUMN_COMMENT"];
                                                columnSchema.isUnique = !!dbUniqueKeys.find(function (key) { return key["constraint_name"] === "uk_" + dbColumn["table_name"] + "_" + dbColumn["column_name"]; });
                                                return columnSchema;
                                            });
                                            // create primary key schema
                                            tableSchema.primaryKeys = primaryKeys
                                                .filter(function (primaryKey) { return primaryKey["table_name"] === tableSchema.name; })
                                                .map(function (primaryKey) { return new PrimaryKeySchema_4.PrimaryKeySchema(primaryKey["constraint_name"], primaryKey["column_name"]); });
                                            // create foreign key schemas from the loaded indices
                                            tableSchema.foreignKeys = dbForeignKeys
                                                .filter(function (dbForeignKey) { return dbForeignKey["table_name"] === tableSchema.name; })
                                                .map(function (dbForeignKey) { return new ForeignKeySchema_4.ForeignKeySchema(dbForeignKey["constraint_name"], [], [], "", ""); }); // todo: fix missing params
                                            // create unique key schemas from the loaded indices
                                            /*tableSchema.uniqueKeys = dbUniqueKeys
                                                .filter(dbUniqueKey => dbUniqueKey["table_name"] === tableSchema.name)
                                                .map(dbUniqueKey => {
                                                    return new UniqueKeySchema(dbUniqueKey["TABLE_NAME"], dbUniqueKey["CONSTRAINT_NAME"], [/!* todo *!/]);
                                                });*/
                                            // create index schemas from the loaded indices
                                            tableSchema.indices = dbIndices
                                                .filter(function (dbIndex) {
                                                return dbIndex["table_name"] === tableSchema.name &&
                                                    (!tableSchema.foreignKeys.find(function (foreignKey) { return foreignKey.name === dbIndex["index_name"]; })) &&
                                                    (!tableSchema.primaryKeys.find(function (primaryKey) { return primaryKey.name === dbIndex["index_name"]; })) &&
                                                    (!dbUniqueKeys.find(function (key) { return key["constraint_name"] === dbIndex["index_name"]; }));
                                            })
                                                .map(function (dbIndex) { return dbIndex["index_name"]; })
                                                .filter(function (value, index, self) { return self.indexOf(value) === index; }) // unqiue
                                                .map(function (dbIndexName) {
                                                var columnNames = dbIndices
                                                    .filter(function (dbIndex) { return dbIndex["table_name"] === tableSchema.name && dbIndex["index_name"] === dbIndexName; })
                                                    .map(function (dbIndex) { return dbIndex["column_name"]; });
                                                return new IndexSchema_4.IndexSchema(dbTable["TABLE_NAME"], dbIndexName, columnNames, false /* todo: uniqueness */);
                                            });
                                            return tableSchema;
                                        })];
                            }
                        });
                    });
                };
                /**
                 * Checks if table with the given name exist in the database.
                 */
                PostgresQueryRunner.prototype.hasTable = function (tableName) {
                    return __awaiter(this, void 0, void 0, function () {
                        var sql, result;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    sql = "SELECT * FROM information_schema.tables WHERE table_catalog = '" + this.dbName + "' AND table_schema = '" + this.schemaName + "' AND table_name = '" + tableName + "'";
                                    return [4 /*yield*/, this.query(sql)];
                                case 1:
                                    result = _a.sent();
                                    return [2 /*return*/, result.length ? true : false];
                            }
                        });
                    });
                };
                /**
                 * Creates a new table from the given table metadata and column metadatas.
                 */
                PostgresQueryRunner.prototype.createTable = function (table) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var columnDefinitions, sql, primaryKeyColumns;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_3.QueryRunnerAlreadyReleasedError();
                                    columnDefinitions = table.columns.map(function (column) { return _this.buildCreateColumnSql(column, false); }).join(", ");
                                    sql = "CREATE SCHEMA IF NOT EXISTS \"" + this.schemaName + "\";CREATE TABLE \"" + table.name + "\" (" + columnDefinitions;
                                    sql += table.columns
                                        .filter(function (column) { return column.isUnique; })
                                        .map(function (column) { return ", CONSTRAINT \"uk_" + table.name + "_" + column.name + "\" UNIQUE (\"" + column.name + "\")"; })
                                        .join(" ");
                                    primaryKeyColumns = table.columns.filter(function (column) { return column.isPrimary && !column.isGenerated; });
                                    if (primaryKeyColumns.length > 0)
                                        sql += ", PRIMARY KEY(" + primaryKeyColumns.map(function (column) { return "\"" + column.name + "\""; }).join(", ") + ")";
                                    sql += ")";
                                    return [4 /*yield*/, this.query(sql)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Checks if column with the given name exist in the given table.
                 */
                PostgresQueryRunner.prototype.hasColumn = function (tableName, columnName) {
                    return __awaiter(this, void 0, void 0, function () {
                        var sql, result;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    sql = "SELECT * FROM information_schema.columns WHERE table_catalog = '" + this.dbName + "' AND table_schema = '" + this.schemaName + "' AND table_name = '" + tableName + "' AND column_name = '" + columnName + "'";
                                    return [4 /*yield*/, this.query(sql)];
                                case 1:
                                    result = _a.sent();
                                    return [2 /*return*/, result.length ? true : false];
                            }
                        });
                    });
                };
                /**
                 * Creates a new column from the column schema in the table.
                 */
                PostgresQueryRunner.prototype.addColumn = function (tableSchemaOrName, column) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableName, sql;
                        return __generator(this, function (_a) {
                            if (this.isReleased)
                                throw new QueryRunnerAlreadyReleasedError_3.QueryRunnerAlreadyReleasedError();
                            tableName = tableSchemaOrName instanceof TableSchema_5.TableSchema ? tableSchemaOrName.name : tableSchemaOrName;
                            sql = "ALTER TABLE \"" + tableName + "\" ADD " + this.buildCreateColumnSql(column, false);
                            return [2 /*return*/, this.query(sql)];
                        });
                    });
                };
                /**
                 * Creates a new columns from the column schema in the table.
                 */
                PostgresQueryRunner.prototype.addColumns = function (tableSchemaOrName, columns) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var queries;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_3.QueryRunnerAlreadyReleasedError();
                                    queries = columns.map(function (column) { return _this.addColumn(tableSchemaOrName, column); });
                                    return [4 /*yield*/, Promise.all(queries)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Renames column in the given table.
                 */
                PostgresQueryRunner.prototype.renameColumn = function (tableSchemaOrName, oldColumnSchemaOrName, newColumnSchemaOrName) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableSchema, oldColumn, newColumn;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    tableSchema = undefined;
                                    if (!(tableSchemaOrName instanceof TableSchema_5.TableSchema)) return [3 /*break*/, 1];
                                    tableSchema = tableSchemaOrName;
                                    return [3 /*break*/, 3];
                                case 1: return [4 /*yield*/, this.loadTableSchema(tableSchemaOrName)];
                                case 2:
                                    tableSchema = _a.sent();
                                    _a.label = 3;
                                case 3:
                                    if (!tableSchema)
                                        throw new Error("Table " + tableSchemaOrName + " was not found.");
                                    oldColumn = undefined;
                                    if (oldColumnSchemaOrName instanceof ColumnSchema_6.ColumnSchema) {
                                        oldColumn = oldColumnSchemaOrName;
                                    }
                                    else {
                                        oldColumn = tableSchema.columns.find(function (column) { return column.name === oldColumnSchemaOrName; });
                                    }
                                    if (!oldColumn)
                                        throw new Error("Column \"" + oldColumnSchemaOrName + "\" was not found in the \"" + tableSchemaOrName + "\" table.");
                                    newColumn = undefined;
                                    if (newColumnSchemaOrName instanceof ColumnSchema_6.ColumnSchema) {
                                        newColumn = newColumnSchemaOrName;
                                    }
                                    else {
                                        newColumn = oldColumn.clone();
                                        newColumn.name = newColumnSchemaOrName;
                                    }
                                    return [2 /*return*/, this.changeColumn(tableSchema, oldColumn, newColumn)];
                            }
                        });
                    });
                };
                /**
                 * Changes a column in the table.
                 */
                PostgresQueryRunner.prototype.changeColumn = function (tableSchemaOrName, oldColumnSchemaOrName, newColumn) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableSchema, oldColumn, sql, sql;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_3.QueryRunnerAlreadyReleasedError();
                                    tableSchema = undefined;
                                    if (!(tableSchemaOrName instanceof TableSchema_5.TableSchema)) return [3 /*break*/, 1];
                                    tableSchema = tableSchemaOrName;
                                    return [3 /*break*/, 3];
                                case 1: return [4 /*yield*/, this.loadTableSchema(tableSchemaOrName)];
                                case 2:
                                    tableSchema = _a.sent();
                                    _a.label = 3;
                                case 3:
                                    if (!tableSchema)
                                        throw new Error("Table " + tableSchemaOrName + " was not found.");
                                    oldColumn = undefined;
                                    if (oldColumnSchemaOrName instanceof ColumnSchema_6.ColumnSchema) {
                                        oldColumn = oldColumnSchemaOrName;
                                    }
                                    else {
                                        oldColumn = tableSchema.columns.find(function (column) { return column.name === oldColumnSchemaOrName; });
                                    }
                                    if (!oldColumn)
                                        throw new Error("Column \"" + oldColumnSchemaOrName + "\" was not found in the \"" + tableSchemaOrName + "\" table.");
                                    if (!(oldColumn.type !== newColumn.type ||
                                        oldColumn.name !== newColumn.name)) return [3 /*break*/, 5];
                                    sql = "ALTER TABLE \"" + tableSchema.name + "\" ALTER COLUMN \"" + oldColumn.name + "\"";
                                    if (oldColumn.type !== newColumn.type) {
                                        sql += " TYPE " + newColumn.type;
                                    }
                                    if (oldColumn.name !== newColumn.name) {
                                        sql += " RENAME TO " + newColumn.name;
                                    }
                                    return [4 /*yield*/, this.query(sql)];
                                case 4:
                                    _a.sent();
                                    _a.label = 5;
                                case 5:
                                    if (!(oldColumn.isNullable !== newColumn.isNullable)) return [3 /*break*/, 7];
                                    sql = "ALTER TABLE \"" + tableSchema.name + "\" ALTER COLUMN \"" + oldColumn.name + "\"";
                                    if (newColumn.isNullable) {
                                        sql += " DROP NOT NULL";
                                    }
                                    else {
                                        sql += " SET NOT NULL";
                                    }
                                    return [4 /*yield*/, this.query(sql)];
                                case 6:
                                    _a.sent();
                                    _a.label = 7;
                                case 7:
                                    if (!(oldColumn.isGenerated !== newColumn.isGenerated)) return [3 /*break*/, 13];
                                    if (!(!oldColumn.isGenerated && newColumn.type !== "uuid")) return [3 /*break*/, 10];
                                    return [4 /*yield*/, this.query("CREATE SEQUENCE \"" + tableSchema.name + "_id_seq\" OWNED BY \"" + tableSchema.name + "\".\"" + oldColumn.name + "\"")];
                                case 8:
                                    _a.sent();
                                    return [4 /*yield*/, this.query("ALTER TABLE \"" + tableSchema.name + "\" ALTER COLUMN \"" + oldColumn.name + "\" SET DEFAULT nextval('\"" + tableSchema.name + "_id_seq\"')")];
                                case 9:
                                    _a.sent();
                                    return [3 /*break*/, 13];
                                case 10: return [4 /*yield*/, this.query("ALTER TABLE \"" + tableSchema.name + "\" ALTER COLUMN \"" + oldColumn.name + "\" DROP DEFAULT")];
                                case 11:
                                    _a.sent();
                                    return [4 /*yield*/, this.query("DROP SEQUENCE \"" + tableSchema.name + "_id_seq\"")];
                                case 12:
                                    _a.sent();
                                    _a.label = 13;
                                case 13:
                                    if (!(oldColumn.comment !== newColumn.comment)) return [3 /*break*/, 15];
                                    return [4 /*yield*/, this.query("COMMENT ON COLUMN \"" + tableSchema.name + "\".\"" + oldColumn.name + "\" is '" + newColumn.comment + "'")];
                                case 14:
                                    _a.sent();
                                    _a.label = 15;
                                case 15:
                                    if (!(oldColumn.isUnique !== newColumn.isUnique)) return [3 /*break*/, 19];
                                    if (!(newColumn.isUnique === true)) return [3 /*break*/, 17];
                                    return [4 /*yield*/, this.query("ALTER TABLE \"" + tableSchema.name + "\" ADD CONSTRAINT \"uk_" + newColumn.name + "\" UNIQUE (\"" + newColumn.name + "\")")];
                                case 16:
                                    _a.sent();
                                    return [3 /*break*/, 19];
                                case 17:
                                    if (!(newColumn.isUnique === false)) return [3 /*break*/, 19];
                                    return [4 /*yield*/, this.query("ALTER TABLE \"" + tableSchema.name + "\" DROP CONSTRAINT \"uk_" + newColumn.name + "\"")];
                                case 18:
                                    _a.sent();
                                    _a.label = 19;
                                case 19: return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Changes a column in the table.
                 */
                PostgresQueryRunner.prototype.changeColumns = function (tableSchema, changedColumns) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var updatePromises;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_3.QueryRunnerAlreadyReleasedError();
                                    updatePromises = changedColumns.map(function (changedColumn) { return __awaiter(_this, void 0, void 0, function () {
                                        return __generator(this, function (_a) {
                                            return [2 /*return*/, this.changeColumn(tableSchema, changedColumn.oldColumn, changedColumn.newColumn)];
                                        });
                                    }); });
                                    return [4 /*yield*/, Promise.all(updatePromises)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Drops column in the table.
                 */
                PostgresQueryRunner.prototype.dropColumn = function (tableSchemaOrName, columnSchemaOrName) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableName, columnName;
                        return __generator(this, function (_a) {
                            tableName = tableSchemaOrName instanceof TableSchema_5.TableSchema ? tableSchemaOrName.name : tableSchemaOrName;
                            columnName = columnSchemaOrName instanceof ColumnSchema_6.ColumnSchema ? columnSchemaOrName.name : columnSchemaOrName;
                            return [2 /*return*/, this.query("ALTER TABLE \"" + tableName + "\" DROP \"" + columnName + "\"")];
                        });
                    });
                };
                /**
                 * Drops the columns in the table.
                 */
                PostgresQueryRunner.prototype.dropColumns = function (tableSchemaOrName, columnSchemasOrNames) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var dropPromises;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_3.QueryRunnerAlreadyReleasedError();
                                    dropPromises = columnSchemasOrNames.map(function (column) { return _this.dropColumn(tableSchemaOrName, column); });
                                    return [4 /*yield*/, Promise.all(dropPromises)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Updates table's primary keys.
                 */
                PostgresQueryRunner.prototype.updatePrimaryKeys = function (dbTable) {
                    return __awaiter(this, void 0, void 0, function () {
                        var primaryColumnNames;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_3.QueryRunnerAlreadyReleasedError();
                                    primaryColumnNames = dbTable.primaryKeys.map(function (primaryKey) { return "\"" + primaryKey.columnName + "\""; });
                                    return [4 /*yield*/, this.query("ALTER TABLE \"" + dbTable.name + "\" DROP CONSTRAINT IF EXISTS \"" + dbTable.name + "_pkey\"")];
                                case 1:
                                    _a.sent();
                                    return [4 /*yield*/, this.query("DROP INDEX IF EXISTS \"" + dbTable.name + "_pkey\"")];
                                case 2:
                                    _a.sent();
                                    if (!(primaryColumnNames.length > 0)) return [3 /*break*/, 4];
                                    return [4 /*yield*/, this.query("ALTER TABLE \"" + dbTable.name + "\" ADD PRIMARY KEY (" + primaryColumnNames.join(", ") + ")")];
                                case 3:
                                    _a.sent();
                                    _a.label = 4;
                                case 4: return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Creates a new foreign key.
                 */
                PostgresQueryRunner.prototype.createForeignKey = function (tableSchemaOrName, foreignKey) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableName, sql;
                        return __generator(this, function (_a) {
                            if (this.isReleased)
                                throw new QueryRunnerAlreadyReleasedError_3.QueryRunnerAlreadyReleasedError();
                            tableName = tableSchemaOrName instanceof TableSchema_5.TableSchema ? tableSchemaOrName.name : tableSchemaOrName;
                            sql = "ALTER TABLE \"" + tableName + "\" ADD CONSTRAINT \"" + foreignKey.name + "\" " +
                                ("FOREIGN KEY (\"" + foreignKey.columnNames.join("\", \"") + "\") ") +
                                ("REFERENCES \"" + foreignKey.referencedTableName + "\"(\"" + foreignKey.referencedColumnNames.join("\", \"") + "\")");
                            if (foreignKey.onDelete)
                                sql += " ON DELETE " + foreignKey.onDelete;
                            return [2 /*return*/, this.query(sql)];
                        });
                    });
                };
                /**
                 * Creates a new foreign keys.
                 */
                PostgresQueryRunner.prototype.createForeignKeys = function (tableSchemaOrName, foreignKeys) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var promises;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_3.QueryRunnerAlreadyReleasedError();
                                    promises = foreignKeys.map(function (foreignKey) { return _this.createForeignKey(tableSchemaOrName, foreignKey); });
                                    return [4 /*yield*/, Promise.all(promises)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Drops a foreign key from the table.
                 */
                PostgresQueryRunner.prototype.dropForeignKey = function (tableSchemaOrName, foreignKey) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableName, sql;
                        return __generator(this, function (_a) {
                            if (this.isReleased)
                                throw new QueryRunnerAlreadyReleasedError_3.QueryRunnerAlreadyReleasedError();
                            tableName = tableSchemaOrName instanceof TableSchema_5.TableSchema ? tableSchemaOrName.name : tableSchemaOrName;
                            sql = "ALTER TABLE \"" + tableName + "\" DROP CONSTRAINT \"" + foreignKey.name + "\"";
                            return [2 /*return*/, this.query(sql)];
                        });
                    });
                };
                /**
                 * Drops a foreign keys from the table.
                 */
                PostgresQueryRunner.prototype.dropForeignKeys = function (tableSchemaOrName, foreignKeys) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var promises;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_3.QueryRunnerAlreadyReleasedError();
                                    promises = foreignKeys.map(function (foreignKey) { return _this.dropForeignKey(tableSchemaOrName, foreignKey); });
                                    return [4 /*yield*/, Promise.all(promises)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Creates a new index.
                 */
                PostgresQueryRunner.prototype.createIndex = function (tableName, index) {
                    return __awaiter(this, void 0, void 0, function () {
                        var columnNames, sql;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_3.QueryRunnerAlreadyReleasedError();
                                    columnNames = index.columnNames.map(function (columnName) { return "\"" + columnName + "\""; }).join(",");
                                    sql = "CREATE " + (index.isUnique ? "UNIQUE " : "") + "INDEX \"" + index.name + "\" ON \"" + tableName + "\"(" + columnNames + ")";
                                    return [4 /*yield*/, this.query(sql)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Drops an index from the table.
                 */
                PostgresQueryRunner.prototype.dropIndex = function (tableName, indexName, isGenerated) {
                    if (isGenerated === void 0) { isGenerated = false; }
                    return __awaiter(this, void 0, void 0, function () {
                        var sql;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_3.QueryRunnerAlreadyReleasedError();
                                    if (!isGenerated) return [3 /*break*/, 2];
                                    return [4 /*yield*/, this.query("ALTER SEQUENCE \"" + tableName + "_id_seq\" OWNED BY NONE")];
                                case 1:
                                    _a.sent();
                                    _a.label = 2;
                                case 2:
                                    sql = "DROP INDEX \"" + indexName + "\"";
                                    return [4 /*yield*/, this.query(sql)];
                                case 3:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Creates a database type from a given column metadata.
                 */
                PostgresQueryRunner.prototype.normalizeType = function (typeOptions) {
                    switch (typeOptions.type) {
                        case "string":
                            return "character varying(" + (typeOptions.length ? typeOptions.length : 255) + ")";
                        case "text":
                            return "text";
                        case "boolean":
                            return "boolean";
                        case "integer":
                        case "int":
                            return "integer";
                        case "smallint":
                            return "smallint";
                        case "bigint":
                            return "bigint";
                        case "float":
                            return "real";
                        case "double":
                        case "number":
                            return "double precision";
                        case "decimal":
                            if (typeOptions.precision && typeOptions.scale) {
                                return "decimal(" + typeOptions.precision + "," + typeOptions.scale + ")";
                            }
                            else if (typeOptions.scale) {
                                return "decimal(" + typeOptions.scale + ")";
                            }
                            else if (typeOptions.precision) {
                                return "decimal(" + typeOptions.precision + ")";
                            }
                            else {
                                return "decimal";
                            }
                        case "date":
                            return "date";
                        case "time":
                            if (typeOptions.timezone) {
                                return "time with time zone";
                            }
                            else {
                                return "time without time zone";
                            }
                        case "datetime":
                            if (typeOptions.timezone) {
                                return "timestamp with time zone";
                            }
                            else {
                                return "timestamp without time zone";
                            }
                        case "json":
                            return "json";
                        case "jsonb":
                            return "jsonb";
                        case "simple_array":
                            return typeOptions.length ? "character varying(" + typeOptions.length + ")" : "text";
                        case "uuid":
                            return "uuid";
                    }
                    throw new DataTypeNotSupportedByDriverError_3.DataTypeNotSupportedByDriverError(typeOptions.type, "Postgres");
                };
                /**
                 * Checks if "DEFAULT" values in the column metadata and in the database schema are equal.
                 */
                PostgresQueryRunner.prototype.compareDefaultValues = function (columnMetadataValue, databaseValue) {
                    if (typeof columnMetadataValue === "number")
                        return columnMetadataValue === parseInt(databaseValue);
                    if (typeof columnMetadataValue === "boolean")
                        return columnMetadataValue === (!!databaseValue || databaseValue === "false");
                    if (typeof columnMetadataValue === "function")
                        return columnMetadataValue() === databaseValue;
                    return columnMetadataValue === databaseValue;
                };
                /**
                 * Truncates table.
                 */
                PostgresQueryRunner.prototype.truncate = function (tableName) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.query("TRUNCATE TABLE " + this.driver.escapeTableName(tableName))];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                Object.defineProperty(PostgresQueryRunner.prototype, "dbName", {
                    // -------------------------------------------------------------------------
                    // Protected Methods
                    // -------------------------------------------------------------------------
                    /**
                     * Database name shortcut.
                     */
                    get: function () {
                        return this.driver.options.database;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Parametrizes given object of values. Used to create column=value queries.
                 */
                PostgresQueryRunner.prototype.parametrize = function (objectLiteral, startIndex) {
                    var _this = this;
                    if (startIndex === void 0) { startIndex = 0; }
                    return Object.keys(objectLiteral).map(function (key, index) { return _this.driver.escapeColumnName(key) + "=$" + (startIndex + index + 1); });
                };
                /**
                 * Builds a query for create column.
                 */
                PostgresQueryRunner.prototype.buildCreateColumnSql = function (column, skipPrimary) {
                    var c = "\"" + column.name + "\"";
                    if (column.isGenerated === true && column.type !== "uuid")
                        c += " SERIAL";
                    if (!column.isGenerated || column.type === "uuid")
                        c += " " + column.type;
                    if (column.isNullable !== true)
                        c += " NOT NULL";
                    if (column.isGenerated)
                        c += " PRIMARY KEY";
                    if (column.default !== undefined && column.default !== null) {
                        if (typeof column.default === "number") {
                            c += " DEFAULT " + column.default + "";
                        }
                        else if (typeof column.default === "boolean") {
                            c += " DEFAULT " + (column.default === true ? "TRUE" : "FALSE") + "";
                        }
                        else if (typeof column.default === "function") {
                            c += " DEFAULT " + column.default() + "";
                        }
                        else if (typeof column.default === "string") {
                            c += " DEFAULT '" + column.default + "'";
                        }
                        else {
                            c += " DEFAULT " + column.default + "";
                        }
                    }
                    if (column.isGenerated && column.type === "uuid" && !column.default)
                        c += " DEFAULT uuid_generate_v4()";
                    return c;
                };
                return PostgresQueryRunner;
            }());
            exports_141("PostgresQueryRunner", PostgresQueryRunner);
        }
    };
});
System.register("typeorm/driver/postgres/PostgresDriver", ["typeorm/driver/error/ConnectionIsNotSetError", "typeorm/driver/error/DriverPackageNotInstalledError", "typeorm/driver/DriverUtils", "typeorm/metadata/types/ColumnTypes", "typeorm/driver/postgres/PostgresQueryRunner", "typeorm/driver/error/DriverOptionNotSetError", "typeorm/util/DataTransformationUtils", "typeorm/platform/PlatformTools"], function (exports_142, context_142) {
    "use strict";
    var __moduleName = context_142 && context_142.id;
    var ConnectionIsNotSetError_3, DriverPackageNotInstalledError_3, DriverUtils_3, ColumnTypes_6, PostgresQueryRunner_1, DriverOptionNotSetError_3, DataTransformationUtils_4, PlatformTools_6, PostgresDriver;
    return {
        setters: [
            function (ConnectionIsNotSetError_3_1) {
                ConnectionIsNotSetError_3 = ConnectionIsNotSetError_3_1;
            },
            function (DriverPackageNotInstalledError_3_1) {
                DriverPackageNotInstalledError_3 = DriverPackageNotInstalledError_3_1;
            },
            function (DriverUtils_3_1) {
                DriverUtils_3 = DriverUtils_3_1;
            },
            function (ColumnTypes_6_1) {
                ColumnTypes_6 = ColumnTypes_6_1;
            },
            function (PostgresQueryRunner_1_1) {
                PostgresQueryRunner_1 = PostgresQueryRunner_1_1;
            },
            function (DriverOptionNotSetError_3_1) {
                DriverOptionNotSetError_3 = DriverOptionNotSetError_3_1;
            },
            function (DataTransformationUtils_4_1) {
                DataTransformationUtils_4 = DataTransformationUtils_4_1;
            },
            function (PlatformTools_6_1) {
                PlatformTools_6 = PlatformTools_6_1;
            }
        ],
        execute: function () {
            // todo(tests):
            // check connection with url
            // check if any of required option is not set exception to be thrown
            //
            /**
             * Organizes communication with PostgreSQL DBMS.
             */
            PostgresDriver = (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function PostgresDriver(connectionOptions, logger, postgres) {
                    /**
                     * Pool of database connections.
                     */
                    this.databaseConnectionPool = [];
                    this.options = DriverUtils_3.DriverUtils.buildDriverOptions(connectionOptions);
                    this.logger = logger;
                    this.postgres = postgres;
                    this.schemaName = connectionOptions.schemaName || "public";
                    // validate options to make sure everything is set
                    if (!this.options.host)
                        throw new DriverOptionNotSetError_3.DriverOptionNotSetError("host");
                    if (!this.options.username)
                        throw new DriverOptionNotSetError_3.DriverOptionNotSetError("username");
                    if (!this.options.database)
                        throw new DriverOptionNotSetError_3.DriverOptionNotSetError("database");
                    // if postgres package instance was not set explicitly then try to load it
                    if (!postgres)
                        this.loadDependencies();
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Performs connection to the database.
                 * Based on pooling options, it can either create connection immediately,
                 * either create a pool and create connection when needed.
                 */
                PostgresDriver.prototype.connect = function () {
                    var _this = this;
                    // build connection options for the driver
                    var options = Object.assign({}, {
                        host: this.options.host,
                        user: this.options.username,
                        password: this.options.password,
                        database: this.options.database,
                        port: this.options.port
                    }, this.options.extra || {});
                    // pooling is enabled either when its set explicitly to true,
                    // either when its not defined at all (e.g. enabled by default)
                    if (this.options.usePool === undefined || this.options.usePool === true) {
                        this.pool = new this.postgres.Pool(options);
                        return Promise.resolve();
                    }
                    else {
                        return new Promise(function (ok, fail) {
                            _this.databaseConnection = {
                                id: 1,
                                connection: new _this.postgres.Client(options),
                                isTransactionActive: false
                            };
                            _this.databaseConnection.connection.connect(function (err) {
                                if (err) {
                                    fail(err);
                                }
                                else {
                                    _this.databaseConnection && _this.databaseConnection.connection.query("SET search_path TO '" + _this.schemaName + "', 'public';", function (err, result) {
                                        if (err) {
                                            _this.logger.logFailedQuery("SET search_path TO '" + _this.schemaName + "', 'public';");
                                            _this.logger.logQueryError(err);
                                            fail(err);
                                        }
                                        else {
                                            ok();
                                        }
                                    });
                                }
                            });
                        });
                    }
                };
                /**
                 * Closes connection with database.
                 */
                PostgresDriver.prototype.disconnect = function () {
                    var _this = this;
                    if (!this.databaseConnection && !this.pool)
                        throw new ConnectionIsNotSetError_3.ConnectionIsNotSetError("postgres");
                    return new Promise(function (ok, fail) {
                        var handler = function (err) { return err ? fail(err) : ok(); };
                        if (_this.databaseConnection) {
                            _this.databaseConnection.connection.end(); // todo: check if it can emit errors
                            _this.databaseConnection = undefined;
                        }
                        if (_this.pool) {
                            _this.databaseConnectionPool.forEach(function (dbConnection) {
                                if (dbConnection && dbConnection.releaseCallback) {
                                    dbConnection.releaseCallback();
                                }
                            });
                            _this.pool.end(handler);
                            _this.pool = undefined;
                            _this.databaseConnectionPool = [];
                        }
                        ok();
                    });
                };
                /**
                 * Creates a query runner used for common queries.
                 */
                PostgresDriver.prototype.createQueryRunner = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var databaseConnection;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!this.databaseConnection && !this.pool)
                                        return [2 /*return*/, Promise.reject(new ConnectionIsNotSetError_3.ConnectionIsNotSetError("postgres"))];
                                    return [4 /*yield*/, this.retrieveDatabaseConnection()];
                                case 1:
                                    databaseConnection = _a.sent();
                                    return [2 /*return*/, new PostgresQueryRunner_1.PostgresQueryRunner(databaseConnection, this, this.logger)];
                            }
                        });
                    });
                };
                /**
                 * Access to the native implementation of the database.
                 */
                PostgresDriver.prototype.nativeInterface = function () {
                    return {
                        driver: this.postgres,
                        connection: this.databaseConnection ? this.databaseConnection.connection : undefined,
                        pool: this.pool
                    };
                };
                /**
                 * Prepares given value to a value to be persisted, based on its column type and metadata.
                 */
                PostgresDriver.prototype.preparePersistentValue = function (value, column) {
                    if (value === null || value === undefined)
                        return null;
                    switch (column.type) {
                        case ColumnTypes_6.ColumnTypes.BOOLEAN:
                            return value === true ? 1 : 0;
                        case ColumnTypes_6.ColumnTypes.DATE:
                            return DataTransformationUtils_4.DataTransformationUtils.mixedDateToDateString(value);
                        case ColumnTypes_6.ColumnTypes.TIME:
                            return DataTransformationUtils_4.DataTransformationUtils.mixedDateToTimeString(value);
                        case ColumnTypes_6.ColumnTypes.DATETIME:
                            if (column.localTimezone) {
                                return DataTransformationUtils_4.DataTransformationUtils.mixedDateToDatetimeString(value);
                            }
                            else {
                                return DataTransformationUtils_4.DataTransformationUtils.mixedDateToUtcDatetimeString(value);
                            }
                        case ColumnTypes_6.ColumnTypes.JSON:
                        case ColumnTypes_6.ColumnTypes.JSONB:
                            return JSON.stringify(value);
                        case ColumnTypes_6.ColumnTypes.SIMPLE_ARRAY:
                            return DataTransformationUtils_4.DataTransformationUtils.simpleArrayToString(value);
                    }
                    return value;
                };
                /**
                 * Prepares given value to a value to be persisted, based on its column type or metadata.
                 */
                PostgresDriver.prototype.prepareHydratedValue = function (value, columnMetadata) {
                    switch (columnMetadata.type) {
                        case ColumnTypes_6.ColumnTypes.BOOLEAN:
                            return value ? true : false;
                        case ColumnTypes_6.ColumnTypes.DATETIME:
                            return DataTransformationUtils_4.DataTransformationUtils.normalizeHydratedDate(value, columnMetadata.localTimezone === true);
                        case ColumnTypes_6.ColumnTypes.TIME:
                            return DataTransformationUtils_4.DataTransformationUtils.mixedTimeToString(value);
                        case ColumnTypes_6.ColumnTypes.JSON:
                        case ColumnTypes_6.ColumnTypes.JSONB:
                            // pg(pg-types) have done JSON.parse conversion
                            // https://github.com/brianc/node-pg-types/blob/ed2d0e36e33217b34530727a98d20b325389e73a/lib/textParsers.js#L170
                            return value;
                        case ColumnTypes_6.ColumnTypes.SIMPLE_ARRAY:
                            return DataTransformationUtils_4.DataTransformationUtils.stringToSimpleArray(value);
                    }
                    return value;
                };
                /**
                 * Replaces parameters in the given sql with special escaping character
                 * and an array of parameter names to be passed to a query.
                 */
                PostgresDriver.prototype.escapeQueryWithParameters = function (sql, parameters) {
                    if (!parameters || !Object.keys(parameters).length)
                        return [sql, []];
                    var builtParameters = [];
                    var keys = Object.keys(parameters).map(function (parameter) { return "(:" + parameter + "\\b)"; }).join("|");
                    sql = sql.replace(new RegExp(keys, "g"), function (key) {
                        var value = parameters[key.substr(1)];
                        if (value instanceof Array) {
                            return value.map(function (v) {
                                builtParameters.push(v);
                                return "$" + builtParameters.length;
                            }).join(", ");
                        }
                        else {
                            builtParameters.push(value);
                        }
                        return "$" + builtParameters.length;
                    }); // todo: make replace only in value statements, otherwise problems
                    return [sql, builtParameters];
                };
                /**
                 * Escapes a column name.
                 */
                PostgresDriver.prototype.escapeColumnName = function (columnName) {
                    return "\"" + columnName + "\"";
                };
                /**
                 * Escapes an alias.
                 */
                PostgresDriver.prototype.escapeAliasName = function (aliasName) {
                    return "\"" + aliasName + "\"";
                };
                /**
                 * Escapes a table name.
                 */
                PostgresDriver.prototype.escapeTableName = function (tableName) {
                    return "\"" + tableName + "\"";
                };
                // -------------------------------------------------------------------------
                // Protected Methods
                // -------------------------------------------------------------------------
                /**
                 * Retrieves a new database connection.
                 * If pooling is enabled then connection from the pool will be retrieved.
                 * Otherwise active connection will be returned.
                 */
                PostgresDriver.prototype.retrieveDatabaseConnection = function () {
                    var _this = this;
                    if (this.pool) {
                        return new Promise(function (ok, fail) {
                            _this.pool.connect(function (err, connection, release) {
                                if (err) {
                                    fail(err);
                                    return;
                                }
                                var dbConnection = _this.databaseConnectionPool.find(function (dbConnection) { return dbConnection.connection === connection; });
                                if (!dbConnection) {
                                    dbConnection = {
                                        id: _this.databaseConnectionPool.length,
                                        connection: connection,
                                        isTransactionActive: false
                                    };
                                    _this.databaseConnectionPool.push(dbConnection);
                                }
                                dbConnection.releaseCallback = function () {
                                    if (dbConnection) {
                                        _this.databaseConnectionPool.splice(_this.databaseConnectionPool.indexOf(dbConnection), 1);
                                    }
                                    release();
                                    return Promise.resolve();
                                };
                                dbConnection.connection.query("SET search_path TO '" + _this.schemaName + "', 'public';", function (err) {
                                    if (err) {
                                        _this.logger.logFailedQuery("SET search_path TO '" + _this.schemaName + "', 'public';");
                                        _this.logger.logQueryError(err);
                                        fail(err);
                                    }
                                    else {
                                        ok(dbConnection);
                                    }
                                });
                            });
                        });
                    }
                    if (this.databaseConnection)
                        return Promise.resolve(this.databaseConnection);
                    throw new ConnectionIsNotSetError_3.ConnectionIsNotSetError("postgres");
                };
                /**
                 * If driver dependency is not given explicitly, then try to load it via "require".
                 */
                PostgresDriver.prototype.loadDependencies = function () {
                    try {
                        this.postgres = PlatformTools_6.PlatformTools.load("pg");
                    }
                    catch (e) {
                        throw new DriverPackageNotInstalledError_3.DriverPackageNotInstalledError("Postgres", "pg");
                    }
                };
                return PostgresDriver;
            }());
            exports_142("PostgresDriver", PostgresDriver);
        }
    };
});
System.register("typeorm/connection/error/AlreadyHasActiveConnectionError", [], function (exports_143, context_143) {
    "use strict";
    var __moduleName = context_143 && context_143.id;
    var AlreadyHasActiveConnectionError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown when consumer tries to recreate connection with the same name, but previous connection was not closed yet.
             */
            AlreadyHasActiveConnectionError = (function (_super) {
                __extends(AlreadyHasActiveConnectionError, _super);
                function AlreadyHasActiveConnectionError(connectionName) {
                    var _this = _super.call(this) || this;
                    _this.name = "AlreadyHasActiveConnectionError";
                    _this.message = "Cannot create a new connection named \"" + connectionName + "\", because connection with such name " +
                        "already exist and it now has an active connection session.";
                    _this.stack = new Error().stack;
                    return _this;
                }
                return AlreadyHasActiveConnectionError;
            }(Error));
            exports_143("AlreadyHasActiveConnectionError", AlreadyHasActiveConnectionError);
        }
    };
});
System.register("typeorm/driver/sqlite/SqliteQueryRunner", ["typeorm/driver/error/TransactionAlreadyStartedError", "typeorm/driver/error/TransactionNotStartedError", "typeorm/driver/error/DataTypeNotSupportedByDriverError", "typeorm/schema-builder/schema/ColumnSchema", "typeorm/metadata/ColumnMetadata", "typeorm/schema-builder/schema/TableSchema", "typeorm/schema-builder/schema/IndexSchema", "typeorm/schema-builder/schema/ForeignKeySchema", "typeorm/schema-builder/schema/PrimaryKeySchema", "typeorm/query-runner/error/QueryRunnerAlreadyReleasedError"], function (exports_144, context_144) {
    "use strict";
    var __moduleName = context_144 && context_144.id;
    var TransactionAlreadyStartedError_4, TransactionNotStartedError_4, DataTypeNotSupportedByDriverError_4, ColumnSchema_7, ColumnMetadata_4, TableSchema_6, IndexSchema_5, ForeignKeySchema_5, PrimaryKeySchema_5, QueryRunnerAlreadyReleasedError_4, SqliteQueryRunner;
    return {
        setters: [
            function (TransactionAlreadyStartedError_4_1) {
                TransactionAlreadyStartedError_4 = TransactionAlreadyStartedError_4_1;
            },
            function (TransactionNotStartedError_4_1) {
                TransactionNotStartedError_4 = TransactionNotStartedError_4_1;
            },
            function (DataTypeNotSupportedByDriverError_4_1) {
                DataTypeNotSupportedByDriverError_4 = DataTypeNotSupportedByDriverError_4_1;
            },
            function (ColumnSchema_7_1) {
                ColumnSchema_7 = ColumnSchema_7_1;
            },
            function (ColumnMetadata_4_1) {
                ColumnMetadata_4 = ColumnMetadata_4_1;
            },
            function (TableSchema_6_1) {
                TableSchema_6 = TableSchema_6_1;
            },
            function (IndexSchema_5_1) {
                IndexSchema_5 = IndexSchema_5_1;
            },
            function (ForeignKeySchema_5_1) {
                ForeignKeySchema_5 = ForeignKeySchema_5_1;
            },
            function (PrimaryKeySchema_5_1) {
                PrimaryKeySchema_5 = PrimaryKeySchema_5_1;
            },
            function (QueryRunnerAlreadyReleasedError_4_1) {
                QueryRunnerAlreadyReleasedError_4 = QueryRunnerAlreadyReleasedError_4_1;
            }
        ],
        execute: function () {
            /**
             * Runs queries on a single sqlite database connection.
             *
             * Does not support compose primary keys with autoincrement field.
             * todo: need to throw exception for this case.
             */
            SqliteQueryRunner = (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function SqliteQueryRunner(databaseConnection, driver, logger) {
                    this.databaseConnection = databaseConnection;
                    this.driver = driver;
                    this.logger = logger;
                    // -------------------------------------------------------------------------
                    // Protected Properties
                    // -------------------------------------------------------------------------
                    /**
                     * Indicates if connection for this query runner is released.
                     * Once its released, query runner cannot run queries anymore.
                     */
                    this.isReleased = false;
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Releases database connection. This is needed when using connection pooling.
                 * If connection is not from a pool, it should not be released.
                 */
                SqliteQueryRunner.prototype.release = function () {
                    if (this.databaseConnection.releaseCallback) {
                        this.isReleased = true;
                        return this.databaseConnection.releaseCallback();
                    }
                    return Promise.resolve();
                };
                /**
                 * Removes all tables from the currently connected database.
                 */
                SqliteQueryRunner.prototype.clearDatabase = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var selectDropsQuery, dropQueries, error_7;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_4.QueryRunnerAlreadyReleasedError();
                                    return [4 /*yield*/, this.query("PRAGMA foreign_keys = OFF;")];
                                case 1:
                                    _a.sent();
                                    return [4 /*yield*/, this.beginTransaction()];
                                case 2:
                                    _a.sent();
                                    _a.label = 3;
                                case 3:
                                    _a.trys.push([3, 7, 9, 12]);
                                    selectDropsQuery = "select 'drop table ' || name || ';' as query from sqlite_master where type = 'table' and name != 'sqlite_sequence'";
                                    return [4 /*yield*/, this.query(selectDropsQuery)];
                                case 4:
                                    dropQueries = _a.sent();
                                    return [4 /*yield*/, Promise.all(dropQueries.map(function (q) { return _this.query(q["query"]); }))];
                                case 5:
                                    _a.sent();
                                    return [4 /*yield*/, this.commitTransaction()];
                                case 6:
                                    _a.sent();
                                    return [3 /*break*/, 12];
                                case 7:
                                    error_7 = _a.sent();
                                    return [4 /*yield*/, this.rollbackTransaction()];
                                case 8:
                                    _a.sent();
                                    throw error_7;
                                case 9: return [4 /*yield*/, this.release()];
                                case 10:
                                    _a.sent();
                                    return [4 /*yield*/, this.query("PRAGMA foreign_keys = ON;")];
                                case 11:
                                    _a.sent();
                                    return [7 /*endfinally*/];
                                case 12: return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Starts transaction.
                 */
                SqliteQueryRunner.prototype.beginTransaction = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_4.QueryRunnerAlreadyReleasedError();
                                    if (this.databaseConnection.isTransactionActive)
                                        throw new TransactionAlreadyStartedError_4.TransactionAlreadyStartedError();
                                    this.databaseConnection.isTransactionActive = true;
                                    return [4 /*yield*/, this.query("BEGIN TRANSACTION")];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Commits transaction.
                 */
                SqliteQueryRunner.prototype.commitTransaction = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_4.QueryRunnerAlreadyReleasedError();
                                    if (!this.databaseConnection.isTransactionActive)
                                        throw new TransactionNotStartedError_4.TransactionNotStartedError();
                                    return [4 /*yield*/, this.query("COMMIT")];
                                case 1:
                                    _a.sent();
                                    this.databaseConnection.isTransactionActive = false;
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Rollbacks transaction.
                 */
                SqliteQueryRunner.prototype.rollbackTransaction = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_4.QueryRunnerAlreadyReleasedError();
                                    if (!this.databaseConnection.isTransactionActive)
                                        throw new TransactionNotStartedError_4.TransactionNotStartedError();
                                    return [4 /*yield*/, this.query("ROLLBACK")];
                                case 1:
                                    _a.sent();
                                    this.databaseConnection.isTransactionActive = false;
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Checks if transaction is in progress.
                 */
                SqliteQueryRunner.prototype.isTransactionActive = function () {
                    return this.databaseConnection.isTransactionActive;
                };
                /**
                 * Executes a given SQL query.
                 */
                SqliteQueryRunner.prototype.query = function (query, parameters) {
                    var _this = this;
                    if (this.isReleased)
                        throw new QueryRunnerAlreadyReleasedError_4.QueryRunnerAlreadyReleasedError();
                    return new Promise(function (ok, fail) {
                        _this.logger.logQuery(query, parameters);
                        _this.databaseConnection.connection.all(query, parameters, function (err, result) {
                            if (err) {
                                _this.logger.logFailedQuery(query, parameters);
                                _this.logger.logQueryError(err);
                                fail(err);
                            }
                            else {
                                ok(result);
                            }
                        });
                    });
                };
                /**
                 * Insert a new row into given table.
                 */
                SqliteQueryRunner.prototype.insert = function (tableName, keyValues, generatedColumn) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var keys, columns, values, sql, parameters;
                        return __generator(this, function (_a) {
                            if (this.isReleased)
                                throw new QueryRunnerAlreadyReleasedError_4.QueryRunnerAlreadyReleasedError();
                            keys = Object.keys(keyValues);
                            columns = keys.map(function (key) { return _this.driver.escapeColumnName(key); }).join(", ");
                            values = keys.map(function (key, index) { return "$" + (index + 1); }).join(",");
                            sql = columns.length > 0 ? ("INSERT INTO " + this.driver.escapeTableName(tableName) + "(" + columns + ") VALUES (" + values + ")") : "INSERT INTO " + this.driver.escapeTableName(tableName) + " DEFAULT VALUES";
                            parameters = keys.map(function (key) { return keyValues[key]; });
                            return [2 /*return*/, new Promise(function (ok, fail) {
                                    _this.logger.logQuery(sql, parameters);
                                    var __this = _this;
                                    _this.databaseConnection.connection.run(sql, parameters, function (err) {
                                        if (err) {
                                            __this.logger.logFailedQuery(sql, parameters);
                                            __this.logger.logQueryError(err);
                                            fail(err);
                                        }
                                        else {
                                            if (generatedColumn)
                                                return ok(this["lastID"]);
                                            ok();
                                        }
                                    });
                                })];
                        });
                    });
                };
                /**
                 * Updates rows that match given conditions in the given table.
                 */
                SqliteQueryRunner.prototype.update = function (tableName, valuesMap, conditions) {
                    return __awaiter(this, void 0, void 0, function () {
                        var updateValues, conditionString, query, updateParams, conditionParams, allParameters;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_4.QueryRunnerAlreadyReleasedError();
                                    updateValues = this.parametrize(valuesMap).join(", ");
                                    conditionString = this.parametrize(conditions, Object.keys(valuesMap).length).join(" AND ");
                                    query = "UPDATE " + this.driver.escapeTableName(tableName) + " SET " + updateValues + " " + (conditionString ? (" WHERE " + conditionString) : "");
                                    updateParams = Object.keys(valuesMap).map(function (key) { return valuesMap[key]; });
                                    conditionParams = Object.keys(conditions).map(function (key) { return conditions[key]; });
                                    allParameters = updateParams.concat(conditionParams);
                                    return [4 /*yield*/, this.query(query, allParameters)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Deletes from the given table by a given conditions.
                 */
                SqliteQueryRunner.prototype.delete = function (tableName, conditions, maybeParameters) {
                    return __awaiter(this, void 0, void 0, function () {
                        var conditionString, parameters, sql;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_4.QueryRunnerAlreadyReleasedError();
                                    conditionString = typeof conditions === "string" ? conditions : this.parametrize(conditions).join(" AND ");
                                    parameters = conditions instanceof Object ? Object.keys(conditions).map(function (key) { return conditions[key]; }) : maybeParameters;
                                    sql = "DELETE FROM " + this.driver.escapeTableName(tableName) + " WHERE " + conditionString;
                                    return [4 /*yield*/, this.query(sql, parameters)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Inserts rows into closure table.
                 */
                SqliteQueryRunner.prototype.insertIntoClosureTable = function (tableName, newEntityId, parentId, hasLevel) {
                    return __awaiter(this, void 0, void 0, function () {
                        var sql, results;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_4.QueryRunnerAlreadyReleasedError();
                                    sql = "";
                                    if (hasLevel) {
                                        sql = "INSERT INTO " + this.driver.escapeTableName(tableName) + "(ancestor, descendant, level) " +
                                            ("SELECT ancestor, " + newEntityId + ", level + 1 FROM " + this.driver.escapeTableName(tableName) + " WHERE descendant = " + parentId + " ") +
                                            ("UNION ALL SELECT " + newEntityId + ", " + newEntityId + ", 1");
                                    }
                                    else {
                                        sql = "INSERT INTO " + this.driver.escapeTableName(tableName) + "(ancestor, descendant) " +
                                            ("SELECT ancestor, " + newEntityId + " FROM " + this.driver.escapeTableName(tableName) + " WHERE descendant = " + parentId + " ") +
                                            ("UNION ALL SELECT " + newEntityId + ", " + newEntityId);
                                    }
                                    return [4 /*yield*/, this.query(sql)];
                                case 1:
                                    _a.sent();
                                    return [4 /*yield*/, this.query("SELECT MAX(level) as level FROM " + tableName + " WHERE descendant = " + parentId)];
                                case 2:
                                    results = _a.sent();
                                    return [2 /*return*/, results && results[0] && results[0]["level"] ? parseInt(results[0]["level"]) + 1 : 1];
                            }
                        });
                    });
                };
                /**
                 * Loads given table's data from the database.
                 */
                SqliteQueryRunner.prototype.loadTableSchema = function (tableName) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableSchemas;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.loadTableSchemas([tableName])];
                                case 1:
                                    tableSchemas = _a.sent();
                                    return [2 /*return*/, tableSchemas.length > 0 ? tableSchemas[0] : undefined];
                            }
                        });
                    });
                };
                /**
                 * Loads all tables (with given names) from the database and creates a TableSchema from them.
                 */
                SqliteQueryRunner.prototype.loadTableSchemas = function (tableNames) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var tableNamesString, dbTables;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_4.QueryRunnerAlreadyReleasedError();
                                    // if no tables given then no need to proceed
                                    if (!tableNames || !tableNames.length)
                                        return [2 /*return*/, []];
                                    tableNamesString = tableNames.map(function (tableName) { return "'" + tableName + "'"; }).join(", ");
                                    return [4 /*yield*/, this.query("SELECT * FROM sqlite_master WHERE type = 'table' AND name IN (" + tableNamesString + ")")];
                                case 1:
                                    dbTables = _a.sent();
                                    // if tables were not found in the db, no need to proceed
                                    if (!dbTables || !dbTables.length)
                                        return [2 /*return*/, []];
                                    // create table schemas for loaded tables
                                    return [2 /*return*/, Promise.all(dbTables.map(function (dbTable) { return __awaiter(_this, void 0, void 0, function () {
                                            var _this = this;
                                            var tableSchema, _a, dbColumns, dbIndices, dbForeignKeys, autoIncrementColumnName, tableSql, comma, bracket, indicesPromises, indices;
                                            return __generator(this, function (_b) {
                                                switch (_b.label) {
                                                    case 0:
                                                        tableSchema = new TableSchema_6.TableSchema(dbTable["name"]);
                                                        return [4 /*yield*/, Promise.all([
                                                                this.query("PRAGMA table_info(\"" + dbTable["name"] + "\")"),
                                                                this.query("PRAGMA index_list(\"" + dbTable["name"] + "\")"),
                                                                this.query("PRAGMA foreign_key_list(\"" + dbTable["name"] + "\")"),
                                                            ])];
                                                    case 1:
                                                        _a = _b.sent(), dbColumns = _a[0], dbIndices = _a[1], dbForeignKeys = _a[2];
                                                        autoIncrementColumnName = undefined;
                                                        tableSql = dbTable["sql"];
                                                        if (tableSql.indexOf("AUTOINCREMENT") !== -1) {
                                                            autoIncrementColumnName = tableSql.substr(0, tableSql.indexOf("AUTOINCREMENT"));
                                                            comma = autoIncrementColumnName.lastIndexOf(",");
                                                            bracket = autoIncrementColumnName.lastIndexOf("(");
                                                            if (comma !== -1) {
                                                                autoIncrementColumnName = autoIncrementColumnName.substr(comma);
                                                                autoIncrementColumnName = autoIncrementColumnName.substr(0, autoIncrementColumnName.lastIndexOf("\""));
                                                                autoIncrementColumnName = autoIncrementColumnName.substr(autoIncrementColumnName.indexOf("\"") + 1);
                                                            }
                                                            else if (bracket !== -1) {
                                                                autoIncrementColumnName = autoIncrementColumnName.substr(bracket);
                                                                autoIncrementColumnName = autoIncrementColumnName.substr(0, autoIncrementColumnName.lastIndexOf("\""));
                                                                autoIncrementColumnName = autoIncrementColumnName.substr(autoIncrementColumnName.indexOf("\"") + 1);
                                                            }
                                                        }
                                                        // create column schemas from the loaded columns
                                                        tableSchema.columns = dbColumns.map(function (dbColumn) {
                                                            var columnSchema = new ColumnSchema_7.ColumnSchema();
                                                            columnSchema.name = dbColumn["name"];
                                                            columnSchema.type = dbColumn["type"].toLowerCase();
                                                            columnSchema.default = dbColumn["dflt_value"] !== null && dbColumn["dflt_value"] !== undefined ? dbColumn["dflt_value"] : undefined;
                                                            columnSchema.isNullable = dbColumn["notnull"] === 0;
                                                            columnSchema.isPrimary = dbColumn["pk"] === 1;
                                                            columnSchema.comment = ""; // todo later
                                                            columnSchema.isGenerated = autoIncrementColumnName === dbColumn["name"];
                                                            var columnForeignKeys = dbForeignKeys
                                                                .filter(function (foreignKey) { return foreignKey["from"] === dbColumn["name"]; })
                                                                .map(function (foreignKey) {
                                                                var keyName = _this.driver.namingStrategy.foreignKeyName(dbTable["name"], [foreignKey["from"]], foreignKey["table"], [foreignKey["to"]]);
                                                                return new ForeignKeySchema_5.ForeignKeySchema(keyName, [foreignKey["from"]], [foreignKey["to"]], foreignKey["table"], foreignKey["on_delete"]); // todo: how sqlite return from and to when they are arrays? (multiple column foreign keys)
                                                            });
                                                            tableSchema.addForeignKeys(columnForeignKeys);
                                                            return columnSchema;
                                                        });
                                                        // create primary key schema
                                                        return [4 /*yield*/, Promise.all(dbIndices
                                                                .filter(function (index) { return index["origin"] === "pk"; })
                                                                .map(function (index) { return __awaiter(_this, void 0, void 0, function () {
                                                                var indexInfos, indexColumns;
                                                                return __generator(this, function (_a) {
                                                                    switch (_a.label) {
                                                                        case 0: return [4 /*yield*/, this.query("PRAGMA index_info(\"" + index["name"] + "\")")];
                                                                        case 1:
                                                                            indexInfos = _a.sent();
                                                                            indexColumns = indexInfos.map(function (indexInfo) { return indexInfo["name"]; });
                                                                            indexColumns.forEach(function (indexColumn) {
                                                                                tableSchema.primaryKeys.push(new PrimaryKeySchema_5.PrimaryKeySchema(index["name"], indexColumn));
                                                                            });
                                                                            return [2 /*return*/];
                                                                    }
                                                                });
                                                            }); }))];
                                                    case 2:
                                                        // create primary key schema
                                                        _b.sent();
                                                        indicesPromises = dbIndices
                                                            .filter(function (dbIndex) {
                                                            return dbIndex["origin"] !== "pk" &&
                                                                (!tableSchema.foreignKeys.find(function (foreignKey) { return foreignKey.name === dbIndex["name"]; })) &&
                                                                (!tableSchema.primaryKeys.find(function (primaryKey) { return primaryKey.name === dbIndex["name"]; }));
                                                        })
                                                            .map(function (dbIndex) { return dbIndex["name"]; })
                                                            .filter(function (value, index, self) { return self.indexOf(value) === index; }) // unqiue
                                                            .map(function (dbIndexName) { return __awaiter(_this, void 0, void 0, function () {
                                                            var dbIndex, indexInfos, indexColumns;
                                                            return __generator(this, function (_a) {
                                                                switch (_a.label) {
                                                                    case 0:
                                                                        dbIndex = dbIndices.find(function (dbIndex) { return dbIndex["name"] === dbIndexName; });
                                                                        return [4 /*yield*/, this.query("PRAGMA index_info(\"" + dbIndex["name"] + "\")")];
                                                                    case 1:
                                                                        indexInfos = _a.sent();
                                                                        indexColumns = indexInfos.map(function (indexInfo) { return indexInfo["name"]; });
                                                                        // check if db index is generated by sqlite itself and has special use case
                                                                        if (dbIndex["name"].substr(0, "sqlite_autoindex".length) === "sqlite_autoindex") {
                                                                            if (dbIndex["unique"] === 1) {
                                                                                // so we find and update the column
                                                                                indexColumns.forEach(function (columnName) {
                                                                                    var column = tableSchema.columns.find(function (column) { return column.name === columnName; });
                                                                                    if (column)
                                                                                        column.isUnique = true;
                                                                                });
                                                                            }
                                                                            return [2 /*return*/, Promise.resolve(undefined)];
                                                                        }
                                                                        else {
                                                                            return [2 /*return*/, new IndexSchema_5.IndexSchema(dbTable["name"], dbIndex["name"], indexColumns, dbIndex["unique"] === "1")];
                                                                        }
                                                                        return [2 /*return*/];
                                                                }
                                                            });
                                                        }); });
                                                        return [4 /*yield*/, Promise.all(indicesPromises)];
                                                    case 3:
                                                        indices = _b.sent();
                                                        tableSchema.indices = indices.filter(function (index) { return !!index; });
                                                        return [2 /*return*/, tableSchema];
                                                }
                                            });
                                        }); }))];
                            }
                        });
                    });
                };
                /**
                 * Checks if table with the given name exist in the database.
                 */
                SqliteQueryRunner.prototype.hasTable = function (tableName) {
                    return __awaiter(this, void 0, void 0, function () {
                        var sql, result;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    sql = "SELECT * FROM sqlite_master WHERE type = 'table' AND name = '" + tableName + "'";
                                    return [4 /*yield*/, this.query(sql)];
                                case 1:
                                    result = _a.sent();
                                    return [2 /*return*/, result.length ? true : false];
                            }
                        });
                    });
                };
                /**
                 * Creates a new table from the given table metadata and column metadatas.
                 */
                SqliteQueryRunner.prototype.createTable = function (table) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var columnDefinitions, sql, primaryKeyColumns;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_4.QueryRunnerAlreadyReleasedError();
                                    columnDefinitions = table.columns.map(function (column) { return _this.buildCreateColumnSql(column); }).join(", ");
                                    sql = "CREATE TABLE \"" + table.name + "\" (" + columnDefinitions;
                                    primaryKeyColumns = table.columns.filter(function (column) { return column.isPrimary && !column.isGenerated; });
                                    if (primaryKeyColumns.length > 0)
                                        sql += ", PRIMARY KEY(" + primaryKeyColumns.map(function (column) { return "" + column.name; }).join(", ") + ")"; // for some reason column escaping here generates a wrong schema
                                    sql += ")";
                                    return [4 /*yield*/, this.query(sql)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Checks if column with the given name exist in the given table.
                 */
                SqliteQueryRunner.prototype.hasColumn = function (tableName, columnName) {
                    return __awaiter(this, void 0, void 0, function () {
                        var sql, columns;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    sql = "PRAGMA table_info(\"" + tableName + "\")";
                                    return [4 /*yield*/, this.query(sql)];
                                case 1:
                                    columns = _a.sent();
                                    return [2 /*return*/, !!columns.find(function (column) { return column["name"] === columnName; })];
                            }
                        });
                    });
                };
                /**
                 * Creates a new column from the column schema in the table.
                 */
                SqliteQueryRunner.prototype.addColumn = function (tableSchemaOrName, column) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableSchema, newTableSchema;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_4.QueryRunnerAlreadyReleasedError();
                                    return [4 /*yield*/, this.getTableSchema(tableSchemaOrName)];
                                case 1:
                                    tableSchema = _a.sent();
                                    newTableSchema = tableSchema.clone();
                                    newTableSchema.addColumns([column]);
                                    return [4 /*yield*/, this.recreateTable(newTableSchema, tableSchema)];
                                case 2:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Creates a new columns from the column schema in the table.
                 */
                SqliteQueryRunner.prototype.addColumns = function (tableSchemaOrName, columns) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableSchema, newTableSchema;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_4.QueryRunnerAlreadyReleasedError();
                                    return [4 /*yield*/, this.getTableSchema(tableSchemaOrName)];
                                case 1:
                                    tableSchema = _a.sent();
                                    newTableSchema = tableSchema.clone();
                                    newTableSchema.addColumns(columns);
                                    return [4 /*yield*/, this.recreateTable(newTableSchema, tableSchema)];
                                case 2:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Renames column in the given table.
                 */
                SqliteQueryRunner.prototype.renameColumn = function (tableSchemaOrName, oldColumnSchemaOrName, newColumnSchemaOrName) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableSchema, oldColumn, newColumn;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    tableSchema = undefined;
                                    if (!(tableSchemaOrName instanceof TableSchema_6.TableSchema)) return [3 /*break*/, 1];
                                    tableSchema = tableSchemaOrName;
                                    return [3 /*break*/, 3];
                                case 1: return [4 /*yield*/, this.loadTableSchema(tableSchemaOrName)];
                                case 2:
                                    tableSchema = _a.sent();
                                    _a.label = 3;
                                case 3:
                                    if (!tableSchema)
                                        throw new Error("Table " + tableSchemaOrName + " was not found.");
                                    oldColumn = undefined;
                                    if (oldColumnSchemaOrName instanceof ColumnSchema_7.ColumnSchema) {
                                        oldColumn = oldColumnSchemaOrName;
                                    }
                                    else {
                                        oldColumn = tableSchema.columns.find(function (column) { return column.name === oldColumnSchemaOrName; });
                                    }
                                    if (!oldColumn)
                                        throw new Error("Column \"" + oldColumnSchemaOrName + "\" was not found in the \"" + tableSchemaOrName + "\" table.");
                                    newColumn = undefined;
                                    if (newColumnSchemaOrName instanceof ColumnSchema_7.ColumnSchema) {
                                        newColumn = newColumnSchemaOrName;
                                    }
                                    else {
                                        newColumn = oldColumn.clone();
                                        newColumn.name = newColumnSchemaOrName;
                                    }
                                    return [2 /*return*/, this.changeColumn(tableSchema, oldColumn, newColumn)];
                            }
                        });
                    });
                };
                /**
                 * Changes a column in the table.
                 */
                SqliteQueryRunner.prototype.changeColumn = function (tableSchemaOrName, oldColumnSchemaOrName, newColumn) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableSchema, oldColumn;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_4.QueryRunnerAlreadyReleasedError();
                                    tableSchema = undefined;
                                    if (!(tableSchemaOrName instanceof TableSchema_6.TableSchema)) return [3 /*break*/, 1];
                                    tableSchema = tableSchemaOrName;
                                    return [3 /*break*/, 3];
                                case 1: return [4 /*yield*/, this.loadTableSchema(tableSchemaOrName)];
                                case 2:
                                    tableSchema = _a.sent();
                                    _a.label = 3;
                                case 3:
                                    if (!tableSchema)
                                        throw new Error("Table " + tableSchemaOrName + " was not found.");
                                    oldColumn = undefined;
                                    if (oldColumnSchemaOrName instanceof ColumnSchema_7.ColumnSchema) {
                                        oldColumn = oldColumnSchemaOrName;
                                    }
                                    else {
                                        oldColumn = tableSchema.columns.find(function (column) { return column.name === oldColumnSchemaOrName; });
                                    }
                                    if (!oldColumn)
                                        throw new Error("Column \"" + oldColumnSchemaOrName + "\" was not found in the \"" + tableSchemaOrName + "\" table.");
                                    // todo: fix it. it should not depend on tableSchema
                                    return [2 /*return*/, this.recreateTable(tableSchema)];
                            }
                        });
                    });
                };
                /**
                 * Changes a column in the table.
                 * Changed column looses all its keys in the db.
                 */
                SqliteQueryRunner.prototype.changeColumns = function (tableSchema, changedColumns) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            if (this.isReleased)
                                throw new QueryRunnerAlreadyReleasedError_4.QueryRunnerAlreadyReleasedError();
                            // todo: fix it. it should not depend on tableSchema
                            return [2 /*return*/, this.recreateTable(tableSchema)];
                        });
                    });
                };
                /**
                 * Drops column in the table.
                 */
                SqliteQueryRunner.prototype.dropColumn = function (tableSchemaOrName, columnSchemaOrName) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            return [2 /*return*/, this.dropColumns(tableSchemaOrName, [columnSchemaOrName])];
                        });
                    });
                };
                /**
                 * Drops the columns in the table.
                 */
                SqliteQueryRunner.prototype.dropColumns = function (tableSchemaOrName, columnSchemasOrNames) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableSchema, updatingTableSchema, columns;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_4.QueryRunnerAlreadyReleasedError();
                                    return [4 /*yield*/, this.getTableSchema(tableSchemaOrName)];
                                case 1:
                                    tableSchema = _a.sent();
                                    updatingTableSchema = tableSchema.clone();
                                    columns = columnSchemasOrNames.map(function (columnSchemasOrName) {
                                        if (typeof columnSchemasOrName === "string") {
                                            var column = tableSchema.columns.find(function (column) { return column.name === columnSchemasOrName; });
                                            if (!column)
                                                throw new Error("Cannot drop a column - column \"" + columnSchemasOrName + "\" was not found in the \"" + tableSchema.name + "\" table.");
                                            return column;
                                        }
                                        else {
                                            return columnSchemasOrName;
                                        }
                                    });
                                    updatingTableSchema.removeColumns(columns);
                                    return [2 /*return*/, this.recreateTable(updatingTableSchema)];
                            }
                        });
                    });
                };
                /**
                 * Updates table's primary keys.
                 */
                SqliteQueryRunner.prototype.updatePrimaryKeys = function (dbTable) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            if (this.isReleased)
                                throw new QueryRunnerAlreadyReleasedError_4.QueryRunnerAlreadyReleasedError();
                            return [2 /*return*/, this.recreateTable(dbTable)];
                        });
                    });
                };
                /**
                 * Creates a new foreign key.
                 */
                SqliteQueryRunner.prototype.createForeignKey = function (tableSchemaOrName, foreignKey) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            if (this.isReleased)
                                throw new QueryRunnerAlreadyReleasedError_4.QueryRunnerAlreadyReleasedError();
                            return [2 /*return*/, this.createForeignKeys(tableSchemaOrName, [foreignKey])];
                        });
                    });
                };
                /**
                 * Creates a new foreign keys.
                 */
                SqliteQueryRunner.prototype.createForeignKeys = function (tableSchemaOrName, foreignKeys) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableSchema, changedTableSchema;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_4.QueryRunnerAlreadyReleasedError();
                                    return [4 /*yield*/, this.getTableSchema(tableSchemaOrName)];
                                case 1:
                                    tableSchema = _a.sent();
                                    changedTableSchema = tableSchema.clone();
                                    changedTableSchema.addForeignKeys(foreignKeys);
                                    return [2 /*return*/, this.recreateTable(changedTableSchema)];
                            }
                        });
                    });
                };
                /**
                 * Drops a foreign key from the table.
                 */
                SqliteQueryRunner.prototype.dropForeignKey = function (tableSchemaOrName, foreignKey) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            if (this.isReleased)
                                throw new QueryRunnerAlreadyReleasedError_4.QueryRunnerAlreadyReleasedError();
                            return [2 /*return*/, this.dropForeignKeys(tableSchemaOrName, [foreignKey])];
                        });
                    });
                };
                /**
                 * Drops a foreign keys from the table.
                 */
                SqliteQueryRunner.prototype.dropForeignKeys = function (tableSchemaOrName, foreignKeys) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableSchema, changedTableSchema;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_4.QueryRunnerAlreadyReleasedError();
                                    return [4 /*yield*/, this.getTableSchema(tableSchemaOrName)];
                                case 1:
                                    tableSchema = _a.sent();
                                    changedTableSchema = tableSchema.clone();
                                    changedTableSchema.removeForeignKeys(foreignKeys);
                                    return [2 /*return*/, this.recreateTable(changedTableSchema)];
                            }
                        });
                    });
                };
                /**
                 * Creates a new index.
                 */
                SqliteQueryRunner.prototype.createIndex = function (tableName, index) {
                    return __awaiter(this, void 0, void 0, function () {
                        var columnNames, sql;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_4.QueryRunnerAlreadyReleasedError();
                                    columnNames = index.columnNames.map(function (columnName) { return "\"" + columnName + "\""; }).join(",");
                                    sql = "CREATE " + (index.isUnique ? "UNIQUE " : "") + "INDEX \"" + index.name + "\" ON \"" + tableName + "\"(" + columnNames + ")";
                                    return [4 /*yield*/, this.query(sql)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Drops an index from the table.
                 */
                SqliteQueryRunner.prototype.dropIndex = function (tableName, indexName) {
                    return __awaiter(this, void 0, void 0, function () {
                        var sql;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_4.QueryRunnerAlreadyReleasedError();
                                    sql = "DROP INDEX \"" + indexName + "\"";
                                    return [4 /*yield*/, this.query(sql)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Creates a database type from a given column metadata.
                 */
                SqliteQueryRunner.prototype.normalizeType = function (typeOptions) {
                    switch (typeOptions.type) {
                        case "string":
                            return "character varying(" + (typeOptions.length ? typeOptions.length : 255) + ")";
                        case "text":
                            return "text";
                        case "boolean":
                            return "boolean";
                        case "integer":
                        case "int":
                            return "integer";
                        case "smallint":
                            return "smallint";
                        case "bigint":
                            return "bigint";
                        case "float":
                            return "real";
                        case "double":
                        case "number":
                            return "double precision";
                        case "decimal":
                            if (typeOptions.precision && typeOptions.scale) {
                                return "decimal(" + typeOptions.precision + "," + typeOptions.scale + ")";
                            }
                            else if (typeOptions.scale) {
                                return "decimal(" + typeOptions.scale + ")";
                            }
                            else if (typeOptions.precision) {
                                return "decimal(" + typeOptions.precision + ")";
                            }
                            else {
                                return "decimal";
                            }
                        case "date":
                            return "date";
                        case "time":
                            if (typeOptions.timezone) {
                                return "time with time zone";
                            }
                            else {
                                return "time without time zone";
                            }
                        case "datetime":
                            if (typeOptions.timezone) {
                                return "timestamp with time zone";
                            }
                            else {
                                return "timestamp without time zone";
                            }
                        case "json":
                            return "json";
                        case "simple_array":
                            return typeOptions.length ? "character varying(" + typeOptions.length + ")" : "text";
                    }
                    throw new DataTypeNotSupportedByDriverError_4.DataTypeNotSupportedByDriverError(typeOptions.type, "SQLite");
                };
                /**
                 * Checks if "DEFAULT" values in the column metadata and in the database schema are equal.
                 */
                SqliteQueryRunner.prototype.compareDefaultValues = function (columnMetadataValue, databaseValue) {
                    if (typeof columnMetadataValue === "number")
                        return columnMetadataValue === parseInt(databaseValue);
                    if (typeof columnMetadataValue === "boolean")
                        return columnMetadataValue === (!!databaseValue || databaseValue === "false");
                    if (typeof columnMetadataValue === "function")
                        return columnMetadataValue() === databaseValue;
                    return columnMetadataValue === databaseValue;
                };
                /**
                 * Truncates table.
                 */
                SqliteQueryRunner.prototype.truncate = function (tableName) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.query("DELETE FROM " + this.driver.escapeTableName(tableName))];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                // -------------------------------------------------------------------------
                // Protected Methods
                // -------------------------------------------------------------------------
                /**
                 * Parametrizes given object of values. Used to create column=value queries.
                 */
                SqliteQueryRunner.prototype.parametrize = function (objectLiteral, startIndex) {
                    var _this = this;
                    if (startIndex === void 0) { startIndex = 0; }
                    return Object.keys(objectLiteral).map(function (key, index) { return _this.driver.escapeColumnName(key) + "=$" + (startIndex + index + 1); });
                };
                /**
                 * Builds a query for create column.
                 */
                SqliteQueryRunner.prototype.buildCreateColumnSql = function (column) {
                    var c = "\"" + column.name + "\"";
                    if (column instanceof ColumnMetadata_4.ColumnMetadata) {
                        c += " " + this.normalizeType(column);
                    }
                    else {
                        c += " " + column.type;
                    }
                    if (column.isNullable !== true)
                        c += " NOT NULL";
                    if (column.isUnique === true)
                        c += " UNIQUE";
                    if (column.isGenerated === true)
                        c += " PRIMARY KEY AUTOINCREMENT";
                    if (column.default !== undefined && column.default !== null) {
                        if (typeof column.default === "number") {
                            c += " DEFAULT " + column.default + "";
                        }
                        else if (typeof column.default === "boolean") {
                            c += " DEFAULT " + (column.default === true ? "1" : "0") + "";
                        }
                        else if (typeof column.default === "function") {
                            c += " DEFAULT " + column.default() + "";
                        }
                        else if (typeof column.default === "string") {
                            c += " DEFAULT '" + column.default + "'";
                        }
                        else {
                            c += " DEFAULT " + column.default + "";
                        }
                    }
                    return c;
                };
                SqliteQueryRunner.prototype.recreateTable = function (tableSchema, oldTableSchema, migrateData) {
                    if (migrateData === void 0) { migrateData = true; }
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var columnDefinitions, columnNames, sql1, primaryKeyColumns, oldColumnNames, sql2, sql3, sql4, indexPromises;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    columnDefinitions = tableSchema.columns.map(function (dbColumn) { return _this.buildCreateColumnSql(dbColumn); }).join(", ");
                                    columnNames = tableSchema.columns.map(function (column) { return "\"" + column.name + "\""; }).join(", ");
                                    sql1 = "CREATE TABLE \"temporary_" + tableSchema.name + "\" (" + columnDefinitions;
                                    // if (options && options.createForeignKeys) {
                                    tableSchema.foreignKeys.forEach(function (foreignKey) {
                                        var columnNames = foreignKey.columnNames.map(function (name) { return "\"" + name + "\""; }).join(", ");
                                        var referencedColumnNames = foreignKey.referencedColumnNames.map(function (name) { return "\"" + name + "\""; }).join(", ");
                                        sql1 += ", FOREIGN KEY(" + columnNames + ") REFERENCES \"" + foreignKey.referencedTableName + "\"(" + referencedColumnNames + ")";
                                        if (foreignKey.onDelete)
                                            sql1 += " ON DELETE " + foreignKey.onDelete;
                                    });
                                    primaryKeyColumns = tableSchema.columns.filter(function (column) { return column.isPrimary && !column.isGenerated; });
                                    if (primaryKeyColumns.length > 0)
                                        sql1 += ", PRIMARY KEY(" + primaryKeyColumns.map(function (column) { return "" + column.name; }).join(", ") + ")"; // for some reason column escaping here generate a wrong schema
                                    sql1 += ")";
                                    // todo: need also create uniques and indices?
                                    // recreate a table with a temporary name
                                    return [4 /*yield*/, this.query(sql1)];
                                case 1:
                                    // todo: need also create uniques and indices?
                                    // recreate a table with a temporary name
                                    _a.sent();
                                    oldColumnNames = oldTableSchema ? oldTableSchema.columns.map(function (column) { return "\"" + column.name + "\""; }).join(", ") : columnNames;
                                    if (!migrateData) return [3 /*break*/, 3];
                                    sql2 = "INSERT INTO \"temporary_" + tableSchema.name + "\"(" + oldColumnNames + ") SELECT " + oldColumnNames + " FROM \"" + tableSchema.name + "\"";
                                    return [4 /*yield*/, this.query(sql2)];
                                case 2:
                                    _a.sent();
                                    _a.label = 3;
                                case 3:
                                    sql3 = "DROP TABLE \"" + tableSchema.name + "\"";
                                    return [4 /*yield*/, this.query(sql3)];
                                case 4:
                                    _a.sent();
                                    sql4 = "ALTER TABLE \"temporary_" + tableSchema.name + "\" RENAME TO \"" + tableSchema.name + "\"";
                                    return [4 /*yield*/, this.query(sql4)];
                                case 5:
                                    _a.sent();
                                    indexPromises = tableSchema.indices.map(function (index) { return _this.createIndex(tableSchema.name, index); });
                                    // const uniquePromises = tableSchema.uniqueKeys.map(key => this.createIndex(key));
                                    return [4 /*yield*/, Promise.all(indexPromises /*.concat(uniquePromises)*/)];
                                case 6:
                                    // const uniquePromises = tableSchema.uniqueKeys.map(key => this.createIndex(key));
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * If given value is a table name then it loads its table schema representation from the database.
                 */
                SqliteQueryRunner.prototype.getTableSchema = function (tableSchemaOrName) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableSchema;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!(tableSchemaOrName instanceof TableSchema_6.TableSchema)) return [3 /*break*/, 1];
                                    return [2 /*return*/, tableSchemaOrName];
                                case 1: return [4 /*yield*/, this.loadTableSchema(tableSchemaOrName)];
                                case 2:
                                    tableSchema = _a.sent();
                                    if (!tableSchema)
                                        throw new Error("Table named " + tableSchemaOrName + " was not found in the database.");
                                    return [2 /*return*/, tableSchema];
                            }
                        });
                    });
                };
                return SqliteQueryRunner;
            }());
            exports_144("SqliteQueryRunner", SqliteQueryRunner);
        }
    };
});
System.register("typeorm/driver/sqlite/SqliteDriver", ["typeorm/driver/error/ConnectionIsNotSetError", "typeorm/driver/error/DriverPackageNotInstalledError", "typeorm/metadata/types/ColumnTypes", "typeorm/driver/sqlite/SqliteQueryRunner", "typeorm/driver/error/DriverOptionNotSetError", "typeorm/util/DataTransformationUtils", "typeorm/platform/PlatformTools"], function (exports_145, context_145) {
    "use strict";
    var __moduleName = context_145 && context_145.id;
    var ConnectionIsNotSetError_4, DriverPackageNotInstalledError_4, ColumnTypes_7, SqliteQueryRunner_1, DriverOptionNotSetError_4, DataTransformationUtils_5, PlatformTools_7, SqliteDriver;
    return {
        setters: [
            function (ConnectionIsNotSetError_4_1) {
                ConnectionIsNotSetError_4 = ConnectionIsNotSetError_4_1;
            },
            function (DriverPackageNotInstalledError_4_1) {
                DriverPackageNotInstalledError_4 = DriverPackageNotInstalledError_4_1;
            },
            function (ColumnTypes_7_1) {
                ColumnTypes_7 = ColumnTypes_7_1;
            },
            function (SqliteQueryRunner_1_1) {
                SqliteQueryRunner_1 = SqliteQueryRunner_1_1;
            },
            function (DriverOptionNotSetError_4_1) {
                DriverOptionNotSetError_4 = DriverOptionNotSetError_4_1;
            },
            function (DataTransformationUtils_5_1) {
                DataTransformationUtils_5 = DataTransformationUtils_5_1;
            },
            function (PlatformTools_7_1) {
                PlatformTools_7 = PlatformTools_7_1;
            }
        ],
        execute: function () {
            /**
             * Organizes communication with sqlite DBMS.
             */
            SqliteDriver = (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function SqliteDriver(connectionOptions, logger, sqlite) {
                    this.options = connectionOptions;
                    this.logger = logger;
                    this.sqlite = sqlite;
                    // validate options to make sure everything is set
                    if (!this.options.storage)
                        throw new DriverOptionNotSetError_4.DriverOptionNotSetError("storage");
                    // if sqlite package instance was not set explicitly then try to load it
                    if (!sqlite)
                        this.loadDependencies();
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Performs connection to the database.
                 */
                SqliteDriver.prototype.connect = function () {
                    var _this = this;
                    return new Promise(function (ok, fail) {
                        var connection = new _this.sqlite.Database(_this.options.storage, function (err) {
                            if (err)
                                return fail(err);
                            _this.databaseConnection = {
                                id: 1,
                                connection: connection,
                                isTransactionActive: false
                            };
                            // we need to enable foreign keys in sqlite to make sure all foreign key related features
                            // working properly. this also makes onDelete to work with sqlite.
                            connection.run("PRAGMA foreign_keys = ON;", function (err, result) {
                                ok();
                            });
                        });
                    });
                };
                /**
                 * Closes connection with database.
                 */
                SqliteDriver.prototype.disconnect = function () {
                    var _this = this;
                    return new Promise(function (ok, fail) {
                        var handler = function (err) { return err ? fail(err) : ok(); };
                        if (!_this.databaseConnection)
                            return fail(new ConnectionIsNotSetError_4.ConnectionIsNotSetError("sqlite"));
                        _this.databaseConnection.connection.close(handler);
                    });
                };
                /**
                 * Creates a query runner used for common queries.
                 */
                SqliteDriver.prototype.createQueryRunner = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var databaseConnection;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!this.databaseConnection)
                                        return [2 /*return*/, Promise.reject(new ConnectionIsNotSetError_4.ConnectionIsNotSetError("sqlite"))];
                                    return [4 /*yield*/, this.retrieveDatabaseConnection()];
                                case 1:
                                    databaseConnection = _a.sent();
                                    return [2 /*return*/, new SqliteQueryRunner_1.SqliteQueryRunner(databaseConnection, this, this.logger)];
                            }
                        });
                    });
                };
                /**
                 * Access to the native implementation of the database.
                 */
                SqliteDriver.prototype.nativeInterface = function () {
                    return {
                        driver: this.sqlite,
                        connection: this.databaseConnection ? this.databaseConnection.connection : undefined
                    };
                };
                /**
                 * Prepares given value to a value to be persisted, based on its column type and metadata.
                 */
                SqliteDriver.prototype.preparePersistentValue = function (value, columnMetadata) {
                    if (value === null || value === undefined)
                        return null;
                    switch (columnMetadata.type) {
                        case ColumnTypes_7.ColumnTypes.BOOLEAN:
                            return value === true ? 1 : 0;
                        case ColumnTypes_7.ColumnTypes.DATE:
                            return DataTransformationUtils_5.DataTransformationUtils.mixedDateToDateString(value);
                        case ColumnTypes_7.ColumnTypes.TIME:
                            return DataTransformationUtils_5.DataTransformationUtils.mixedDateToTimeString(value);
                        case ColumnTypes_7.ColumnTypes.DATETIME:
                            if (columnMetadata.localTimezone) {
                                return DataTransformationUtils_5.DataTransformationUtils.mixedDateToDatetimeString(value);
                            }
                            else {
                                return DataTransformationUtils_5.DataTransformationUtils.mixedDateToUtcDatetimeString(value);
                            }
                        case ColumnTypes_7.ColumnTypes.JSON:
                            return JSON.stringify(value);
                        case ColumnTypes_7.ColumnTypes.SIMPLE_ARRAY:
                            return DataTransformationUtils_5.DataTransformationUtils.simpleArrayToString(value);
                    }
                    return value;
                };
                /**
                 * Prepares given value to a value to be persisted, based on its column type or metadata.
                 */
                SqliteDriver.prototype.prepareHydratedValue = function (value, columnMetadata) {
                    switch (columnMetadata.type) {
                        case ColumnTypes_7.ColumnTypes.BOOLEAN:
                            return value ? true : false;
                        case ColumnTypes_7.ColumnTypes.DATETIME:
                            return DataTransformationUtils_5.DataTransformationUtils.normalizeHydratedDate(value, columnMetadata.localTimezone === true);
                        case ColumnTypes_7.ColumnTypes.TIME:
                            return DataTransformationUtils_5.DataTransformationUtils.mixedTimeToString(value);
                        case ColumnTypes_7.ColumnTypes.JSON:
                            return JSON.parse(value);
                        case ColumnTypes_7.ColumnTypes.SIMPLE_ARRAY:
                            return DataTransformationUtils_5.DataTransformationUtils.stringToSimpleArray(value);
                    }
                    return value;
                };
                /**
                 * Replaces parameters in the given sql with special escaping character
                 * and an array of parameter names to be passed to a query.
                 */
                SqliteDriver.prototype.escapeQueryWithParameters = function (sql, parameters) {
                    if (!parameters || !Object.keys(parameters).length)
                        return [sql, []];
                    var builtParameters = [];
                    var keys = Object.keys(parameters).map(function (parameter) { return "(:" + parameter + "\\b)"; }).join("|");
                    sql = sql.replace(new RegExp(keys, "g"), function (key) {
                        var value = parameters[key.substr(1)];
                        if (value instanceof Array) {
                            return value.map(function (v) {
                                builtParameters.push(v);
                                return "$" + builtParameters.length;
                            }).join(", ");
                        }
                        else {
                            builtParameters.push(value);
                        }
                        return "$" + builtParameters.length;
                    }); // todo: make replace only in value statements, otherwise problems
                    return [sql, builtParameters];
                };
                /**
                 * Escapes a column name.
                 */
                SqliteDriver.prototype.escapeColumnName = function (columnName) {
                    return "\"" + columnName + "\"";
                };
                /**
                 * Escapes an alias.
                 */
                SqliteDriver.prototype.escapeAliasName = function (aliasName) {
                    return "\"" + aliasName + "\"";
                };
                /**
                 * Escapes a table name.
                 */
                SqliteDriver.prototype.escapeTableName = function (tableName) {
                    return "\"" + tableName + "\"";
                };
                // -------------------------------------------------------------------------
                // Protected Methods
                // -------------------------------------------------------------------------
                /**
                 * Retrieves a new database connection.
                 * If pooling is enabled then connection from the pool will be retrieved.
                 * Otherwise active connection will be returned.
                 */
                SqliteDriver.prototype.retrieveDatabaseConnection = function () {
                    if (this.databaseConnection)
                        return Promise.resolve(this.databaseConnection);
                    throw new ConnectionIsNotSetError_4.ConnectionIsNotSetError("sqlite");
                };
                /**
                 * If driver dependency is not given explicitly, then try to load it via "require".
                 */
                SqliteDriver.prototype.loadDependencies = function () {
                    try {
                        this.sqlite = PlatformTools_7.PlatformTools.load("sqlite3").verbose();
                    }
                    catch (e) {
                        throw new DriverPackageNotInstalledError_4.DriverPackageNotInstalledError("SQLite", "sqlite3");
                    }
                };
                return SqliteDriver;
            }());
            exports_145("SqliteDriver", SqliteDriver);
        }
    };
});
System.register("typeorm/driver/oracle/OracleQueryRunner", ["typeorm/driver/error/TransactionAlreadyStartedError", "typeorm/driver/error/TransactionNotStartedError", "typeorm/driver/error/DataTypeNotSupportedByDriverError", "typeorm/schema-builder/schema/ColumnSchema", "typeorm/schema-builder/schema/TableSchema", "typeorm/schema-builder/schema/ForeignKeySchema", "typeorm/schema-builder/schema/PrimaryKeySchema", "typeorm/query-runner/error/QueryRunnerAlreadyReleasedError"], function (exports_146, context_146) {
    "use strict";
    var __moduleName = context_146 && context_146.id;
    var TransactionAlreadyStartedError_5, TransactionNotStartedError_5, DataTypeNotSupportedByDriverError_5, ColumnSchema_8, TableSchema_7, ForeignKeySchema_6, PrimaryKeySchema_6, QueryRunnerAlreadyReleasedError_5, OracleQueryRunner;
    return {
        setters: [
            function (TransactionAlreadyStartedError_5_1) {
                TransactionAlreadyStartedError_5 = TransactionAlreadyStartedError_5_1;
            },
            function (TransactionNotStartedError_5_1) {
                TransactionNotStartedError_5 = TransactionNotStartedError_5_1;
            },
            function (DataTypeNotSupportedByDriverError_5_1) {
                DataTypeNotSupportedByDriverError_5 = DataTypeNotSupportedByDriverError_5_1;
            },
            function (ColumnSchema_8_1) {
                ColumnSchema_8 = ColumnSchema_8_1;
            },
            function (TableSchema_7_1) {
                TableSchema_7 = TableSchema_7_1;
            },
            function (ForeignKeySchema_6_1) {
                ForeignKeySchema_6 = ForeignKeySchema_6_1;
            },
            function (PrimaryKeySchema_6_1) {
                PrimaryKeySchema_6 = PrimaryKeySchema_6_1;
            },
            function (QueryRunnerAlreadyReleasedError_5_1) {
                QueryRunnerAlreadyReleasedError_5 = QueryRunnerAlreadyReleasedError_5_1;
            }
        ],
        execute: function () {
            /**
             * Runs queries on a single mysql database connection.
             *
             * todo: this driver is not 100% finished yet, need to fix all issues that are left
             */
            OracleQueryRunner = (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function OracleQueryRunner(databaseConnection, driver, logger) {
                    this.databaseConnection = databaseConnection;
                    this.driver = driver;
                    this.logger = logger;
                    // -------------------------------------------------------------------------
                    // Protected Properties
                    // -------------------------------------------------------------------------
                    /**
                     * Indicates if connection for this query runner is released.
                     * Once its released, query runner cannot run queries anymore.
                     */
                    this.isReleased = false;
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Releases database connection. This is needed when using connection pooling.
                 * If connection is not from a pool, it should not be released.
                 * You cannot use this class's methods after its released.
                 */
                OracleQueryRunner.prototype.release = function () {
                    if (this.databaseConnection.releaseCallback) {
                        this.isReleased = true;
                        return this.databaseConnection.releaseCallback();
                    }
                    return Promise.resolve();
                };
                /**
                 * Removes all tables from the currently connected database.
                 */
                OracleQueryRunner.prototype.clearDatabase = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var disableForeignKeysCheckQuery, dropTablesQuery, enableForeignKeysCheckQuery, dropQueries, error_8;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_5.QueryRunnerAlreadyReleasedError();
                                    return [4 /*yield*/, this.beginTransaction()];
                                case 1:
                                    _a.sent();
                                    _a.label = 2;
                                case 2:
                                    _a.trys.push([2, 8, 10, 12]);
                                    disableForeignKeysCheckQuery = "SET FOREIGN_KEY_CHECKS = 0;";
                                    dropTablesQuery = "SELECT concat('DROP TABLE IF EXISTS ', table_name, ';') AS query FROM information_schema.tables WHERE table_schema = '" + this.dbName + "'";
                                    enableForeignKeysCheckQuery = "SET FOREIGN_KEY_CHECKS = 1;";
                                    return [4 /*yield*/, this.query(disableForeignKeysCheckQuery)];
                                case 3:
                                    _a.sent();
                                    return [4 /*yield*/, this.query(dropTablesQuery)];
                                case 4:
                                    dropQueries = _a.sent();
                                    return [4 /*yield*/, Promise.all(dropQueries.map(function (query) { return _this.query(query["query"]); }))];
                                case 5:
                                    _a.sent();
                                    return [4 /*yield*/, this.query(enableForeignKeysCheckQuery)];
                                case 6:
                                    _a.sent();
                                    return [4 /*yield*/, this.commitTransaction()];
                                case 7:
                                    _a.sent();
                                    return [3 /*break*/, 12];
                                case 8:
                                    error_8 = _a.sent();
                                    return [4 /*yield*/, this.rollbackTransaction()];
                                case 9:
                                    _a.sent();
                                    throw error_8;
                                case 10: return [4 /*yield*/, this.release()];
                                case 11:
                                    _a.sent();
                                    return [7 /*endfinally*/];
                                case 12: return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Starts transaction.
                 */
                OracleQueryRunner.prototype.beginTransaction = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            if (this.isReleased)
                                throw new QueryRunnerAlreadyReleasedError_5.QueryRunnerAlreadyReleasedError();
                            if (this.databaseConnection.isTransactionActive)
                                throw new TransactionAlreadyStartedError_5.TransactionAlreadyStartedError();
                            // await this.query("START TRANSACTION");
                            this.databaseConnection.isTransactionActive = true;
                            return [2 /*return*/];
                        });
                    });
                };
                /**
                 * Commits transaction.
                 */
                OracleQueryRunner.prototype.commitTransaction = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_5.QueryRunnerAlreadyReleasedError();
                                    if (!this.databaseConnection.isTransactionActive)
                                        throw new TransactionNotStartedError_5.TransactionNotStartedError();
                                    return [4 /*yield*/, this.query("COMMIT")];
                                case 1:
                                    _a.sent();
                                    this.databaseConnection.isTransactionActive = false;
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Rollbacks transaction.
                 */
                OracleQueryRunner.prototype.rollbackTransaction = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_5.QueryRunnerAlreadyReleasedError();
                                    if (!this.databaseConnection.isTransactionActive)
                                        throw new TransactionNotStartedError_5.TransactionNotStartedError();
                                    return [4 /*yield*/, this.query("ROLLBACK")];
                                case 1:
                                    _a.sent();
                                    this.databaseConnection.isTransactionActive = false;
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Checks if transaction is in progress.
                 */
                OracleQueryRunner.prototype.isTransactionActive = function () {
                    return this.databaseConnection.isTransactionActive;
                };
                /**
                 * Executes a given SQL query.
                 */
                OracleQueryRunner.prototype.query = function (query, parameters) {
                    var _this = this;
                    if (this.isReleased)
                        throw new QueryRunnerAlreadyReleasedError_5.QueryRunnerAlreadyReleasedError();
                    return new Promise(function (ok, fail) {
                        _this.logger.logQuery(query, parameters);
                        var handler = function (err, result) {
                            if (err) {
                                _this.logger.logFailedQuery(query, parameters);
                                _this.logger.logQueryError(err);
                                return fail(err);
                            }
                            ok(result.rows || result.outBinds);
                        };
                        var executionOptions = {
                            autoCommit: _this.databaseConnection.isTransactionActive ? false : true
                        };
                        _this.databaseConnection.connection.execute(query, parameters || {}, executionOptions, handler);
                    });
                };
                /**
                 * Insert a new row with given values into given table.
                 */
                OracleQueryRunner.prototype.insert = function (tableName, keyValues, generatedColumn) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var keys, columns, values, parameters, insertSql, sql2, saveResult;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_5.QueryRunnerAlreadyReleasedError();
                                    keys = Object.keys(keyValues);
                                    columns = keys.map(function (key) { return _this.driver.escapeColumnName(key); }).join(", ");
                                    values = keys.map(function (key) { return ":" + key; }).join(", ");
                                    parameters = keys.map(function (key) { return keyValues[key]; });
                                    insertSql = columns.length > 0
                                        ? "INSERT INTO " + this.driver.escapeTableName(tableName) + "(" + columns + ") VALUES (" + values + ")"
                                        : "INSERT INTO " + this.driver.escapeTableName(tableName) + " DEFAULT VALUES";
                                    if (!generatedColumn) return [3 /*break*/, 2];
                                    sql2 = "declare lastId number; begin " + insertSql + " returning \"id\" into lastId; dbms_output.enable; dbms_output.put_line(lastId); dbms_output.get_line(:ln, :st); end;";
                                    return [4 /*yield*/, this.query(sql2, parameters.concat([
                                            { dir: this.driver.oracle.BIND_OUT, type: this.driver.oracle.STRING, maxSize: 32767 },
                                            { dir: this.driver.oracle.BIND_OUT, type: this.driver.oracle.NUMBER }
                                        ]))];
                                case 1:
                                    saveResult = _a.sent();
                                    return [2 /*return*/, parseInt(saveResult[0])];
                                case 2: return [2 /*return*/, this.query(insertSql, parameters)];
                            }
                        });
                    });
                };
                /**
                 * Updates rows that match given conditions in the given table.
                 */
                OracleQueryRunner.prototype.update = function (tableName, valuesMap, conditions) {
                    return __awaiter(this, void 0, void 0, function () {
                        var updateValues, conditionString, sql, conditionParams, updateParams, allParameters;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_5.QueryRunnerAlreadyReleasedError();
                                    updateValues = this.parametrize(valuesMap).join(", ");
                                    conditionString = this.parametrize(conditions).join(" AND ");
                                    sql = "UPDATE " + this.driver.escapeTableName(tableName) + " SET " + updateValues + " " + (conditionString ? (" WHERE " + conditionString) : "");
                                    conditionParams = Object.keys(conditions).map(function (key) { return conditions[key]; });
                                    updateParams = Object.keys(valuesMap).map(function (key) { return valuesMap[key]; });
                                    allParameters = updateParams.concat(conditionParams);
                                    return [4 /*yield*/, this.query(sql, allParameters)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Deletes from the given table by a given conditions.
                 */
                OracleQueryRunner.prototype.delete = function (tableName, conditions, maybeParameters) {
                    return __awaiter(this, void 0, void 0, function () {
                        var conditionString, parameters, sql;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_5.QueryRunnerAlreadyReleasedError();
                                    conditionString = typeof conditions === "string" ? conditions : this.parametrize(conditions).join(" AND ");
                                    parameters = conditions instanceof Object ? Object.keys(conditions).map(function (key) { return conditions[key]; }) : maybeParameters;
                                    sql = "DELETE FROM " + this.driver.escapeTableName(tableName) + " WHERE " + conditionString;
                                    return [4 /*yield*/, this.query(sql, parameters)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Inserts rows into the closure table.
                 */
                OracleQueryRunner.prototype.insertIntoClosureTable = function (tableName, newEntityId, parentId, hasLevel) {
                    return __awaiter(this, void 0, void 0, function () {
                        var sql, results;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_5.QueryRunnerAlreadyReleasedError();
                                    sql = "";
                                    if (hasLevel) {
                                        sql = "INSERT INTO " + this.driver.escapeTableName(tableName) + "(ancestor, descendant, level) " +
                                            ("SELECT ancestor, " + newEntityId + ", level + 1 FROM " + this.driver.escapeTableName(tableName) + " WHERE descendant = " + parentId + " ") +
                                            ("UNION ALL SELECT " + newEntityId + ", " + newEntityId + ", 1");
                                    }
                                    else {
                                        sql = "INSERT INTO " + this.driver.escapeTableName(tableName) + "(ancestor, descendant) " +
                                            ("SELECT ancestor, " + newEntityId + " FROM " + this.driver.escapeTableName(tableName) + " WHERE descendant = " + parentId + " ") +
                                            ("UNION ALL SELECT " + newEntityId + ", " + newEntityId);
                                    }
                                    return [4 /*yield*/, this.query(sql)];
                                case 1:
                                    _a.sent();
                                    return [4 /*yield*/, this.query("SELECT MAX(level) as level FROM " + this.driver.escapeTableName(tableName) + " WHERE descendant = " + parentId)];
                                case 2:
                                    results = _a.sent();
                                    return [2 /*return*/, results && results[0] && results[0]["level"] ? parseInt(results[0]["level"]) + 1 : 1];
                            }
                        });
                    });
                };
                /**
                 * Loads given table's data from the database.
                 */
                OracleQueryRunner.prototype.loadTableSchema = function (tableName) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableSchemas;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.loadTableSchemas([tableName])];
                                case 1:
                                    tableSchemas = _a.sent();
                                    return [2 /*return*/, tableSchemas.length > 0 ? tableSchemas[0] : undefined];
                            }
                        });
                    });
                };
                /**
                 * Loads all tables (with given names) from the database and creates a TableSchema from them.
                 */
                OracleQueryRunner.prototype.loadTableSchemas = function (tableNames) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableNamesString, tablesSql, columnsSql, indicesSql, foreignKeysSql, uniqueKeysSql, constraintsSql, _a, dbTables, dbColumns, constraints;
                        return __generator(this, function (_b) {
                            switch (_b.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_5.QueryRunnerAlreadyReleasedError();
                                    // if no tables given then no need to proceed
                                    if (!tableNames || !tableNames.length)
                                        return [2 /*return*/, []];
                                    tableNamesString = tableNames.map(function (name) { return "'" + name + "'"; }).join(", ");
                                    tablesSql = "SELECT TABLE_NAME FROM user_tables WHERE TABLE_NAME IN (" + tableNamesString + ")";
                                    columnsSql = "SELECT TABLE_NAME, COLUMN_NAME, DATA_TYPE, DATA_LENGTH, DATA_PRECISION, DATA_SCALE, NULLABLE, IDENTITY_COLUMN FROM all_tab_cols WHERE TABLE_NAME IN (" + tableNamesString + ")";
                                    indicesSql = "SELECT * FROM INFORMATION_SCHEMA.STATISTICS WHERE TABLE_SCHEMA = '" + this.dbName + "' AND INDEX_NAME != 'PRIMARY'";
                                    foreignKeysSql = "SELECT * FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE WHERE TABLE_SCHEMA = '" + this.dbName + "' AND REFERENCED_COLUMN_NAME IS NOT NULL";
                                    uniqueKeysSql = "SELECT * FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS WHERE TABLE_SCHEMA = '" + this.dbName + "' AND CONSTRAINT_TYPE = 'UNIQUE'";
                                    constraintsSql = "SELECT cols.table_name, cols.column_name, cols.position, cons.constraint_type, cons.constraint_name\nFROM all_constraints cons, all_cons_columns cols WHERE cols.table_name IN (" + tableNamesString + ") \nAND cons.constraint_name = cols.constraint_name AND cons.owner = cols.owner ORDER BY cols.table_name, cols.position";
                                    return [4 /*yield*/, Promise.all([
                                            this.query(tablesSql),
                                            this.query(columnsSql),
                                            // this.query(indicesSql),
                                            // this.query(foreignKeysSql),
                                            // this.query(uniqueKeysSql),
                                            this.query(constraintsSql),
                                        ])];
                                case 1:
                                    _a = _b.sent(), dbTables = _a[0], dbColumns = _a[1], constraints = _a[2];
                                    // if tables were not found in the db, no need to proceed
                                    if (!dbTables.length)
                                        return [2 /*return*/, []];
                                    // create table schemas for loaded tables
                                    return [2 /*return*/, dbTables.map(function (dbTable) {
                                            var tableSchema = new TableSchema_7.TableSchema(dbTable["TABLE_NAME"]);
                                            // create column schemas from the loaded columns
                                            tableSchema.columns = dbColumns
                                                .filter(function (dbColumn) { return dbColumn["TABLE_NAME"] === tableSchema.name; })
                                                .map(function (dbColumn) {
                                                var isPrimary = !!constraints
                                                    .find(function (constraint) {
                                                    return constraint["TABLE_NAME"] === tableSchema.name &&
                                                        constraint["CONSTRAINT_TYPE"] === "P" &&
                                                        constraint["COLUMN_NAME"] === dbColumn["COLUMN_NAME"];
                                                });
                                                var columnType = dbColumn["DATA_TYPE"].toLowerCase();
                                                if (dbColumn["DATA_TYPE"].toLowerCase() === "varchar2" && dbColumn["DATA_LENGTH"] !== null) {
                                                    columnType += "(" + dbColumn["DATA_LENGTH"] + ")";
                                                }
                                                else if (dbColumn["DATA_PRECISION"] !== null && dbColumn["DATA_SCALE"] !== null) {
                                                    columnType += "(" + dbColumn["DATA_PRECISION"] + "," + dbColumn["DATA_SCALE"] + ")";
                                                }
                                                else if (dbColumn["DATA_SCALE"] !== null) {
                                                    columnType += "(0," + dbColumn["DATA_SCALE"] + ")";
                                                }
                                                else if (dbColumn["DATA_PRECISION"] !== null) {
                                                    columnType += "(" + dbColumn["DATA_PRECISION"] + ")";
                                                }
                                                var columnSchema = new ColumnSchema_8.ColumnSchema();
                                                columnSchema.name = dbColumn["COLUMN_NAME"];
                                                columnSchema.type = columnType;
                                                columnSchema.default = dbColumn["COLUMN_DEFAULT"] !== null && dbColumn["COLUMN_DEFAULT"] !== undefined ? dbColumn["COLUMN_DEFAULT"] : undefined;
                                                columnSchema.isNullable = dbColumn["NULLABLE"] !== "N";
                                                columnSchema.isPrimary = isPrimary;
                                                columnSchema.isGenerated = dbColumn["IDENTITY_COLUMN"] === "YES"; // todo
                                                columnSchema.comment = ""; // todo
                                                return columnSchema;
                                            });
                                            // create primary key schema
                                            tableSchema.primaryKeys = constraints
                                                .filter(function (constraint) { return constraint["TABLE_NAME"] === tableSchema.name && constraint["CONSTRAINT_TYPE"] === "P"; })
                                                .map(function (constraint) { return new PrimaryKeySchema_6.PrimaryKeySchema(constraint["CONSTRAINT_NAME"], constraint["COLUMN_NAME"]); });
                                            // create foreign key schemas from the loaded indices
                                            tableSchema.foreignKeys = constraints
                                                .filter(function (constraint) { return constraint["TABLE_NAME"] === tableSchema.name && constraint["CONSTRAINT_TYPE"] === "R"; })
                                                .map(function (constraint) { return new ForeignKeySchema_6.ForeignKeySchema(constraint["CONSTRAINT_NAME"], [], [], "", ""); }); // todo: fix missing params
                                            // console.log(tableSchema);
                                            // create index schemas from the loaded indices
                                            // tableSchema.indices = dbIndices
                                            //     .filter(dbIndex => {
                                            //         return  dbIndex["table_name"] === tableSchema.name &&
                                            //             (!tableSchema.foreignKeys.find(foreignKey => foreignKey.name === dbIndex["INDEX_NAME"])) &&
                                            //             (!tableSchema.primaryKeys.find(primaryKey => primaryKey.name === dbIndex["INDEX_NAME"]));
                                            //     })
                                            //     .map(dbIndex => dbIndex["INDEX_NAME"])
                                            //     .filter((value, index, self) => self.indexOf(value) === index) // unqiue
                                            //     .map(dbIndexName => {
                                            //         const columnNames = dbIndices
                                            //             .filter(dbIndex => dbIndex["TABLE_NAME"] === tableSchema.name && dbIndex["INDEX_NAME"] === dbIndexName)
                                            //             .map(dbIndex => dbIndex["COLUMN_NAME"]);
                                            //
                                            //         return new IndexSchema(dbTable["TABLE_NAME"], dbIndexName, columnNames, false /* todo: uniqueness */);
                                            //     });
                                            return tableSchema;
                                        })];
                            }
                        });
                    });
                };
                /**
                 * Checks if table with the given name exist in the database.
                 */
                OracleQueryRunner.prototype.hasTable = function (tableName) {
                    return __awaiter(this, void 0, void 0, function () {
                        var sql, result;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    sql = "SELECT TABLE_NAME FROM user_tables WHERE TABLE_NAME = '" + tableName + "'";
                                    return [4 /*yield*/, this.query(sql)];
                                case 1:
                                    result = _a.sent();
                                    return [2 /*return*/, result.length ? true : false];
                            }
                        });
                    });
                };
                /**
                 * Creates a new table from the given table metadata and column metadatas.
                 */
                OracleQueryRunner.prototype.createTable = function (table) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var columnDefinitions, sql, primaryKeyColumns;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_5.QueryRunnerAlreadyReleasedError();
                                    columnDefinitions = table.columns.map(function (column) { return _this.buildCreateColumnSql(column); }).join(", ");
                                    sql = "CREATE TABLE \"" + table.name + "\" (" + columnDefinitions;
                                    primaryKeyColumns = table.columns.filter(function (column) { return column.isPrimary; });
                                    if (primaryKeyColumns.length > 0)
                                        sql += ", PRIMARY KEY(" + primaryKeyColumns.map(function (column) { return "\"" + column.name + "\""; }).join(", ") + ")";
                                    sql += ")";
                                    return [4 /*yield*/, this.query(sql)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Checks if column with the given name exist in the given table.
                 */
                OracleQueryRunner.prototype.hasColumn = function (tableName, columnName) {
                    return __awaiter(this, void 0, void 0, function () {
                        var sql, result;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    sql = "SELECT COLUMN_NAME FROM all_tab_cols WHERE TABLE_NAME = '" + tableName + "' AND COLUMN_NAME = '" + columnName + "'";
                                    return [4 /*yield*/, this.query(sql)];
                                case 1:
                                    result = _a.sent();
                                    return [2 /*return*/, result.length ? true : false];
                            }
                        });
                    });
                };
                /**
                 * Creates a new column from the column schema in the table.
                 */
                OracleQueryRunner.prototype.addColumn = function (tableSchemaOrName, column) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableName, sql;
                        return __generator(this, function (_a) {
                            if (this.isReleased)
                                throw new QueryRunnerAlreadyReleasedError_5.QueryRunnerAlreadyReleasedError();
                            tableName = tableSchemaOrName instanceof TableSchema_7.TableSchema ? tableSchemaOrName.name : tableSchemaOrName;
                            sql = "ALTER TABLE \"" + tableName + "\" ADD " + this.buildCreateColumnSql(column);
                            return [2 /*return*/, this.query(sql)];
                        });
                    });
                };
                /**
                 * Creates a new columns from the column schema in the table.
                 */
                OracleQueryRunner.prototype.addColumns = function (tableSchemaOrName, columns) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var queries;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_5.QueryRunnerAlreadyReleasedError();
                                    queries = columns.map(function (column) { return _this.addColumn(tableSchemaOrName, column); });
                                    return [4 /*yield*/, Promise.all(queries)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Renames column in the given table.
                 */
                OracleQueryRunner.prototype.renameColumn = function (tableSchemaOrName, oldColumnSchemaOrName, newColumnSchemaOrName) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableSchema, oldColumn, newColumn;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    tableSchema = undefined;
                                    if (!(tableSchemaOrName instanceof TableSchema_7.TableSchema)) return [3 /*break*/, 1];
                                    tableSchema = tableSchemaOrName;
                                    return [3 /*break*/, 3];
                                case 1: return [4 /*yield*/, this.loadTableSchema(tableSchemaOrName)];
                                case 2:
                                    tableSchema = _a.sent();
                                    _a.label = 3;
                                case 3:
                                    if (!tableSchema)
                                        throw new Error("Table " + tableSchemaOrName + " was not found.");
                                    oldColumn = undefined;
                                    if (oldColumnSchemaOrName instanceof ColumnSchema_8.ColumnSchema) {
                                        oldColumn = oldColumnSchemaOrName;
                                    }
                                    else {
                                        oldColumn = tableSchema.columns.find(function (column) { return column.name === oldColumnSchemaOrName; });
                                    }
                                    if (!oldColumn)
                                        throw new Error("Column \"" + oldColumnSchemaOrName + "\" was not found in the \"" + tableSchemaOrName + "\" table.");
                                    newColumn = undefined;
                                    if (newColumnSchemaOrName instanceof ColumnSchema_8.ColumnSchema) {
                                        newColumn = newColumnSchemaOrName;
                                    }
                                    else {
                                        newColumn = oldColumn.clone();
                                        newColumn.name = newColumnSchemaOrName;
                                    }
                                    return [2 /*return*/, this.changeColumn(tableSchema, oldColumn, newColumn)];
                            }
                        });
                    });
                };
                /**
                 * Changes a column in the table.
                 */
                OracleQueryRunner.prototype.changeColumn = function (tableSchemaOrName, oldColumnSchemaOrName, newColumn) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableSchema, oldColumn, dropPrimarySql, dropSql, createSql, sql, sql, sql;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_5.QueryRunnerAlreadyReleasedError();
                                    tableSchema = undefined;
                                    if (!(tableSchemaOrName instanceof TableSchema_7.TableSchema)) return [3 /*break*/, 1];
                                    tableSchema = tableSchemaOrName;
                                    return [3 /*break*/, 3];
                                case 1: return [4 /*yield*/, this.loadTableSchema(tableSchemaOrName)];
                                case 2:
                                    tableSchema = _a.sent();
                                    _a.label = 3;
                                case 3:
                                    if (!tableSchema)
                                        throw new Error("Table " + tableSchemaOrName + " was not found.");
                                    oldColumn = undefined;
                                    if (oldColumnSchemaOrName instanceof ColumnSchema_8.ColumnSchema) {
                                        oldColumn = oldColumnSchemaOrName;
                                    }
                                    else {
                                        oldColumn = tableSchema.columns.find(function (column) { return column.name === oldColumnSchemaOrName; });
                                    }
                                    if (!oldColumn)
                                        throw new Error("Column \"" + oldColumnSchemaOrName + "\" was not found in the \"" + tableSchemaOrName + "\" table.");
                                    if (!(newColumn.isGenerated !== oldColumn.isGenerated)) return [3 /*break*/, 10];
                                    if (!newColumn.isGenerated) return [3 /*break*/, 8];
                                    if (!(tableSchema.primaryKeys.length > 0 && oldColumn.isPrimary)) return [3 /*break*/, 5];
                                    dropPrimarySql = "ALTER TABLE \"" + tableSchema.name + "\" DROP CONSTRAINT \"" + tableSchema.primaryKeys[0].name + "\"";
                                    return [4 /*yield*/, this.query(dropPrimarySql)];
                                case 4:
                                    _a.sent();
                                    _a.label = 5;
                                case 5:
                                    dropSql = "ALTER TABLE \"" + tableSchema.name + "\" DROP COLUMN \"" + newColumn.name + "\"";
                                    return [4 /*yield*/, this.query(dropSql)];
                                case 6:
                                    _a.sent();
                                    createSql = "ALTER TABLE \"" + tableSchema.name + "\" ADD " + this.buildCreateColumnSql(newColumn);
                                    return [4 /*yield*/, this.query(createSql)];
                                case 7:
                                    _a.sent();
                                    return [3 /*break*/, 10];
                                case 8:
                                    sql = "ALTER TABLE \"" + tableSchema.name + "\" MODIFY \"" + newColumn.name + "\" DROP IDENTITY";
                                    return [4 /*yield*/, this.query(sql)];
                                case 9:
                                    _a.sent();
                                    _a.label = 10;
                                case 10:
                                    if (!(newColumn.isNullable !== oldColumn.isNullable)) return [3 /*break*/, 12];
                                    sql = "ALTER TABLE \"" + tableSchema.name + "\" MODIFY \"" + newColumn.name + "\" " + newColumn.type + " " + (newColumn.isNullable ? "NULL" : "NOT NULL");
                                    return [4 /*yield*/, this.query(sql)];
                                case 11:
                                    _a.sent();
                                    return [3 /*break*/, 14];
                                case 12:
                                    if (!(newColumn.type !== oldColumn.type)) return [3 /*break*/, 14];
                                    sql = "ALTER TABLE \"" + tableSchema.name + "\" MODIFY \"" + newColumn.name + "\" " + newColumn.type;
                                    return [4 /*yield*/, this.query(sql)];
                                case 13:
                                    _a.sent();
                                    _a.label = 14;
                                case 14: return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Changes a column in the table.
                 */
                OracleQueryRunner.prototype.changeColumns = function (tableSchema, changedColumns) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var updatePromises;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_5.QueryRunnerAlreadyReleasedError();
                                    updatePromises = changedColumns.map(function (changedColumn) { return __awaiter(_this, void 0, void 0, function () {
                                        return __generator(this, function (_a) {
                                            return [2 /*return*/, this.changeColumn(tableSchema, changedColumn.oldColumn, changedColumn.newColumn)];
                                        });
                                    }); });
                                    return [4 /*yield*/, Promise.all(updatePromises)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Drops column in the table.
                 */
                OracleQueryRunner.prototype.dropColumn = function (tableSchemaOrName, columnSchemaOrName) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableName, columnName;
                        return __generator(this, function (_a) {
                            tableName = tableSchemaOrName instanceof TableSchema_7.TableSchema ? tableSchemaOrName.name : tableSchemaOrName;
                            columnName = columnSchemaOrName instanceof ColumnSchema_8.ColumnSchema ? columnSchemaOrName.name : columnSchemaOrName;
                            return [2 /*return*/, this.query("ALTER TABLE \"" + tableName + "\" DROP COLUMN \"" + columnName + "\"")];
                        });
                    });
                };
                /**
                 * Drops the columns in the table.
                 */
                OracleQueryRunner.prototype.dropColumns = function (tableSchemaOrName, columnSchemasOrNames) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var dropPromises;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_5.QueryRunnerAlreadyReleasedError();
                                    dropPromises = columnSchemasOrNames.map(function (column) { return _this.dropColumn(tableSchemaOrName, column); });
                                    return [4 /*yield*/, Promise.all(dropPromises)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Updates table's primary keys.
                 */
                OracleQueryRunner.prototype.updatePrimaryKeys = function (dbTable) {
                    return __awaiter(this, void 0, void 0, function () {
                        var primaryColumnNames;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_5.QueryRunnerAlreadyReleasedError();
                                    primaryColumnNames = dbTable.primaryKeys.map(function (primaryKey) { return "\"" + primaryKey.columnName + "\""; });
                                    if (!(dbTable.primaryKeys.length > 0 && dbTable.primaryKeys[0].name)) return [3 /*break*/, 2];
                                    return [4 /*yield*/, this.query("ALTER TABLE \"" + dbTable.name + "\" DROP CONSTRAINT \"" + dbTable.primaryKeys[0].name + "\"")];
                                case 1:
                                    _a.sent();
                                    _a.label = 2;
                                case 2:
                                    if (!(primaryColumnNames.length > 0)) return [3 /*break*/, 4];
                                    return [4 /*yield*/, this.query("ALTER TABLE \"" + dbTable.name + "\" ADD PRIMARY KEY (" + primaryColumnNames.join(", ") + ")")];
                                case 3:
                                    _a.sent();
                                    _a.label = 4;
                                case 4: return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Creates a new foreign key.
                 */
                OracleQueryRunner.prototype.createForeignKey = function (tableSchemaOrName, foreignKey) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableName, columnNames, referencedColumnNames, sql;
                        return __generator(this, function (_a) {
                            if (this.isReleased)
                                throw new QueryRunnerAlreadyReleasedError_5.QueryRunnerAlreadyReleasedError();
                            tableName = tableSchemaOrName instanceof TableSchema_7.TableSchema ? tableSchemaOrName.name : tableSchemaOrName;
                            columnNames = foreignKey.columnNames.map(function (column) { return "\"" + column + "\""; }).join(", ");
                            referencedColumnNames = foreignKey.referencedColumnNames.map(function (column) { return "\"" + column + "\""; }).join(",");
                            sql = "ALTER TABLE \"" + tableName + "\" ADD CONSTRAINT \"" + foreignKey.name + "\" " +
                                ("FOREIGN KEY (" + columnNames + ") ") +
                                ("REFERENCES \"" + foreignKey.referencedTableName + "\"(" + referencedColumnNames + ")");
                            if (foreignKey.onDelete)
                                sql += " ON DELETE " + foreignKey.onDelete;
                            return [2 /*return*/, this.query(sql)];
                        });
                    });
                };
                /**
                 * Creates a new foreign keys.
                 */
                OracleQueryRunner.prototype.createForeignKeys = function (tableSchemaOrName, foreignKeys) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var promises;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_5.QueryRunnerAlreadyReleasedError();
                                    promises = foreignKeys.map(function (foreignKey) { return _this.createForeignKey(tableSchemaOrName, foreignKey); });
                                    return [4 /*yield*/, Promise.all(promises)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Drops a foreign key from the table.
                 */
                OracleQueryRunner.prototype.dropForeignKey = function (tableSchemaOrName, foreignKey) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableName, sql;
                        return __generator(this, function (_a) {
                            if (this.isReleased)
                                throw new QueryRunnerAlreadyReleasedError_5.QueryRunnerAlreadyReleasedError();
                            tableName = tableSchemaOrName instanceof TableSchema_7.TableSchema ? tableSchemaOrName.name : tableSchemaOrName;
                            sql = "ALTER TABLE \"" + tableName + "\" DROP CONSTRAINT \"" + foreignKey.name + "\"";
                            return [2 /*return*/, this.query(sql)];
                        });
                    });
                };
                /**
                 * Drops a foreign keys from the table.
                 */
                OracleQueryRunner.prototype.dropForeignKeys = function (tableSchemaOrName, foreignKeys) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var promises;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_5.QueryRunnerAlreadyReleasedError();
                                    promises = foreignKeys.map(function (foreignKey) { return _this.dropForeignKey(tableSchemaOrName, foreignKey); });
                                    return [4 /*yield*/, Promise.all(promises)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Creates a new index.
                 */
                OracleQueryRunner.prototype.createIndex = function (tableName, index) {
                    return __awaiter(this, void 0, void 0, function () {
                        var columns, sql;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_5.QueryRunnerAlreadyReleasedError();
                                    columns = index.columnNames.map(function (columnName) { return "\"" + columnName + "\""; }).join(", ");
                                    sql = "CREATE " + (index.isUnique ? "UNIQUE" : "") + " INDEX \"" + index.name + "\" ON \"" + tableName + "\"(" + columns + ")";
                                    return [4 /*yield*/, this.query(sql)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Drops an index from the table.
                 */
                OracleQueryRunner.prototype.dropIndex = function (tableName, indexName) {
                    return __awaiter(this, void 0, void 0, function () {
                        var sql;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_5.QueryRunnerAlreadyReleasedError();
                                    sql = "ALTER TABLE \"" + tableName + "\" DROP INDEX \"" + indexName + "\"";
                                    return [4 /*yield*/, this.query(sql)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Creates a database type from a given column metadata.
                 */
                OracleQueryRunner.prototype.normalizeType = function (typeOptions) {
                    switch (typeOptions.type) {
                        case "string":
                            return "varchar2(" + (typeOptions.length ? typeOptions.length : 255) + ")";
                        case "text":
                            return "clob";
                        case "boolean":
                            return "number(1)";
                        case "integer":
                        case "int":
                            // if (column.isGenerated)
                            //     return `number(22)`;
                            if (typeOptions.precision && typeOptions.scale)
                                return "number(" + typeOptions.precision + "," + typeOptions.scale + ")";
                            if (typeOptions.precision)
                                return "number(" + typeOptions.precision + ",0)";
                            if (typeOptions.scale)
                                return "number(0," + typeOptions.scale + ")";
                            return "number(10,0)";
                        case "smallint":
                            return "number(5)";
                        case "bigint":
                            return "number(20)";
                        case "float":
                            if (typeOptions.precision && typeOptions.scale)
                                return "float(" + typeOptions.precision + "," + typeOptions.scale + ")";
                            if (typeOptions.precision)
                                return "float(" + typeOptions.precision + ",0)";
                            if (typeOptions.scale)
                                return "float(0," + typeOptions.scale + ")";
                            return "float(126)";
                        case "double":
                        case "number":
                            return "float(126)";
                        case "decimal":
                            if (typeOptions.precision && typeOptions.scale) {
                                return "decimal(" + typeOptions.precision + "," + typeOptions.scale + ")";
                            }
                            else if (typeOptions.scale) {
                                return "decimal(0," + typeOptions.scale + ")";
                            }
                            else if (typeOptions.precision) {
                                return "decimal(" + typeOptions.precision + ")";
                            }
                            else {
                                return "decimal";
                            }
                        case "date":
                            return "date";
                        case "time":
                            return "date";
                        case "datetime":
                            return "timestamp(0)";
                        case "json":
                            return "clob";
                        case "simple_array":
                            return typeOptions.length ? "varchar2(" + typeOptions.length + ")" : "text";
                    }
                    throw new DataTypeNotSupportedByDriverError_5.DataTypeNotSupportedByDriverError(typeOptions.type, "Oracle");
                };
                /**
                 * Checks if "DEFAULT" values in the column metadata and in the database schema are equal.
                 */
                OracleQueryRunner.prototype.compareDefaultValues = function (columnMetadataValue, databaseValue) {
                    if (typeof columnMetadataValue === "number")
                        return columnMetadataValue === parseInt(databaseValue);
                    if (typeof columnMetadataValue === "boolean")
                        return columnMetadataValue === (!!databaseValue || databaseValue === "false");
                    if (typeof columnMetadataValue === "function")
                        return columnMetadataValue() === databaseValue;
                    return columnMetadataValue === databaseValue;
                };
                /**
                 * Truncates table.
                 */
                OracleQueryRunner.prototype.truncate = function (tableName) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.query("TRUNCATE TABLE " + this.driver.escapeTableName(tableName))];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                Object.defineProperty(OracleQueryRunner.prototype, "dbName", {
                    // -------------------------------------------------------------------------
                    // Protected Methods
                    // -------------------------------------------------------------------------
                    /**
                     * Database name shortcut.
                     */
                    get: function () {
                        return this.driver.options.database;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Parametrizes given object of values. Used to create column=value queries.
                 */
                OracleQueryRunner.prototype.parametrize = function (objectLiteral) {
                    var _this = this;
                    return Object.keys(objectLiteral).map(function (key) { return _this.driver.escapeColumnName(key) + "=:" + key; });
                };
                /**
                 * Builds a query for create column.
                 */
                OracleQueryRunner.prototype.buildCreateColumnSql = function (column) {
                    var c = "\"" + column.name + "\" " + column.type;
                    if (column.isNullable !== true && !column.isGenerated)
                        c += " NOT NULL";
                    // if (column.isPrimary === true && addPrimary)
                    //     c += " PRIMARY KEY";
                    if (column.isGenerated === true)
                        c += " GENERATED BY DEFAULT ON NULL AS IDENTITY";
                    // if (column.comment) // todo: less priority, fix it later
                    //     c += " COMMENT '" + column.comment + "'";
                    if (column.default !== undefined && column.default !== null) {
                        if (typeof column.default === "number") {
                            c += " DEFAULT " + column.default + "";
                        }
                        else if (typeof column.default === "boolean") {
                            c += " DEFAULT " + (column.default === true ? "TRUE" : "FALSE") + "";
                        }
                        else if (typeof column.default === "function") {
                            c += " DEFAULT " + column.default() + "";
                        }
                        else if (typeof column.default === "string") {
                            c += " DEFAULT '" + column.default + "'";
                        }
                        else {
                            c += " DEFAULT " + column.default + "";
                        }
                    }
                    return c;
                };
                return OracleQueryRunner;
            }());
            exports_146("OracleQueryRunner", OracleQueryRunner);
        }
    };
});
System.register("typeorm/driver/oracle/OracleDriver", ["typeorm/driver/error/ConnectionIsNotSetError", "typeorm/driver/error/DriverPackageNotInstalledError", "typeorm/driver/DriverUtils", "typeorm/driver/oracle/OracleQueryRunner", "typeorm/metadata/types/ColumnTypes", "typeorm/driver/error/DriverOptionNotSetError", "typeorm/util/DataTransformationUtils", "typeorm/platform/PlatformTools"], function (exports_147, context_147) {
    "use strict";
    var __moduleName = context_147 && context_147.id;
    var ConnectionIsNotSetError_5, DriverPackageNotInstalledError_5, DriverUtils_4, OracleQueryRunner_1, ColumnTypes_8, DriverOptionNotSetError_5, DataTransformationUtils_6, PlatformTools_8, OracleDriver;
    return {
        setters: [
            function (ConnectionIsNotSetError_5_1) {
                ConnectionIsNotSetError_5 = ConnectionIsNotSetError_5_1;
            },
            function (DriverPackageNotInstalledError_5_1) {
                DriverPackageNotInstalledError_5 = DriverPackageNotInstalledError_5_1;
            },
            function (DriverUtils_4_1) {
                DriverUtils_4 = DriverUtils_4_1;
            },
            function (OracleQueryRunner_1_1) {
                OracleQueryRunner_1 = OracleQueryRunner_1_1;
            },
            function (ColumnTypes_8_1) {
                ColumnTypes_8 = ColumnTypes_8_1;
            },
            function (DriverOptionNotSetError_5_1) {
                DriverOptionNotSetError_5 = DriverOptionNotSetError_5_1;
            },
            function (DataTransformationUtils_6_1) {
                DataTransformationUtils_6 = DataTransformationUtils_6_1;
            },
            function (PlatformTools_8_1) {
                PlatformTools_8 = PlatformTools_8_1;
            }
        ],
        execute: function () {
            /**
             * Organizes communication with Oracle DBMS.
             *
             * todo: this driver is not 100% finished yet, need to fix all issues that are left
             */
            OracleDriver = (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function OracleDriver(options, logger, oracle) {
                    /**
                     * Pool of database connections.
                     */
                    this.databaseConnectionPool = [];
                    this.options = DriverUtils_4.DriverUtils.buildDriverOptions(options, { useSid: true });
                    this.logger = logger;
                    this.oracle = oracle;
                    // validate options to make sure everything is set
                    if (!this.options.host)
                        throw new DriverOptionNotSetError_5.DriverOptionNotSetError("host");
                    if (!this.options.username)
                        throw new DriverOptionNotSetError_5.DriverOptionNotSetError("username");
                    if (!this.options.sid)
                        throw new DriverOptionNotSetError_5.DriverOptionNotSetError("sid");
                    // if oracle package instance was not set explicitly then try to load it
                    if (!oracle)
                        this.loadDependencies();
                    this.oracle.outFormat = this.oracle.OBJECT;
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Performs connection to the database.
                 * Based on pooling options, it can either create connection immediately,
                 * either create a pool and create connection when needed.
                 */
                OracleDriver.prototype.connect = function () {
                    var _this = this;
                    // build connection options for the driver
                    var options = Object.assign({}, {
                        user: this.options.username,
                        password: this.options.password,
                        connectString: this.options.host + ":" + this.options.port + "/" + this.options.sid,
                    }, this.options.extra || {});
                    // pooling is enabled either when its set explicitly to true,
                    // either when its not defined at all (e.g. enabled by default)
                    if (this.options.usePool === undefined || this.options.usePool === true) {
                        return new Promise(function (ok, fail) {
                            _this.oracle.createPool(options, function (err, pool) {
                                if (err)
                                    return fail(err);
                                _this.pool = pool;
                                ok();
                            });
                        });
                    }
                    else {
                        return new Promise(function (ok, fail) {
                            _this.oracle.getConnection(options, function (err, connection) {
                                if (err)
                                    return fail(err);
                                _this.databaseConnection = {
                                    id: 1,
                                    connection: connection,
                                    isTransactionActive: false
                                };
                                _this.databaseConnection.connection.connect(function (err) { return err ? fail(err) : ok(); });
                            });
                        });
                    }
                };
                /**
                 * Closes connection with the database.
                 */
                OracleDriver.prototype.disconnect = function () {
                    var _this = this;
                    if (!this.databaseConnection && !this.pool)
                        throw new ConnectionIsNotSetError_5.ConnectionIsNotSetError("oracle");
                    return new Promise(function (ok, fail) {
                        var handler = function (err) { return err ? fail(err) : ok(); };
                        // if pooling is used, then disconnect from it
                        if (_this.pool) {
                            _this.pool.close(handler);
                            _this.pool = undefined;
                            _this.databaseConnectionPool = [];
                        }
                        // if single connection is opened, then close it
                        if (_this.databaseConnection) {
                            _this.databaseConnection.connection.close(handler);
                            _this.databaseConnection = undefined;
                        }
                    });
                };
                /**
                 * Creates a query runner used for common queries.
                 */
                OracleDriver.prototype.createQueryRunner = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var databaseConnection;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!this.databaseConnection && !this.pool)
                                        return [2 /*return*/, Promise.reject(new ConnectionIsNotSetError_5.ConnectionIsNotSetError("oracle"))];
                                    return [4 /*yield*/, this.retrieveDatabaseConnection()];
                                case 1:
                                    databaseConnection = _a.sent();
                                    return [2 /*return*/, new OracleQueryRunner_1.OracleQueryRunner(databaseConnection, this, this.logger)];
                            }
                        });
                    });
                };
                /**
                 * Access to the native implementation of the database.
                 */
                OracleDriver.prototype.nativeInterface = function () {
                    return {
                        driver: this.oracle,
                        connection: this.databaseConnection ? this.databaseConnection.connection : undefined,
                        pool: this.pool
                    };
                };
                /**
                 * Replaces parameters in the given sql with special escaping character
                 * and an array of parameter names to be passed to a query.
                 */
                OracleDriver.prototype.escapeQueryWithParameters = function (sql, parameters) {
                    if (!parameters || !Object.keys(parameters).length)
                        return [sql, []];
                    var escapedParameters = [];
                    var keys = Object.keys(parameters).map(function (parameter) { return "(:" + parameter + "\\b)"; }).join("|");
                    sql = sql.replace(new RegExp(keys, "g"), function (key) {
                        escapedParameters.push(parameters[key.substr(1)]);
                        return ":" + key;
                    }); // todo: make replace only in value statements, otherwise problems
                    return [sql, escapedParameters];
                };
                /**
                 * Escapes a column name.
                 */
                OracleDriver.prototype.escapeColumnName = function (columnName) {
                    return "\"" + columnName + "\""; // "`" + columnName + "`";
                };
                /**
                 * Escapes an alias.
                 */
                OracleDriver.prototype.escapeAliasName = function (aliasName) {
                    return "\"" + aliasName + "\"";
                };
                /**
                 * Escapes a table name.
                 */
                OracleDriver.prototype.escapeTableName = function (tableName) {
                    return "\"" + tableName + "\"";
                };
                /**
                 * Prepares given value to a value to be persisted, based on its column type and metadata.
                 */
                OracleDriver.prototype.preparePersistentValue = function (value, columnMetadata) {
                    if (value === null || value === undefined)
                        return null;
                    switch (columnMetadata.type) {
                        case ColumnTypes_8.ColumnTypes.BOOLEAN:
                            return value === true ? 1 : 0;
                        case ColumnTypes_8.ColumnTypes.DATE:
                            return DataTransformationUtils_6.DataTransformationUtils.mixedDateToDateString(value);
                        case ColumnTypes_8.ColumnTypes.TIME:
                            return DataTransformationUtils_6.DataTransformationUtils.mixedDateToTimeString(value);
                        case ColumnTypes_8.ColumnTypes.DATETIME:
                            if (columnMetadata.localTimezone) {
                                return DataTransformationUtils_6.DataTransformationUtils.mixedDateToDatetimeString(value);
                            }
                            else {
                                return DataTransformationUtils_6.DataTransformationUtils.mixedDateToUtcDatetimeString(value);
                            }
                        case ColumnTypes_8.ColumnTypes.JSON:
                            return JSON.stringify(value);
                        case ColumnTypes_8.ColumnTypes.SIMPLE_ARRAY:
                            return DataTransformationUtils_6.DataTransformationUtils.simpleArrayToString(value);
                    }
                    return value;
                };
                /**
                 * Prepares given value to a value to be persisted, based on its column type or metadata.
                 */
                OracleDriver.prototype.prepareHydratedValue = function (value, columnMetadata) {
                    switch (columnMetadata.type) {
                        case ColumnTypes_8.ColumnTypes.BOOLEAN:
                            return value ? true : false;
                        case ColumnTypes_8.ColumnTypes.DATETIME:
                            return DataTransformationUtils_6.DataTransformationUtils.normalizeHydratedDate(value, columnMetadata.localTimezone === true);
                        case ColumnTypes_8.ColumnTypes.TIME:
                            return DataTransformationUtils_6.DataTransformationUtils.mixedTimeToString(value);
                        case ColumnTypes_8.ColumnTypes.JSON:
                            return JSON.parse(value);
                        case ColumnTypes_8.ColumnTypes.SIMPLE_ARRAY:
                            return DataTransformationUtils_6.DataTransformationUtils.stringToSimpleArray(value);
                    }
                    return value;
                };
                // -------------------------------------------------------------------------
                // Protected Methods
                // -------------------------------------------------------------------------
                /**
                 * Retrieves a new database connection.
                 * If pooling is enabled then connection from the pool will be retrieved.
                 * Otherwise active connection will be returned.
                 */
                OracleDriver.prototype.retrieveDatabaseConnection = function () {
                    var _this = this;
                    if (this.pool) {
                        return new Promise(function (ok, fail) {
                            _this.pool.getConnection(function (err, connection) {
                                if (err)
                                    return fail(err);
                                var dbConnection = _this.databaseConnectionPool.find(function (dbConnection) { return dbConnection.connection === connection; });
                                if (!dbConnection) {
                                    dbConnection = {
                                        id: _this.databaseConnectionPool.length,
                                        connection: connection,
                                        isTransactionActive: false
                                    };
                                    dbConnection.releaseCallback = function () {
                                        return new Promise(function (ok, fail) {
                                            connection.close(function (err) {
                                                if (err)
                                                    return fail(err);
                                                if (_this.pool && dbConnection) {
                                                    _this.databaseConnectionPool.splice(_this.databaseConnectionPool.indexOf(dbConnection), 1);
                                                }
                                                ok();
                                            });
                                        });
                                    };
                                    _this.databaseConnectionPool.push(dbConnection);
                                }
                                ok(dbConnection);
                            });
                        });
                    }
                    if (this.databaseConnection)
                        return Promise.resolve(this.databaseConnection);
                    throw new ConnectionIsNotSetError_5.ConnectionIsNotSetError("oracle");
                };
                /**
                 * If driver dependency is not given explicitly, then try to load it via "require".
                 */
                OracleDriver.prototype.loadDependencies = function () {
                    try {
                        this.oracle = PlatformTools_8.PlatformTools.load("oracledb");
                    }
                    catch (e) {
                        throw new DriverPackageNotInstalledError_5.DriverPackageNotInstalledError("Oracle", "oracledb");
                    }
                };
                return OracleDriver;
            }());
            exports_147("OracleDriver", OracleDriver);
        }
    };
});
System.register("typeorm/connection/error/CannotDetermineConnectionOptionsError", [], function (exports_148, context_148) {
    "use strict";
    var __moduleName = context_148 && context_148.id;
    var CannotDetermineConnectionOptionsError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown when connection is trying to be created automatically from connection options found in the ormconfig.json
             * or environment variables, but failed due to missing these configurations.
             */
            CannotDetermineConnectionOptionsError = (function (_super) {
                __extends(CannotDetermineConnectionOptionsError, _super);
                function CannotDetermineConnectionOptionsError() {
                    var _this = _super.call(this) || this;
                    _this.name = "CannotDetermineConnectionOptionsError";
                    _this.message = "Cannot create connection, because connection options are missing. " +
                        "You either need to explicitly pass connection options, either create a ormconfig.json with connection options " +
                        "and \"default\" connection name, either to set proper environment variables. Also, if you are using environment-specific " +
                        "configurations in your ormconfig.json make sure your are running under correct NODE_ENV.";
                    _this.stack = new Error().stack;
                    return _this;
                }
                return CannotDetermineConnectionOptionsError;
            }(Error));
            exports_148("CannotDetermineConnectionOptionsError", CannotDetermineConnectionOptionsError);
        }
    };
});
System.register("typeorm/driver/websql/WebsqlQueryRunner", ["typeorm/driver/error/TransactionAlreadyStartedError", "typeorm/driver/error/TransactionNotStartedError", "typeorm/driver/error/DataTypeNotSupportedByDriverError", "typeorm/schema-builder/schema/ColumnSchema", "typeorm/metadata/ColumnMetadata", "typeorm/schema-builder/schema/TableSchema", "typeorm/query-runner/error/QueryRunnerAlreadyReleasedError"], function (exports_149, context_149) {
    "use strict";
    var __moduleName = context_149 && context_149.id;
    var TransactionAlreadyStartedError_6, TransactionNotStartedError_6, DataTypeNotSupportedByDriverError_6, ColumnSchema_9, ColumnMetadata_5, TableSchema_8, QueryRunnerAlreadyReleasedError_6, WebsqlQueryRunner;
    return {
        setters: [
            function (TransactionAlreadyStartedError_6_1) {
                TransactionAlreadyStartedError_6 = TransactionAlreadyStartedError_6_1;
            },
            function (TransactionNotStartedError_6_1) {
                TransactionNotStartedError_6 = TransactionNotStartedError_6_1;
            },
            function (DataTypeNotSupportedByDriverError_6_1) {
                DataTypeNotSupportedByDriverError_6 = DataTypeNotSupportedByDriverError_6_1;
            },
            function (ColumnSchema_9_1) {
                ColumnSchema_9 = ColumnSchema_9_1;
            },
            function (ColumnMetadata_5_1) {
                ColumnMetadata_5 = ColumnMetadata_5_1;
            },
            function (TableSchema_8_1) {
                TableSchema_8 = TableSchema_8_1;
            },
            function (QueryRunnerAlreadyReleasedError_6_1) {
                QueryRunnerAlreadyReleasedError_6 = QueryRunnerAlreadyReleasedError_6_1;
            }
        ],
        execute: function () {
            /**
             * Runs queries on a single websql database connection.
             */
            WebsqlQueryRunner = (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function WebsqlQueryRunner(databaseConnection, driver, logger) {
                    this.databaseConnection = databaseConnection;
                    this.driver = driver;
                    this.logger = logger;
                    // -------------------------------------------------------------------------
                    // Protected Properties
                    // -------------------------------------------------------------------------
                    /**
                     * Indicates if connection for this query runner is released.
                     * Once its released, query runner cannot run queries anymore.
                     */
                    this.isReleased = false;
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Releases database connection. This is needed when using connection pooling.
                 * If connection is not from a pool, it should not be released.
                 * You cannot use this class's methods after its released.
                 */
                WebsqlQueryRunner.prototype.release = function () {
                    if (this.databaseConnection.releaseCallback) {
                        this.isReleased = true;
                        return this.databaseConnection.releaseCallback();
                    }
                    return Promise.resolve();
                };
                /**
                 * Removes all tables from the currently connected database.
                 */
                WebsqlQueryRunner.prototype.clearDatabase = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var selectDropsQuery, dropQueries, error_9;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_6.QueryRunnerAlreadyReleasedError();
                                    // await this.query(`PRAGMA foreign_keys = OFF;`);
                                    return [4 /*yield*/, this.beginTransaction()];
                                case 1:
                                    // await this.query(`PRAGMA foreign_keys = OFF;`);
                                    _a.sent();
                                    _a.label = 2;
                                case 2:
                                    _a.trys.push([2, 6, 8, 10]);
                                    selectDropsQuery = "select 'drop table ' || name || ';' as query from sqlite_master where type = 'table' and name != 'sqlite_sequence'";
                                    return [4 /*yield*/, this.query(selectDropsQuery)];
                                case 3:
                                    dropQueries = _a.sent();
                                    return [4 /*yield*/, Promise.all(dropQueries.map(function (q) { return _this.query(q["query"]); }))];
                                case 4:
                                    _a.sent();
                                    return [4 /*yield*/, this.commitTransaction()];
                                case 5:
                                    _a.sent();
                                    return [3 /*break*/, 10];
                                case 6:
                                    error_9 = _a.sent();
                                    return [4 /*yield*/, this.rollbackTransaction()];
                                case 7:
                                    _a.sent();
                                    throw error_9;
                                case 8: return [4 /*yield*/, this.release()];
                                case 9:
                                    _a.sent();
                                    return [7 /*endfinally*/];
                                case 10: return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Starts transaction.
                 */
                WebsqlQueryRunner.prototype.beginTransaction = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            if (this.isReleased)
                                throw new QueryRunnerAlreadyReleasedError_6.QueryRunnerAlreadyReleasedError();
                            if (this.databaseConnection.isTransactionActive)
                                throw new TransactionAlreadyStartedError_6.TransactionAlreadyStartedError();
                            this.databaseConnection.isTransactionActive = true;
                            return [2 /*return*/];
                        });
                    });
                };
                /**
                 * Commits transaction.
                 */
                WebsqlQueryRunner.prototype.commitTransaction = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            if (this.isReleased)
                                throw new QueryRunnerAlreadyReleasedError_6.QueryRunnerAlreadyReleasedError();
                            if (!this.databaseConnection.isTransactionActive)
                                throw new TransactionNotStartedError_6.TransactionNotStartedError();
                            // await this.query("COMMIT");
                            this.databaseConnection.isTransactionActive = false;
                            return [2 /*return*/];
                        });
                    });
                };
                /**
                 * Rollbacks transaction.
                 */
                WebsqlQueryRunner.prototype.rollbackTransaction = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            if (this.isReleased)
                                throw new QueryRunnerAlreadyReleasedError_6.QueryRunnerAlreadyReleasedError();
                            if (!this.databaseConnection.isTransactionActive)
                                throw new TransactionNotStartedError_6.TransactionNotStartedError();
                            // await this.query("ROLLBACK");
                            this.databaseConnection.isTransactionActive = false;
                            return [2 /*return*/];
                        });
                    });
                };
                /**
                 * Checks if transaction is in progress.
                 */
                WebsqlQueryRunner.prototype.isTransactionActive = function () {
                    return this.databaseConnection.isTransactionActive;
                };
                /**
                 * Executes a given SQL query.
                 */
                WebsqlQueryRunner.prototype.query = function (query, parameters) {
                    var _this = this;
                    if (this.isReleased)
                        throw new QueryRunnerAlreadyReleasedError_6.QueryRunnerAlreadyReleasedError();
                    return new Promise(function (ok, fail) {
                        _this.logger.logQuery(query, parameters);
                        var db = _this.databaseConnection.connection;
                        // todo: check if transaction is not active
                        db.transaction(function (tx) {
                            tx.executeSql(query, parameters, function (tx, result) {
                                var rows = Object
                                    .keys(result.rows)
                                    .filter(function (key) { return key !== "length"; })
                                    .map(function (key) { return result.rows[key]; });
                                ok(rows);
                            }, function (tx, err) {
                                _this.logger.logFailedQuery(query, parameters);
                                _this.logger.logQueryError(err);
                                return fail(err);
                            });
                        });
                    });
                };
                /**
                 * Insert a new row into given table.
                 */
                WebsqlQueryRunner.prototype.insert = function (tableName, keyValues, generatedColumn) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var keys, columns, values, sql, parameters;
                        return __generator(this, function (_a) {
                            if (this.isReleased)
                                throw new QueryRunnerAlreadyReleasedError_6.QueryRunnerAlreadyReleasedError();
                            keys = Object.keys(keyValues);
                            columns = keys.map(function (key) { return _this.driver.escapeColumnName(key); }).join(", ");
                            values = keys.map(function (key, index) { return "$" + (index + 1); }).join(",");
                            sql = columns.length > 0 ? ("INSERT INTO " + this.driver.escapeTableName(tableName) + "(" + columns + ") VALUES (" + values + ")") : "INSERT INTO " + this.driver.escapeTableName(tableName) + " DEFAULT VALUES";
                            parameters = keys.map(function (key) { return keyValues[key]; });
                            return [2 /*return*/, new Promise(function (ok, fail) {
                                    _this.logger.logQuery(sql, parameters);
                                    var db = _this.databaseConnection.connection;
                                    // todo: check if transaction is not active
                                    db.transaction(function (tx) {
                                        tx.executeSql(sql, parameters, function (tx, result) {
                                            if (generatedColumn)
                                                return ok(result["insertId"]);
                                            ok();
                                        }, function (tx, err) {
                                            _this.logger.logFailedQuery(sql, parameters);
                                            _this.logger.logQueryError(err);
                                            return fail(err);
                                        });
                                    });
                                })];
                        });
                    });
                };
                /**
                 * Updates rows that match given conditions in the given table.
                 */
                WebsqlQueryRunner.prototype.update = function (tableName, valuesMap, conditions) {
                    return __awaiter(this, void 0, void 0, function () {
                        var updateValues, conditionString, query, updateParams, conditionParams, allParameters;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_6.QueryRunnerAlreadyReleasedError();
                                    updateValues = this.parametrize(valuesMap).join(", ");
                                    conditionString = this.parametrize(conditions, Object.keys(valuesMap).length).join(" AND ");
                                    query = "UPDATE " + this.driver.escapeTableName(tableName) + " SET " + updateValues + " " + (conditionString ? (" WHERE " + conditionString) : "");
                                    updateParams = Object.keys(valuesMap).map(function (key) { return valuesMap[key]; });
                                    conditionParams = Object.keys(conditions).map(function (key) { return conditions[key]; });
                                    allParameters = updateParams.concat(conditionParams);
                                    return [4 /*yield*/, this.query(query, allParameters)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Deletes from the given table by a given conditions.
                 */
                WebsqlQueryRunner.prototype.delete = function (tableName, conditions, maybeParameters) {
                    return __awaiter(this, void 0, void 0, function () {
                        var conditionString, parameters, sql;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_6.QueryRunnerAlreadyReleasedError();
                                    conditionString = typeof conditions === "string" ? conditions : this.parametrize(conditions).join(" AND ");
                                    parameters = conditions instanceof Object ? Object.keys(conditions).map(function (key) { return conditions[key]; }) : maybeParameters;
                                    sql = "DELETE FROM " + this.driver.escapeTableName(tableName) + " WHERE " + conditionString;
                                    return [4 /*yield*/, this.query(sql, parameters)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Inserts rows into closure table.
                 */
                WebsqlQueryRunner.prototype.insertIntoClosureTable = function (tableName, newEntityId, parentId, hasLevel) {
                    return __awaiter(this, void 0, void 0, function () {
                        var sql, results;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_6.QueryRunnerAlreadyReleasedError();
                                    sql = "";
                                    if (hasLevel) {
                                        sql = "INSERT INTO " + this.driver.escapeTableName(tableName) + "(ancestor, descendant, level) " +
                                            ("SELECT ancestor, " + newEntityId + ", level + 1 FROM " + this.driver.escapeTableName(tableName) + " WHERE descendant = " + parentId + " ") +
                                            ("UNION ALL SELECT " + newEntityId + ", " + newEntityId + ", 1");
                                    }
                                    else {
                                        sql = "INSERT INTO " + this.driver.escapeTableName(tableName) + "(ancestor, descendant) " +
                                            ("SELECT ancestor, " + newEntityId + " FROM " + this.driver.escapeTableName(tableName) + " WHERE descendant = " + parentId + " ") +
                                            ("UNION ALL SELECT " + newEntityId + ", " + newEntityId);
                                    }
                                    return [4 /*yield*/, this.query(sql)];
                                case 1:
                                    _a.sent();
                                    return [4 /*yield*/, this.query("SELECT MAX(level) as level FROM " + tableName + " WHERE descendant = " + parentId)];
                                case 2:
                                    results = _a.sent();
                                    return [2 /*return*/, results && results[0] && results[0]["level"] ? parseInt(results[0]["level"]) + 1 : 1];
                            }
                        });
                    });
                };
                /**
                 * Loads given table's data from the database.
                 */
                WebsqlQueryRunner.prototype.loadTableSchema = function (tableName) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableSchemas;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.loadTableSchemas([tableName])];
                                case 1:
                                    tableSchemas = _a.sent();
                                    return [2 /*return*/, tableSchemas.length > 0 ? tableSchemas[0] : undefined];
                            }
                        });
                    });
                };
                /**
                 * Loads all tables (with given names) from the database and creates a TableSchema from them.
                 */
                WebsqlQueryRunner.prototype.loadTableSchemas = function (tableNames) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var tableNamesString, dbTables;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_6.QueryRunnerAlreadyReleasedError();
                                    // if no tables given then no need to proceed
                                    if (!tableNames || !tableNames.length)
                                        return [2 /*return*/, []];
                                    tableNamesString = tableNames.map(function (tableName) { return "'" + tableName + "'"; }).join(", ");
                                    return [4 /*yield*/, this.query("SELECT * FROM sqlite_master WHERE type = 'table' AND name IN (" + tableNamesString + ")")];
                                case 1:
                                    dbTables = _a.sent();
                                    // if tables were not found in the db, no need to proceed
                                    if (!dbTables || !dbTables.length)
                                        return [2 /*return*/, []];
                                    // create table schemas for loaded tables
                                    return [2 /*return*/, Promise.all(dbTables.map(function (dbTable) { return __awaiter(_this, void 0, void 0, function () {
                                            var tableSchema;
                                            return __generator(this, function (_a) {
                                                tableSchema = new TableSchema_8.TableSchema(dbTable["name"]);
                                                // load columns and indices
                                                /*const [dbColumns, dbIndices, dbForeignKeys]: ObjectLiteral[][] = await Promise.all([
                                                    this.query(`PRAGMA table_info("${dbTable["name"]}")`),
                                                    this.query(`PRAGMA index_list("${dbTable["name"]}")`),
                                                    this.query(`PRAGMA foreign_key_list("${dbTable["name"]}")`),
                                                ]);
                                    
                                                // find column name with auto increment
                                                let autoIncrementColumnName: string|undefined = undefined;
                                                const tableSql: string = dbTable["sql"];
                                                if (tableSql.indexOf("AUTOINCREMENT") !== -1) {
                                                    autoIncrementColumnName = tableSql.substr(0, tableSql.indexOf("AUTOINCREMENT"));
                                                    const comma = autoIncrementColumnName.lastIndexOf(",");
                                                    const bracket = autoIncrementColumnName.lastIndexOf("(");
                                                    if (comma !== -1) {
                                                        autoIncrementColumnName = autoIncrementColumnName.substr(comma);
                                                        autoIncrementColumnName = autoIncrementColumnName.substr(0, autoIncrementColumnName.lastIndexOf("\""));
                                                        autoIncrementColumnName = autoIncrementColumnName.substr(autoIncrementColumnName.indexOf("\"") + 1);
                                    
                                                    } else if (bracket !== -1) {
                                                        autoIncrementColumnName = autoIncrementColumnName.substr(bracket);
                                                        autoIncrementColumnName = autoIncrementColumnName.substr(0, autoIncrementColumnName.lastIndexOf("\""));
                                                        autoIncrementColumnName = autoIncrementColumnName.substr(autoIncrementColumnName.indexOf("\"") + 1);
                                                    }
                                                }
                                    
                                                // create column schemas from the loaded columns
                                                tableSchema.columns = dbColumns.map(dbColumn => {
                                                    const columnSchema = new ColumnSchema();
                                                    columnSchema.name = dbColumn["name"];
                                                    columnSchema.type = dbColumn["type"].toLowerCase();
                                                    columnSchema.default = dbColumn["dflt_value"] !== null && dbColumn["dflt_value"] !== undefined ? dbColumn["dflt_value"] : undefined;
                                                    columnSchema.isNullable = dbColumn["notnull"] === 0;
                                                    columnSchema.isPrimary = dbColumn["pk"] === 1;
                                                    columnSchema.comment = ""; // todo later
                                                    columnSchema.isGenerated = autoIncrementColumnName === dbColumn["name"];
                                                    const columnForeignKeys = dbForeignKeys
                                                        .filter(foreignKey => foreignKey["from"] === dbColumn["name"])
                                                        .map(foreignKey => {
                                                            const keyName = namingStrategy.foreignKeyName(dbTable["name"], [foreignKey["from"]], foreignKey["table"], [foreignKey["to"]]);
                                                            return new ForeignKeySchema(keyName, [foreignKey["from"]], [foreignKey["to"]], foreignKey["table"], foreignKey["on_delete"]); // todo: how sqlite return from and to when they are arrays? (multiple column foreign keys)
                                                        });
                                                    tableSchema.addForeignKeys(columnForeignKeys);
                                                    return columnSchema;
                                                });
                                    
                                                // create primary key schema
                                                await Promise.all(dbIndices
                                                    .filter(index => index["origin"] === "pk")
                                                    .map(async index => {
                                                        const indexInfos: ObjectLiteral[] = await this.query(`PRAGMA index_info("${index["name"]}")`);
                                                        const indexColumns = indexInfos.map(indexInfo => indexInfo["name"]);
                                                        indexColumns.forEach(indexColumn => {
                                                            tableSchema.primaryKeys.push(new PrimaryKeySchema(index["name"], indexColumn));
                                                        });
                                                    }));
                                    
                                                // create index schemas from the loaded indices
                                                const indicesPromises = dbIndices
                                                    .filter(dbIndex => {
                                                        return  dbIndex["origin"] !== "pk" &&
                                                            (!tableSchema.foreignKeys.find(foreignKey => foreignKey.name === dbIndex["name"])) &&
                                                            (!tableSchema.primaryKeys.find(primaryKey => primaryKey.name === dbIndex["name"]));
                                                    })
                                                    .map(dbIndex => dbIndex["name"])
                                                    .filter((value, index, self) => self.indexOf(value) === index) // unqiue
                                                    .map(async dbIndexName => {
                                                        const dbIndex = dbIndices.find(dbIndex => dbIndex["name"] === dbIndexName);
                                                        const indexInfos: ObjectLiteral[] = await this.query(`PRAGMA index_info("${dbIndex!["name"]}")`);
                                                        const indexColumns = indexInfos.map(indexInfo => indexInfo["name"]);
                                    
                                                        // check if db index is generated by sqlite itself and has special use case
                                                        if (dbIndex!["name"].substr(0, "sqlite_autoindex".length) === "sqlite_autoindex") {
                                                            if (dbIndex!["unique"] === 1) { // this means we have a special index generated for a column
                                                                // so we find and update the column
                                                                indexColumns.forEach(columnName => {
                                                                    const column = tableSchema.columns.find(column => column.name === columnName);
                                                                    if (column)
                                                                        column.isUnique = true;
                                                                });
                                                            }
                                    
                                                            return Promise.resolve(undefined);
                                    
                                                        } else {
                                                            return new IndexSchema(dbTable["name"], dbIndex!["name"], indexColumns, dbIndex!["unique"] === "1");
                                                        }
                                                    });
                                    
                                                const indices = await Promise.all(indicesPromises);
                                                tableSchema.indices = indices.filter(index => !!index) as IndexSchema[];*/
                                                return [2 /*return*/, tableSchema];
                                            });
                                        }); }))];
                            }
                        });
                    });
                };
                /**
                 * Checks if table with the given name exist in the database.
                 */
                WebsqlQueryRunner.prototype.hasTable = function (tableName) {
                    return __awaiter(this, void 0, void 0, function () {
                        var sql, result;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    sql = "SELECT * FROM sqlite_master WHERE type = 'table' AND name = " + tableName + "'";
                                    return [4 /*yield*/, this.query(sql)];
                                case 1:
                                    result = _a.sent();
                                    return [2 /*return*/, result.length ? true : false];
                            }
                        });
                    });
                };
                /**
                 * Creates a new table from the given table metadata and column metadatas.
                 */
                WebsqlQueryRunner.prototype.createTable = function (table) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var columnDefinitions, sql, primaryKeyColumns;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_6.QueryRunnerAlreadyReleasedError();
                                    columnDefinitions = table.columns.map(function (column) { return _this.buildCreateColumnSql(column); }).join(", ");
                                    sql = "CREATE TABLE \"" + table.name + "\" (" + columnDefinitions;
                                    primaryKeyColumns = table.columns.filter(function (column) { return column.isPrimary && !column.isGenerated; });
                                    if (primaryKeyColumns.length > 0)
                                        sql += ", PRIMARY KEY(" + primaryKeyColumns.map(function (column) { return "" + column.name; }).join(", ") + ")"; // for some reason column escaping here generates a wrong schema
                                    sql += ")";
                                    return [4 /*yield*/, this.query(sql)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Checks if column with the given name exist in the given table.
                 */
                WebsqlQueryRunner.prototype.hasColumn = function (tableName, columnName) {
                    return __awaiter(this, void 0, void 0, function () {
                        var sql, columns;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    sql = "PRAGMA table_info(\"" + tableName + "\")";
                                    return [4 /*yield*/, this.query(sql)];
                                case 1:
                                    columns = _a.sent();
                                    return [2 /*return*/, !!columns.find(function (column) { return column["name"] === columnName; })];
                            }
                        });
                    });
                };
                /**
                 * Creates a new column from the column schema in the table.
                 */
                WebsqlQueryRunner.prototype.addColumn = function (tableSchemaOrName, column) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableSchema, newTableSchema;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_6.QueryRunnerAlreadyReleasedError();
                                    return [4 /*yield*/, this.getTableSchema(tableSchemaOrName)];
                                case 1:
                                    tableSchema = _a.sent();
                                    newTableSchema = tableSchema.clone();
                                    newTableSchema.addColumns([column]);
                                    return [4 /*yield*/, this.recreateTable(newTableSchema, tableSchema)];
                                case 2:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Creates a new columns from the column schema in the table.
                 */
                WebsqlQueryRunner.prototype.addColumns = function (tableSchemaOrName, columns) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableSchema, newTableSchema;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_6.QueryRunnerAlreadyReleasedError();
                                    return [4 /*yield*/, this.getTableSchema(tableSchemaOrName)];
                                case 1:
                                    tableSchema = _a.sent();
                                    newTableSchema = tableSchema.clone();
                                    newTableSchema.addColumns(columns);
                                    return [4 /*yield*/, this.recreateTable(newTableSchema, tableSchema)];
                                case 2:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Renames column in the given table.
                 */
                WebsqlQueryRunner.prototype.renameColumn = function (tableSchemaOrName, oldColumnSchemaOrName, newColumnSchemaOrName) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableSchema, oldColumn, newColumn;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    tableSchema = undefined;
                                    if (!(tableSchemaOrName instanceof TableSchema_8.TableSchema)) return [3 /*break*/, 1];
                                    tableSchema = tableSchemaOrName;
                                    return [3 /*break*/, 3];
                                case 1: return [4 /*yield*/, this.loadTableSchema(tableSchemaOrName)];
                                case 2:
                                    tableSchema = _a.sent();
                                    _a.label = 3;
                                case 3:
                                    if (!tableSchema)
                                        throw new Error("Table " + tableSchemaOrName + " was not found.");
                                    oldColumn = undefined;
                                    if (oldColumnSchemaOrName instanceof ColumnSchema_9.ColumnSchema) {
                                        oldColumn = oldColumnSchemaOrName;
                                    }
                                    else {
                                        oldColumn = tableSchema.columns.find(function (column) { return column.name === oldColumnSchemaOrName; });
                                    }
                                    if (!oldColumn)
                                        throw new Error("Column \"" + oldColumnSchemaOrName + "\" was not found in the \"" + tableSchemaOrName + "\" table.");
                                    newColumn = undefined;
                                    if (newColumnSchemaOrName instanceof ColumnSchema_9.ColumnSchema) {
                                        newColumn = newColumnSchemaOrName;
                                    }
                                    else {
                                        newColumn = oldColumn.clone();
                                        newColumn.name = newColumnSchemaOrName;
                                    }
                                    return [2 /*return*/, this.changeColumn(tableSchema, oldColumn, newColumn)];
                            }
                        });
                    });
                };
                /**
                 * Changes a column in the table.
                 */
                WebsqlQueryRunner.prototype.changeColumn = function (tableSchemaOrName, oldColumnSchemaOrName, newColumn) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableSchema, oldColumn;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_6.QueryRunnerAlreadyReleasedError();
                                    tableSchema = undefined;
                                    if (!(tableSchemaOrName instanceof TableSchema_8.TableSchema)) return [3 /*break*/, 1];
                                    tableSchema = tableSchemaOrName;
                                    return [3 /*break*/, 3];
                                case 1: return [4 /*yield*/, this.loadTableSchema(tableSchemaOrName)];
                                case 2:
                                    tableSchema = _a.sent();
                                    _a.label = 3;
                                case 3:
                                    if (!tableSchema)
                                        throw new Error("Table " + tableSchemaOrName + " was not found.");
                                    oldColumn = undefined;
                                    if (oldColumnSchemaOrName instanceof ColumnSchema_9.ColumnSchema) {
                                        oldColumn = oldColumnSchemaOrName;
                                    }
                                    else {
                                        oldColumn = tableSchema.columns.find(function (column) { return column.name === oldColumnSchemaOrName; });
                                    }
                                    if (!oldColumn)
                                        throw new Error("Column \"" + oldColumnSchemaOrName + "\" was not found in the \"" + tableSchemaOrName + "\" table.");
                                    // todo: fix it. it should not depend on tableSchema
                                    return [2 /*return*/, this.recreateTable(tableSchema)];
                            }
                        });
                    });
                };
                /**
                 * Changes a column in the table.
                 * Changed column looses all its keys in the db.
                 */
                WebsqlQueryRunner.prototype.changeColumns = function (tableSchema, changedColumns) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            if (this.isReleased)
                                throw new QueryRunnerAlreadyReleasedError_6.QueryRunnerAlreadyReleasedError();
                            // todo: fix it. it should not depend on tableSchema
                            return [2 /*return*/, this.recreateTable(tableSchema)];
                        });
                    });
                };
                /**
                 * Drops column in the table.
                 */
                WebsqlQueryRunner.prototype.dropColumn = function (tableSchemaOrName, columnSchemaOrName) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            return [2 /*return*/, this.dropColumns(tableSchemaOrName, [columnSchemaOrName])];
                        });
                    });
                };
                /**
                 * Drops the columns in the table.
                 */
                WebsqlQueryRunner.prototype.dropColumns = function (tableSchemaOrName, columnSchemasOrNames) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableSchema, updatingTableSchema, columns;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_6.QueryRunnerAlreadyReleasedError();
                                    return [4 /*yield*/, this.getTableSchema(tableSchemaOrName)];
                                case 1:
                                    tableSchema = _a.sent();
                                    updatingTableSchema = tableSchema.clone();
                                    columns = columnSchemasOrNames.map(function (columnSchemasOrName) {
                                        if (typeof columnSchemasOrName === "string") {
                                            var column = tableSchema.columns.find(function (column) { return column.name === columnSchemasOrName; });
                                            if (!column)
                                                throw new Error("Cannot drop a column - column \"" + columnSchemasOrName + "\" was not found in the \"" + tableSchema.name + "\" table.");
                                            return column;
                                        }
                                        else {
                                            return columnSchemasOrName;
                                        }
                                    });
                                    updatingTableSchema.removeColumns(columns);
                                    return [2 /*return*/, this.recreateTable(updatingTableSchema)];
                            }
                        });
                    });
                };
                /**
                 * Updates table's primary keys.
                 */
                WebsqlQueryRunner.prototype.updatePrimaryKeys = function (dbTable) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            if (this.isReleased)
                                throw new QueryRunnerAlreadyReleasedError_6.QueryRunnerAlreadyReleasedError();
                            return [2 /*return*/, this.recreateTable(dbTable)];
                        });
                    });
                };
                /**
                 * Creates a new foreign key.
                 */
                WebsqlQueryRunner.prototype.createForeignKey = function (tableSchemaOrName, foreignKey) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            if (this.isReleased)
                                throw new QueryRunnerAlreadyReleasedError_6.QueryRunnerAlreadyReleasedError();
                            return [2 /*return*/, this.createForeignKeys(tableSchemaOrName, [foreignKey])];
                        });
                    });
                };
                /**
                 * Creates a new foreign keys.
                 */
                WebsqlQueryRunner.prototype.createForeignKeys = function (tableSchemaOrName, foreignKeys) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableSchema, changedTableSchema;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_6.QueryRunnerAlreadyReleasedError();
                                    return [4 /*yield*/, this.getTableSchema(tableSchemaOrName)];
                                case 1:
                                    tableSchema = _a.sent();
                                    changedTableSchema = tableSchema.clone();
                                    changedTableSchema.addForeignKeys(foreignKeys);
                                    return [2 /*return*/, this.recreateTable(changedTableSchema)];
                            }
                        });
                    });
                };
                /**
                 * Drops a foreign key from the table.
                 */
                WebsqlQueryRunner.prototype.dropForeignKey = function (tableSchemaOrName, foreignKey) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            if (this.isReleased)
                                throw new QueryRunnerAlreadyReleasedError_6.QueryRunnerAlreadyReleasedError();
                            return [2 /*return*/, this.dropForeignKeys(tableSchemaOrName, [foreignKey])];
                        });
                    });
                };
                /**
                 * Drops a foreign keys from the table.
                 */
                WebsqlQueryRunner.prototype.dropForeignKeys = function (tableSchemaOrName, foreignKeys) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableSchema, changedTableSchema;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_6.QueryRunnerAlreadyReleasedError();
                                    return [4 /*yield*/, this.getTableSchema(tableSchemaOrName)];
                                case 1:
                                    tableSchema = _a.sent();
                                    changedTableSchema = tableSchema.clone();
                                    changedTableSchema.removeForeignKeys(foreignKeys);
                                    return [2 /*return*/, this.recreateTable(changedTableSchema)];
                            }
                        });
                    });
                };
                /**
                 * Creates a new index.
                 */
                WebsqlQueryRunner.prototype.createIndex = function (tableName, index) {
                    return __awaiter(this, void 0, void 0, function () {
                        var columnNames, sql;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_6.QueryRunnerAlreadyReleasedError();
                                    columnNames = index.columnNames.map(function (columnName) { return "\"" + columnName + "\""; }).join(",");
                                    sql = "CREATE " + (index.isUnique ? "UNIQUE " : "") + "INDEX \"" + index.name + "\" ON \"" + tableName + "\"(" + columnNames + ")";
                                    return [4 /*yield*/, this.query(sql)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Drops an index from the table.
                 */
                WebsqlQueryRunner.prototype.dropIndex = function (tableName, indexName) {
                    return __awaiter(this, void 0, void 0, function () {
                        var sql;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_6.QueryRunnerAlreadyReleasedError();
                                    sql = "DROP INDEX \"" + indexName + "\"";
                                    return [4 /*yield*/, this.query(sql)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Creates a database type from a given column metadata.
                 */
                WebsqlQueryRunner.prototype.normalizeType = function (typeOptions) {
                    switch (typeOptions.type) {
                        case "string":
                            return "character varying(" + (typeOptions.length ? typeOptions.length : 255) + ")";
                        case "text":
                            return "text";
                        case "boolean":
                            return "boolean";
                        case "integer":
                        case "int":
                            return "integer";
                        case "smallint":
                            return "smallint";
                        case "bigint":
                            return "bigint";
                        case "float":
                            return "real";
                        case "double":
                        case "number":
                            return "double precision";
                        case "decimal":
                            if (typeOptions.precision && typeOptions.scale) {
                                return "decimal(" + typeOptions.precision + "," + typeOptions.scale + ")";
                            }
                            else if (typeOptions.scale) {
                                return "decimal(" + typeOptions.scale + ")";
                            }
                            else if (typeOptions.precision) {
                                return "decimal(" + typeOptions.precision + ")";
                            }
                            else {
                                return "decimal";
                            }
                        case "date":
                            return "date";
                        case "time":
                            if (typeOptions.timezone) {
                                return "time with time zone";
                            }
                            else {
                                return "time without time zone";
                            }
                        case "datetime":
                            if (typeOptions.timezone) {
                                return "timestamp with time zone";
                            }
                            else {
                                return "timestamp without time zone";
                            }
                        case "json":
                            return "json";
                        case "simple_array":
                            return typeOptions.length ? "character varying(" + typeOptions.length + ")" : "text";
                    }
                    throw new DataTypeNotSupportedByDriverError_6.DataTypeNotSupportedByDriverError(typeOptions.type, "WebSQL");
                };
                /**
                 * Checks if "DEFAULT" values in the column metadata and in the database schema are equal.
                 */
                WebsqlQueryRunner.prototype.compareDefaultValues = function (columnMetadataValue, databaseValue) {
                    if (typeof columnMetadataValue === "number")
                        return columnMetadataValue === parseInt(databaseValue);
                    if (typeof columnMetadataValue === "boolean")
                        return columnMetadataValue === (!!databaseValue || databaseValue === "false");
                    if (typeof columnMetadataValue === "function")
                        return columnMetadataValue() === databaseValue;
                    return columnMetadataValue === databaseValue;
                };
                /**
                 * Truncates table.
                 */
                WebsqlQueryRunner.prototype.truncate = function (tableName) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.query("DELETE FROM " + this.driver.escapeTableName(tableName))];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                // -------------------------------------------------------------------------
                // Protected Methods
                // -------------------------------------------------------------------------
                /**
                 * Parametrizes given object of values. Used to create column=value queries.
                 */
                WebsqlQueryRunner.prototype.parametrize = function (objectLiteral, startIndex) {
                    var _this = this;
                    if (startIndex === void 0) { startIndex = 0; }
                    return Object.keys(objectLiteral).map(function (key, index) { return _this.driver.escapeColumnName(key) + "=$" + (startIndex + index + 1); });
                };
                /**
                 * Builds a query for create column.
                 */
                WebsqlQueryRunner.prototype.buildCreateColumnSql = function (column) {
                    var c = "\"" + column.name + "\"";
                    if (column instanceof ColumnMetadata_5.ColumnMetadata) {
                        c += " " + this.normalizeType(column);
                    }
                    else {
                        c += " " + column.type;
                    }
                    if (column.isNullable !== true)
                        c += " NOT NULL";
                    if (column.isUnique === true)
                        c += " UNIQUE";
                    if (column.isGenerated === true)
                        c += " PRIMARY KEY AUTOINCREMENT";
                    if (column.default !== undefined && column.default !== null) {
                        if (typeof column.default === "number") {
                            c += " DEFAULT " + column.default + "";
                        }
                        else if (typeof column.default === "boolean") {
                            c += " DEFAULT " + (column.default === true ? "TRUE" : "FALSE") + "";
                        }
                        else if (typeof column.default === "function") {
                            c += " DEFAULT " + column.default() + "";
                        }
                        else if (typeof column.default === "string") {
                            c += " DEFAULT '" + column.default + "'";
                        }
                        else {
                            c += " DEFAULT " + column.default + "";
                        }
                    }
                    return c;
                };
                WebsqlQueryRunner.prototype.recreateTable = function (tableSchema, oldTableSchema) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var columnDefinitions, columnNames, sql1, primaryKeyColumns, oldColumnNames, sql2, sql3, sql4, indexPromises;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    columnDefinitions = tableSchema.columns.map(function (dbColumn) { return _this.buildCreateColumnSql(dbColumn); }).join(", ");
                                    columnNames = tableSchema.columns.map(function (column) { return "\"" + column.name + "\""; }).join(", ");
                                    sql1 = "CREATE TABLE \"temporary_" + tableSchema.name + "\" (" + columnDefinitions;
                                    // if (options && options.createForeignKeys) {
                                    tableSchema.foreignKeys.forEach(function (foreignKey) {
                                        var columnNames = foreignKey.columnNames.map(function (name) { return "\"" + name + "\""; }).join(", ");
                                        var referencedColumnNames = foreignKey.referencedColumnNames.map(function (name) { return "\"" + name + "\""; }).join(", ");
                                        sql1 += ", FOREIGN KEY(" + columnNames + ") REFERENCES \"" + foreignKey.referencedTableName + "\"(" + referencedColumnNames + ")";
                                        if (foreignKey.onDelete)
                                            sql1 += " ON DELETE " + foreignKey.onDelete;
                                    });
                                    primaryKeyColumns = tableSchema.columns.filter(function (column) { return column.isPrimary && !column.isGenerated; });
                                    if (primaryKeyColumns.length > 0)
                                        sql1 += ", PRIMARY KEY(" + primaryKeyColumns.map(function (column) { return "" + column.name; }).join(", ") + ")"; // for some reason column escaping here generate a wrong schema
                                    sql1 += ")";
                                    // todo: need also create uniques and indices?
                                    // recreate a table with a temporary name
                                    return [4 /*yield*/, this.query(sql1)];
                                case 1:
                                    // todo: need also create uniques and indices?
                                    // recreate a table with a temporary name
                                    _a.sent();
                                    oldColumnNames = oldTableSchema ? oldTableSchema.columns.map(function (column) { return "\"" + column.name + "\""; }).join(", ") : columnNames;
                                    sql2 = "INSERT INTO \"temporary_" + tableSchema.name + "\"(" + oldColumnNames + ") SELECT " + oldColumnNames + " FROM \"" + tableSchema.name + "\"";
                                    return [4 /*yield*/, this.query(sql2)];
                                case 2:
                                    _a.sent();
                                    sql3 = "DROP TABLE \"" + tableSchema.name + "\"";
                                    return [4 /*yield*/, this.query(sql3)];
                                case 3:
                                    _a.sent();
                                    sql4 = "ALTER TABLE \"temporary_" + tableSchema.name + "\" RENAME TO \"" + tableSchema.name + "\"";
                                    return [4 /*yield*/, this.query(sql4)];
                                case 4:
                                    _a.sent();
                                    indexPromises = tableSchema.indices.map(function (index) { return _this.createIndex(tableSchema.name, index); });
                                    // const uniquePromises = tableSchema.uniqueKeys.map(key => this.createIndex(key));
                                    return [4 /*yield*/, Promise.all(indexPromises /*.concat(uniquePromises)*/)];
                                case 5:
                                    // const uniquePromises = tableSchema.uniqueKeys.map(key => this.createIndex(key));
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * If given value is a table name then it loads its table schema representation from the database.
                 */
                WebsqlQueryRunner.prototype.getTableSchema = function (tableSchemaOrName) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableSchema;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!(tableSchemaOrName instanceof TableSchema_8.TableSchema)) return [3 /*break*/, 1];
                                    return [2 /*return*/, tableSchemaOrName];
                                case 1: return [4 /*yield*/, this.loadTableSchema(tableSchemaOrName)];
                                case 2:
                                    tableSchema = _a.sent();
                                    if (!tableSchema)
                                        throw new Error("Table named " + tableSchemaOrName + " was not found in the database.");
                                    return [2 /*return*/, tableSchema];
                            }
                        });
                    });
                };
                return WebsqlQueryRunner;
            }());
            exports_149("WebsqlQueryRunner", WebsqlQueryRunner);
        }
    };
});
System.register("typeorm/driver/websql/WebsqlDriver", ["typeorm/driver/error/ConnectionIsNotSetError", "typeorm/driver/DriverUtils", "typeorm/metadata/types/ColumnTypes", "typeorm/driver/error/DriverOptionNotSetError", "typeorm/util/DataTransformationUtils", "typeorm/driver/websql/WebsqlQueryRunner"], function (exports_150, context_150) {
    "use strict";
    var __moduleName = context_150 && context_150.id;
    var ConnectionIsNotSetError_6, DriverUtils_5, ColumnTypes_9, DriverOptionNotSetError_6, DataTransformationUtils_7, WebsqlQueryRunner_1, WebsqlDriver;
    return {
        setters: [
            function (ConnectionIsNotSetError_6_1) {
                ConnectionIsNotSetError_6 = ConnectionIsNotSetError_6_1;
            },
            function (DriverUtils_5_1) {
                DriverUtils_5 = DriverUtils_5_1;
            },
            function (ColumnTypes_9_1) {
                ColumnTypes_9 = ColumnTypes_9_1;
            },
            function (DriverOptionNotSetError_6_1) {
                DriverOptionNotSetError_6 = DriverOptionNotSetError_6_1;
            },
            function (DataTransformationUtils_7_1) {
                DataTransformationUtils_7 = DataTransformationUtils_7_1;
            },
            function (WebsqlQueryRunner_1_1) {
                WebsqlQueryRunner_1 = WebsqlQueryRunner_1_1;
            }
        ],
        execute: function () {
            /**
             * Organizes communication with WebSQL in the browser.
             */
            WebsqlDriver = (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function WebsqlDriver(options, logger) {
                    this.options = DriverUtils_5.DriverUtils.buildDriverOptions(options);
                    this.logger = logger;
                    // validate options to make sure everything is set
                    // if (!this.options.host)
                    //     throw new DriverOptionNotSetError("host");
                    // if (!this.options.username)
                    //     throw new DriverOptionNotSetError("username");
                    if (!this.options.database)
                        throw new DriverOptionNotSetError_6.DriverOptionNotSetError("database");
                    // todo: what about extra options: version, description, size
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Performs connection to the database.
                 * Based on pooling options, it can either create connection immediately,
                 * either create a pool and create connection when needed.
                 */
                WebsqlDriver.prototype.connect = function () {
                    var _this = this;
                    // build connection options for the driver
                    var options = Object.assign({}, {
                        database: this.options.database,
                    }, this.options.extra || {});
                    return new Promise(function (ok, fail) {
                        var connection = openDatabase(options.database, options.version, options.description, options.size);
                        _this.databaseConnection = {
                            id: 1,
                            connection: connection,
                            isTransactionActive: false
                        };
                        ok();
                    });
                };
                /**
                 * Closes connection with the database.
                 */
                WebsqlDriver.prototype.disconnect = function () {
                    if (!this.databaseConnection)
                        throw new ConnectionIsNotSetError_6.ConnectionIsNotSetError("websql");
                    return new Promise(function (ok, fail) {
                        // const handler = (err: any) => err ? fail(err) : ok();
                        // todo: find out how to close connection
                        ok();
                    });
                };
                /**
                 * Creates a query runner used for common queries.
                 */
                WebsqlDriver.prototype.createQueryRunner = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var databaseConnection;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!this.databaseConnection)
                                        return [2 /*return*/, Promise.reject(new ConnectionIsNotSetError_6.ConnectionIsNotSetError("websql"))];
                                    return [4 /*yield*/, this.retrieveDatabaseConnection()];
                                case 1:
                                    databaseConnection = _a.sent();
                                    return [2 /*return*/, new WebsqlQueryRunner_1.WebsqlQueryRunner(databaseConnection, this, this.logger)];
                            }
                        });
                    });
                };
                /**
                 * Access to the native implementation of the database.
                 */
                WebsqlDriver.prototype.nativeInterface = function () {
                    return {
                        connection: this.databaseConnection ? this.databaseConnection.connection : undefined
                    };
                };
                /**
                 * Replaces parameters in the given sql with special escaping character
                 * and an array of parameter names to be passed to a query.
                 */
                WebsqlDriver.prototype.escapeQueryWithParameters = function (sql, parameters) {
                    if (!parameters || !Object.keys(parameters).length)
                        return [sql, []];
                    var escapedParameters = [];
                    var keys = Object.keys(parameters).map(function (parameter) { return "(:" + parameter + "\\b)"; }).join("|");
                    sql = sql.replace(new RegExp(keys, "g"), function (key) {
                        escapedParameters.push(parameters[key.substr(1)]);
                        return "?";
                    }); // todo: make replace only in value statements, otherwise problems
                    return [sql, escapedParameters];
                };
                /**
                 * Escapes a column name.
                 */
                WebsqlDriver.prototype.escapeColumnName = function (columnName) {
                    return columnName; // "`" + columnName + "`";
                };
                /**
                 * Escapes an alias.
                 */
                WebsqlDriver.prototype.escapeAliasName = function (aliasName) {
                    return aliasName; // "`" + aliasName + "`";
                };
                /**
                 * Escapes a table name.
                 */
                WebsqlDriver.prototype.escapeTableName = function (tableName) {
                    return tableName; // "`" + tableName + "`";
                };
                /**
                 * Prepares given value to a value to be persisted, based on its column type and metadata.
                 */
                WebsqlDriver.prototype.preparePersistentValue = function (value, columnMetadata) {
                    if (value === null || value === undefined)
                        return null;
                    switch (columnMetadata.type) {
                        case ColumnTypes_9.ColumnTypes.BOOLEAN:
                            return value === true ? 1 : 0;
                        case ColumnTypes_9.ColumnTypes.DATE:
                            return DataTransformationUtils_7.DataTransformationUtils.mixedDateToDateString(value);
                        case ColumnTypes_9.ColumnTypes.TIME:
                            return DataTransformationUtils_7.DataTransformationUtils.mixedDateToTimeString(value);
                        case ColumnTypes_9.ColumnTypes.DATETIME:
                            if (columnMetadata.localTimezone) {
                                return DataTransformationUtils_7.DataTransformationUtils.mixedDateToDatetimeString(value);
                            }
                            else {
                                return DataTransformationUtils_7.DataTransformationUtils.mixedDateToUtcDatetimeString(value);
                            }
                        case ColumnTypes_9.ColumnTypes.JSON:
                            return JSON.stringify(value);
                        case ColumnTypes_9.ColumnTypes.SIMPLE_ARRAY:
                            return DataTransformationUtils_7.DataTransformationUtils.simpleArrayToString(value);
                    }
                    return value;
                };
                /**
                 * Prepares given value to a value to be persisted, based on its column type or metadata.
                 */
                WebsqlDriver.prototype.prepareHydratedValue = function (value, columnMetadata) {
                    switch (columnMetadata.type) {
                        case ColumnTypes_9.ColumnTypes.BOOLEAN:
                            return value ? true : false;
                        case ColumnTypes_9.ColumnTypes.DATETIME:
                            return DataTransformationUtils_7.DataTransformationUtils.normalizeHydratedDate(value, columnMetadata.localTimezone === true);
                        case ColumnTypes_9.ColumnTypes.TIME:
                            return DataTransformationUtils_7.DataTransformationUtils.mixedTimeToString(value);
                        case ColumnTypes_9.ColumnTypes.JSON:
                            return JSON.parse(value);
                        case ColumnTypes_9.ColumnTypes.SIMPLE_ARRAY:
                            return DataTransformationUtils_7.DataTransformationUtils.stringToSimpleArray(value);
                    }
                    return value;
                };
                // -------------------------------------------------------------------------
                // Protected Methods
                // -------------------------------------------------------------------------
                /**
                 * Retrieves a new database connection.
                 * If pooling is enabled then connection from the pool will be retrieved.
                 * Otherwise active connection will be returned.
                 */
                WebsqlDriver.prototype.retrieveDatabaseConnection = function () {
                    if (this.databaseConnection)
                        return Promise.resolve(this.databaseConnection);
                    throw new ConnectionIsNotSetError_6.ConnectionIsNotSetError("websql");
                };
                return WebsqlDriver;
            }());
            exports_150("WebsqlDriver", WebsqlDriver);
        }
    };
});
System.register("typeorm/connection/ConnectionManager", ["typeorm/connection/Connection", "typeorm/connection/error/ConnectionNotFoundError", "typeorm/driver/mysql/MysqlDriver", "typeorm/connection/error/MissingDriverError", "typeorm/driver/postgres/PostgresDriver", "typeorm/connection/error/AlreadyHasActiveConnectionError", "typeorm/logger/Logger", "typeorm/driver/sqlite/SqliteDriver", "typeorm/driver/oracle/OracleDriver", "typeorm/driver/sqlserver/SqlServerDriver", "typeorm/util/OrmUtils", "typeorm/connection/error/CannotDetermineConnectionOptionsError", "typeorm/platform/PlatformTools", "typeorm/driver/websql/WebsqlDriver"], function (exports_151, context_151) {
    "use strict";
    var __moduleName = context_151 && context_151.id;
    var Connection_1, ConnectionNotFoundError_1, MysqlDriver_1, MissingDriverError_1, PostgresDriver_1, AlreadyHasActiveConnectionError_1, Logger_1, SqliteDriver_1, OracleDriver_1, SqlServerDriver_2, OrmUtils_3, CannotDetermineConnectionOptionsError_1, PlatformTools_9, WebsqlDriver_1, ConnectionManager;
    return {
        setters: [
            function (Connection_1_1) {
                Connection_1 = Connection_1_1;
            },
            function (ConnectionNotFoundError_1_1) {
                ConnectionNotFoundError_1 = ConnectionNotFoundError_1_1;
            },
            function (MysqlDriver_1_1) {
                MysqlDriver_1 = MysqlDriver_1_1;
            },
            function (MissingDriverError_1_1) {
                MissingDriverError_1 = MissingDriverError_1_1;
            },
            function (PostgresDriver_1_1) {
                PostgresDriver_1 = PostgresDriver_1_1;
            },
            function (AlreadyHasActiveConnectionError_1_1) {
                AlreadyHasActiveConnectionError_1 = AlreadyHasActiveConnectionError_1_1;
            },
            function (Logger_1_1) {
                Logger_1 = Logger_1_1;
            },
            function (SqliteDriver_1_1) {
                SqliteDriver_1 = SqliteDriver_1_1;
            },
            function (OracleDriver_1_1) {
                OracleDriver_1 = OracleDriver_1_1;
            },
            function (SqlServerDriver_2_1) {
                SqlServerDriver_2 = SqlServerDriver_2_1;
            },
            function (OrmUtils_3_1) {
                OrmUtils_3 = OrmUtils_3_1;
            },
            function (CannotDetermineConnectionOptionsError_1_1) {
                CannotDetermineConnectionOptionsError_1 = CannotDetermineConnectionOptionsError_1_1;
            },
            function (PlatformTools_9_1) {
                PlatformTools_9 = PlatformTools_9_1;
            },
            function (WebsqlDriver_1_1) {
                WebsqlDriver_1 = WebsqlDriver_1_1;
            }
        ],
        execute: function () {
            /**
             * ConnectionManager is used to store and manage all these different connections.
             * It also provides useful factory methods to simplify connection creation.
             */
            ConnectionManager = (function () {
                function ConnectionManager() {
                    // -------------------------------------------------------------------------
                    // Protected Properties
                    // -------------------------------------------------------------------------
                    /**
                     * List of connections registered in this connection manager.
                     */
                    this.connections = [];
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Checks if connection with the given name exist in the manager.
                 */
                ConnectionManager.prototype.has = function (name) {
                    return !!this.connections.find(function (connection) { return connection.name === name; });
                };
                /**
                 * Gets registered connection with the given name.
                 * If connection name is not given then it will get a default connection.
                 * Throws exception if connection with the given name was not found.
                 */
                ConnectionManager.prototype.get = function (name) {
                    if (name === void 0) { name = "default"; }
                    var connection = this.connections.find(function (connection) { return connection.name === name; });
                    if (!connection)
                        throw new ConnectionNotFoundError_1.ConnectionNotFoundError(name);
                    return connection;
                };
                /**
                 * Creates a new connection based on the given connection options and registers it in the manager.
                 * You need to manually call #connect method to establish connection.
                 * Note that dropSchemaOnConnection and autoSchemaSync options of a ConnectionOptions will not work there - use
                 * createAndConnect method to use them.
                 */
                ConnectionManager.prototype.create = function (options) {
                    var logger = new Logger_1.Logger(options.logging || {});
                    var driver = this.createDriver(options.driver, logger);
                    var connection = this.createConnection(options.name || "default", driver, logger);
                    // import entity schemas
                    if (options.entitySchemas) {
                        var _a = this.splitStringsAndClasses(options.entitySchemas), directories = _a[0], classes = _a[1];
                        connection
                            .importEntitySchemas(classes)
                            .importEntitySchemaFromDirectories(directories);
                    }
                    // import entities
                    if (options.entities) {
                        var _b = this.splitStringsAndClasses(options.entities), directories = _b[0], classes = _b[1];
                        connection
                            .importEntities(classes)
                            .importEntitiesFromDirectories(directories);
                    }
                    // import subscriber
                    if (options.subscribers) {
                        var _c = this.splitStringsAndClasses(options.subscribers), directories = _c[0], classes = _c[1];
                        connection
                            .importSubscribers(classes)
                            .importSubscribersFromDirectories(directories);
                    }
                    // import naming strategies
                    if (options.namingStrategies) {
                        var _d = this.splitStringsAndClasses(options.namingStrategies), directories = _d[0], classes = _d[1];
                        connection
                            .importNamingStrategies(classes)
                            .importNamingStrategiesFromDirectories(directories);
                    }
                    // import migrations
                    if (options.migrations) {
                        var _e = this.splitStringsAndClasses(options.migrations), directories = _e[0], classes = _e[1];
                        connection
                            .importMigrations(classes)
                            .importMigrationsFromDirectories(directories);
                    }
                    // set naming strategy to be used for this connection
                    if (options.usedNamingStrategy)
                        connection.useNamingStrategy(options.usedNamingStrategy);
                    return connection;
                };
                /**
                 * Creates connection and and registers it in the manager.
                 */
                ConnectionManager.prototype.createAndConnect = function (optionsOrConnectionNameFromConfig, ormConfigPath) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            // if connection options are given, then create connection from them
                            if (optionsOrConnectionNameFromConfig && optionsOrConnectionNameFromConfig instanceof Object)
                                return [2 /*return*/, this.createAndConnectByConnectionOptions(optionsOrConnectionNameFromConfig)];
                            // if connection name is specified then explicitly try to load connection options from it
                            if (typeof optionsOrConnectionNameFromConfig === "string")
                                return [2 /*return*/, this.createFromConfigAndConnect(optionsOrConnectionNameFromConfig || "default", ormConfigPath)];
                            // if nothing is specified then try to silently load config from ormconfig.json
                            if (this.hasDefaultConfigurationInConfigurationFile())
                                return [2 /*return*/, this.createFromConfigAndConnect("default")];
                            // if driver type is set in environment variables then try to create connection from env variables
                            if (this.hasDefaultConfigurationInEnvironmentVariables())
                                return [2 /*return*/, this.createFromEnvAndConnect()];
                            throw new CannotDetermineConnectionOptionsError_1.CannotDetermineConnectionOptionsError();
                        });
                    });
                };
                /**
                 * Creates connections and and registers them in the manager.
                 */
                ConnectionManager.prototype.createAndConnectToAll = function (optionsOrOrmConfigFilePath) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var _a;
                        return __generator(this, function (_b) {
                            switch (_b.label) {
                                case 0:
                                    // if connection options are given, then create connection from them
                                    if (optionsOrOrmConfigFilePath && optionsOrOrmConfigFilePath instanceof Array)
                                        return [2 /*return*/, Promise.all(optionsOrOrmConfigFilePath.map(function (options) {
                                                return _this.createAndConnectByConnectionOptions(options);
                                            }))];
                                    // if connection name is specified then explicitly try to load connection options from it
                                    if (typeof optionsOrOrmConfigFilePath === "string")
                                        return [2 /*return*/, this.createFromConfigAndConnectToAll(optionsOrOrmConfigFilePath)];
                                    // if nothing is specified then try to silently load config from ormconfig.json
                                    if (this.hasOrmConfigurationFile())
                                        return [2 /*return*/, this.createFromConfigAndConnectToAll()];
                                    if (!this.hasDefaultConfigurationInEnvironmentVariables()) return [3 /*break*/, 2];
                                    return [4 /*yield*/, this.createFromEnvAndConnect()];
                                case 1: return [2 /*return*/, [_b.sent()]];
                                case 2: throw new CannotDetermineConnectionOptionsError_1.CannotDetermineConnectionOptionsError();
                            }
                        });
                    });
                };
                // -------------------------------------------------------------------------
                // Protected Methods
                // -------------------------------------------------------------------------
                /**
                 * Checks if ormconfig.json exists.
                 */
                ConnectionManager.prototype.hasOrmConfigurationFile = function () {
                    var path = PlatformTools_9.PlatformTools.load("app-root-path").path + "/ormconfig.json";
                    if (!PlatformTools_9.PlatformTools.fileExist(path))
                        return false;
                    var configuration = PlatformTools_9.PlatformTools.load(path);
                    if (configuration instanceof Array) {
                        return configuration
                            .filter(function (options) { return !options.environment || options.environment === PlatformTools_9.PlatformTools.getEnvVariable("NODE_ENV"); })
                            .length > 0;
                    }
                    else if (configuration instanceof Object) {
                        if (configuration.environment && configuration.environment !== PlatformTools_9.PlatformTools.getEnvVariable("NODE_ENV"))
                            return false;
                        return Object.keys(configuration).length > 0;
                    }
                    return false;
                };
                /**
                 * Checks if there is a default connection in the ormconfig.json file.
                 */
                ConnectionManager.prototype.hasDefaultConfigurationInConfigurationFile = function () {
                    var path = PlatformTools_9.PlatformTools.load("app-root-path").path + "/ormconfig.json";
                    if (!PlatformTools_9.PlatformTools.fileExist(path))
                        return false;
                    var configuration = PlatformTools_9.PlatformTools.load(path);
                    if (configuration instanceof Array) {
                        return !!configuration
                            .filter(function (options) { return !options.environment || options.environment === PlatformTools_9.PlatformTools.getEnvVariable("NODE_ENV"); })
                            .find(function (config) { return !!config.name || config.name === "default"; });
                    }
                    else if (configuration instanceof Object) {
                        if (!configuration.name ||
                            configuration.name !== "default")
                            return false;
                        if (configuration.environment && configuration.environment !== PlatformTools_9.PlatformTools.getEnvVariable("NODE_ENV"))
                            return false;
                        return true;
                    }
                    return false;
                };
                /**
                 * Checks if environment variables contains connection options.
                 */
                ConnectionManager.prototype.hasDefaultConfigurationInEnvironmentVariables = function () {
                    return !!PlatformTools_9.PlatformTools.getEnvVariable("TYPEORM_DRIVER_TYPE");
                };
                /**
                 * Allows to quickly create a connection based on the environment variable values.
                 */
                ConnectionManager.prototype.createFromEnvAndConnect = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            return [2 /*return*/, this.createAndConnectByConnectionOptions({
                                    driver: {
                                        type: PlatformTools_9.PlatformTools.getEnvVariable("TYPEORM_DRIVER_TYPE"),
                                        url: PlatformTools_9.PlatformTools.getEnvVariable("TYPEORM_URL"),
                                        host: PlatformTools_9.PlatformTools.getEnvVariable("TYPEORM_HOST"),
                                        port: PlatformTools_9.PlatformTools.getEnvVariable("TYPEORM_PORT"),
                                        username: PlatformTools_9.PlatformTools.getEnvVariable("TYPEORM_USERNAME"),
                                        password: PlatformTools_9.PlatformTools.getEnvVariable("TYPEORM_PASSWORD"),
                                        database: PlatformTools_9.PlatformTools.getEnvVariable("TYPEORM_DATABASE"),
                                        sid: PlatformTools_9.PlatformTools.getEnvVariable("TYPEORM_SID"),
                                        storage: PlatformTools_9.PlatformTools.getEnvVariable("TYPEORM_STORAGE"),
                                        usePool: PlatformTools_9.PlatformTools.getEnvVariable("TYPEORM_USE_POOL") !== undefined ? OrmUtils_3.OrmUtils.toBoolean(PlatformTools_9.PlatformTools.getEnvVariable("TYPEORM_USE_POOL")) : undefined,
                                        extra: PlatformTools_9.PlatformTools.getEnvVariable("TYPEORM_DRIVER_EXTRA") ? JSON.parse(PlatformTools_9.PlatformTools.getEnvVariable("TYPEORM_DRIVER_EXTRA")) : undefined
                                    },
                                    autoSchemaSync: OrmUtils_3.OrmUtils.toBoolean(PlatformTools_9.PlatformTools.getEnvVariable("TYPEORM_AUTO_SCHEMA_SYNC")),
                                    entities: PlatformTools_9.PlatformTools.getEnvVariable("TYPEORM_ENTITIES") ? PlatformTools_9.PlatformTools.getEnvVariable("TYPEORM_ENTITIES").split(",") : [],
                                    subscribers: PlatformTools_9.PlatformTools.getEnvVariable("TYPEORM_SUBSCRIBERS") ? PlatformTools_9.PlatformTools.getEnvVariable("TYPEORM_SUBSCRIBERS").split(",") : [],
                                    entitySchemas: PlatformTools_9.PlatformTools.getEnvVariable("TYPEORM_ENTITY_SCHEMAS") ? PlatformTools_9.PlatformTools.getEnvVariable("TYPEORM_ENTITY_SCHEMAS").split(",") : [],
                                    namingStrategies: PlatformTools_9.PlatformTools.getEnvVariable("TYPEORM_NAMING_STRATEGIES") ? PlatformTools_9.PlatformTools.getEnvVariable("TYPEORM_NAMING_STRATEGIES").split(",") : [],
                                    usedNamingStrategy: PlatformTools_9.PlatformTools.getEnvVariable("TYPEORM_USED_NAMING_STRATEGY"),
                                    logging: {
                                        logQueries: OrmUtils_3.OrmUtils.toBoolean(PlatformTools_9.PlatformTools.getEnvVariable("TYPEORM_LOGGING_QUERIES")),
                                        logFailedQueryError: OrmUtils_3.OrmUtils.toBoolean(PlatformTools_9.PlatformTools.getEnvVariable("TYPEORM_LOGGING_FAILED_QUERIES")),
                                        logOnlyFailedQueries: OrmUtils_3.OrmUtils.toBoolean(PlatformTools_9.PlatformTools.getEnvVariable("TYPEORM_LOGGING_ONLY_FAILED_QUERIES")),
                                    }
                                })];
                        });
                    });
                };
                /**
                 * Creates a new connection based on the connection options from "ormconfig.json"
                 * and registers a new connection in the manager.
                 * Optionally you can specify a path to the json configuration.
                 * If path is not given, then ormconfig.json file will be searched near node_modules directory.
                 */
                ConnectionManager.prototype.createFromConfigAndConnectToAll = function (path) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var optionsArray, promises;
                        return __generator(this, function (_a) {
                            optionsArray = PlatformTools_9.PlatformTools.load(path || (PlatformTools_9.PlatformTools.load("app-root-path").path + "/ormconfig.json"));
                            if (!optionsArray)
                                throw new Error("Configuration " + (path || "ormconfig.json") + " was not found. Add connection configuration inside ormconfig.json file.");
                            promises = optionsArray
                                .filter(function (options) { return !options.environment || options.environment === PlatformTools_9.PlatformTools.getEnvVariable("NODE_ENV"); }) // skip connection creation if environment is set in the options, and its not equal to the value in the NODE_ENV variable
                                .map(function (options) { return _this.createAndConnectByConnectionOptions(options); });
                            return [2 /*return*/, Promise.all(promises)];
                        });
                    });
                };
                /**
                 * Creates a new connection based on the connection options from "ormconfig.json"
                 * and registers a new connection in the manager.
                 * Optionally you can specify a path to the json configuration.
                 * If path is not given, then ormconfig.json file will be searched near node_modules directory.
                 */
                ConnectionManager.prototype.createFromConfigAndConnect = function (connectionName, path) {
                    return __awaiter(this, void 0, void 0, function () {
                        var optionsArray, environmentLessOptions, options;
                        return __generator(this, function (_a) {
                            optionsArray = PlatformTools_9.PlatformTools.load(path || (PlatformTools_9.PlatformTools.load("app-root-path").path + "/ormconfig.json"));
                            if (!optionsArray)
                                throw new Error("Configuration " + (path || "ormconfig.json") + " was not found. Add connection configuration inside ormconfig.json file.");
                            environmentLessOptions = optionsArray.filter(function (options) { return (options.name || "default") === connectionName; });
                            options = environmentLessOptions.filter(function (options) { return !options.environment || options.environment === PlatformTools_9.PlatformTools.getEnvVariable("NODE_ENV"); });
                            if (!options.length)
                                throw new Error("Connection \"" + connectionName + "\" " + (PlatformTools_9.PlatformTools.getEnvVariable("NODE_ENV") ? "for the environment " + PlatformTools_9.PlatformTools.getEnvVariable("NODE_ENV") + " " : "") + "was not found in the json configuration file." +
                                    (environmentLessOptions.length ? " However there are such configurations for other environments: " + environmentLessOptions.map(function (options) { return options.environment; }).join(", ") + "." : ""));
                            return [2 /*return*/, this.createAndConnectByConnectionOptions(options[0])];
                        });
                    });
                };
                /**
                 * Creates a new connection based on the given connection options and registers a new connection in the manager.
                 */
                ConnectionManager.prototype.createAndConnectByConnectionOptions = function (options) {
                    return __awaiter(this, void 0, void 0, function () {
                        var connection;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    connection = this.create(options);
                                    // connect to the database
                                    return [4 /*yield*/, connection.connect()];
                                case 1:
                                    // connect to the database
                                    _a.sent();
                                    if (!(options.dropSchemaOnConnection && !PlatformTools_9.PlatformTools.getEnvVariable("SKIP_SCHEMA_CREATION"))) return [3 /*break*/, 3];
                                    return [4 /*yield*/, connection.dropDatabase()];
                                case 2:
                                    _a.sent();
                                    _a.label = 3;
                                case 3:
                                    if (!(options.autoSchemaSync && !PlatformTools_9.PlatformTools.getEnvVariable("SKIP_SCHEMA_CREATION"))) return [3 /*break*/, 5];
                                    return [4 /*yield*/, connection.syncSchema()];
                                case 4:
                                    _a.sent();
                                    _a.label = 5;
                                case 5:
                                    if (!(options.autoMigrationsRun && !PlatformTools_9.PlatformTools.getEnvVariable("SKIP_MIGRATIONS_RUN"))) return [3 /*break*/, 7];
                                    return [4 /*yield*/, connection.runMigrations()];
                                case 6:
                                    _a.sent();
                                    _a.label = 7;
                                case 7: return [2 /*return*/, connection];
                            }
                        });
                    });
                };
                /**
                 * Splits given array of mixed strings and / or functions into two separate array of string and array of functions.
                 */
                ConnectionManager.prototype.splitStringsAndClasses = function (strAndClses) {
                    return [
                        strAndClses.filter(function (str) { return typeof str === "string"; }),
                        strAndClses.filter(function (cls) { return typeof cls !== "string"; }),
                    ];
                };
                /**
                 * Creates a new driver based on the given driver type and options.
                 */
                ConnectionManager.prototype.createDriver = function (options, logger) {
                    switch (options.type) {
                        case "mysql":
                            return new MysqlDriver_1.MysqlDriver(options, logger, undefined);
                        case "postgres":
                            return new PostgresDriver_1.PostgresDriver(options, logger);
                        case "mariadb":
                            return new MysqlDriver_1.MysqlDriver(options, logger);
                        case "sqlite":
                            return new SqliteDriver_1.SqliteDriver(options, logger);
                        case "oracle":
                            return new OracleDriver_1.OracleDriver(options, logger);
                        case "mssql":
                            return new SqlServerDriver_2.SqlServerDriver(options, logger);
                        case "websql":
                            return new WebsqlDriver_1.WebsqlDriver(options, logger);
                        default:
                            throw new MissingDriverError_1.MissingDriverError(options.type);
                    }
                };
                /**
                 * Creates a new connection and registers it in the connection manager.
                 */
                ConnectionManager.prototype.createConnection = function (name, driver, logger) {
                    var existConnection = this.connections.find(function (connection) { return connection.name === name; });
                    if (existConnection) {
                        if (existConnection.isConnected)
                            throw new AlreadyHasActiveConnectionError_1.AlreadyHasActiveConnectionError(name);
                        this.connections.splice(this.connections.indexOf(existConnection), 1);
                    }
                    var connection = new Connection_1.Connection(name, driver, logger);
                    this.connections.push(connection);
                    return connection;
                };
                return ConnectionManager;
            }());
            exports_151("ConnectionManager", ConnectionManager);
        }
    };
});
System.register("typeorm/container", [], function (exports_152, context_152) {
    "use strict";
    var __moduleName = context_152 && context_152.id;
    /**
     * Sets container to be used by this library.
     */
    function useContainer(iocContainer, options) {
        userContainer = iocContainer;
        userContainerOptions = options;
    }
    exports_152("useContainer", useContainer);
    /**
     * Gets the IOC container used by this library.
     */
    function getFromContainer(someClass) {
        if (userContainer) {
            try {
                var instance = userContainer.get(someClass);
                if (instance)
                    return instance;
                if (!userContainerOptions || !userContainerOptions.fallback)
                    return instance;
            }
            catch (error) {
                if (!userContainerOptions || !userContainerOptions.fallbackOnErrors)
                    throw error;
            }
        }
        return defaultContainer.get(someClass);
    }
    exports_152("getFromContainer", getFromContainer);
    var defaultContainer, userContainer, userContainerOptions;
    return {
        setters: [],
        execute: function () {
            /**
             * Container to be used by this library for inversion control. If container was not implicitly set then by default
             * container simply creates a new instance of the given class.
             */
            exports_152("defaultContainer", defaultContainer = new ((function () {
                function class_1() {
                    this.instances = [];
                }
                class_1.prototype.get = function (someClass) {
                    var instance = this.instances.find(function (instance) { return instance.type === someClass; });
                    if (!instance) {
                        instance = { type: someClass, object: new someClass() };
                        this.instances.push(instance);
                    }
                    return instance.object;
                };
                return class_1;
            }()))());
        }
    };
});
System.register("typeorm/decorator/error/ColumnTypeUndefinedError", [], function (exports_153, context_153) {
    "use strict";
    var __moduleName = context_153 && context_153.id;
    var ColumnTypeUndefinedError;
    return {
        setters: [],
        execute: function () {
            ColumnTypeUndefinedError = (function (_super) {
                __extends(ColumnTypeUndefinedError, _super);
                function ColumnTypeUndefinedError(object, propertyName) {
                    var _this = _super.call(this) || this;
                    _this.name = "ColumnTypeUndefinedError";
                    _this.message = "Column type for " + object.constructor.name + "#" + propertyName + " is not defined or cannot be guessed. " +
                        "Try to implicitly provide a column type to @Column decorator.";
                    return _this;
                }
                return ColumnTypeUndefinedError;
            }(Error));
            exports_153("ColumnTypeUndefinedError", ColumnTypeUndefinedError);
        }
    };
});
System.register("typeorm/decorator/error/GeneratedOnlyForPrimaryError", [], function (exports_154, context_154) {
    "use strict";
    var __moduleName = context_154 && context_154.id;
    var GeneratedOnlyForPrimaryError;
    return {
        setters: [],
        execute: function () {
            GeneratedOnlyForPrimaryError = (function (_super) {
                __extends(GeneratedOnlyForPrimaryError, _super);
                function GeneratedOnlyForPrimaryError(object, propertyName) {
                    var _this = _super.call(this) || this;
                    _this.name = "GeneratedOnlyForPrimaryError";
                    _this.message = "Column for property " + object.constructor.name + "#" + propertyName + " cannot have a generated " +
                        "value because its not a primary column. Try to use @PrimaryColumn decorator.";
                    return _this;
                }
                return GeneratedOnlyForPrimaryError;
            }(Error));
            exports_154("GeneratedOnlyForPrimaryError", GeneratedOnlyForPrimaryError);
        }
    };
});
System.register("typeorm/decorator/columns/Column", ["typeorm/decorator/error/ColumnTypeUndefinedError", "typeorm/decorator/error/GeneratedOnlyForPrimaryError", "typeorm/index", "typeorm/metadata/types/ColumnTypes"], function (exports_155, context_155) {
    "use strict";
    var __moduleName = context_155 && context_155.id;
    /**
     * Column decorator is used to mark a specific class property as a table column.
     * Only properties decorated with this decorator will be persisted to the database when entity be saved.
     */
    function Column(typeOrOptions, options) {
        var type;
        if (typeof typeOrOptions === "string") {
            type = typeOrOptions;
        }
        else if (typeOrOptions) {
            options = typeOrOptions;
            type = typeOrOptions.type;
        }
        return function (object, propertyName) {
            // todo: need to store not string type, but original type instead? (like in relation metadata)
            // const reflectedType = ColumnTypes.typeToString((Reflect as any).getMetadata("design:type", object, propertyName));
            // if type is not given implicitly then try to guess it
            if (!type) {
                var reflectMetadataType = Reflect && Reflect.getMetadata ? Reflect.getMetadata("design:type", object, propertyName) : undefined;
                if (reflectMetadataType)
                    type = ColumnTypes_10.ColumnTypes.determineTypeFromFunction(reflectMetadataType);
            }
            // if column options are not given then create a new empty options
            if (!options)
                options = {};
            // check if there is no type in column options then set type from first function argument, or guessed one
            if (!options.type && type)
                options = Object.assign({ type: type }, options);
            // if we still don't have a type then we need to give error to user that type is required
            if (!options.type)
                throw new ColumnTypeUndefinedError_1.ColumnTypeUndefinedError(object, propertyName);
            // check if auto increment is not set for simple column
            if (options.generated)
                throw new GeneratedOnlyForPrimaryError_1.GeneratedOnlyForPrimaryError(object, propertyName);
            // create and register a new column metadata
            var args = {
                target: object.constructor,
                propertyName: propertyName,
                // propertyType: reflectedType,
                mode: "regular",
                options: options
            };
            index_4.getMetadataArgsStorage().columns.add(args);
        };
    }
    exports_155("Column", Column);
    var ColumnTypeUndefinedError_1, GeneratedOnlyForPrimaryError_1, index_4, ColumnTypes_10;
    return {
        setters: [
            function (ColumnTypeUndefinedError_1_1) {
                ColumnTypeUndefinedError_1 = ColumnTypeUndefinedError_1_1;
            },
            function (GeneratedOnlyForPrimaryError_1_1) {
                GeneratedOnlyForPrimaryError_1 = GeneratedOnlyForPrimaryError_1_1;
            },
            function (index_4_1) {
                index_4 = index_4_1;
            },
            function (ColumnTypes_10_1) {
                ColumnTypes_10 = ColumnTypes_10_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/columns/CreateDateColumn", ["typeorm/metadata/types/ColumnTypes", "typeorm/index"], function (exports_156, context_156) {
    "use strict";
    var __moduleName = context_156 && context_156.id;
    /**
     * This column will store a creation date of the inserted object.
     * Creation date is generated and inserted only once,
     * at the first time when you create an object, the value is inserted into the table, and is never touched again.
     */
    function CreateDateColumn(options) {
        return function (object, propertyName) {
            // const reflectedType = ColumnTypes.typeToString((Reflect as any).getMetadata("design:type", object, propertyName));
            // if column options are not given then create a new empty options
            if (!options)
                options = {};
            // implicitly set a type, because this column's type cannot be anything else except date
            options = Object.assign({ type: ColumnTypes_11.ColumnTypes.DATETIME }, options);
            // create and register a new column metadata
            var args = {
                target: object.constructor,
                propertyName: propertyName,
                // propertyType: reflectedType,
                mode: "createDate",
                options: options
            };
            index_5.getMetadataArgsStorage().columns.add(args);
        };
    }
    exports_156("CreateDateColumn", CreateDateColumn);
    var ColumnTypes_11, index_5;
    return {
        setters: [
            function (ColumnTypes_11_1) {
                ColumnTypes_11 = ColumnTypes_11_1;
            },
            function (index_5_1) {
                index_5 = index_5_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/columns/DiscriminatorColumn", ["typeorm/index"], function (exports_157, context_157) {
    "use strict";
    var __moduleName = context_157 && context_157.id;
    /**
     * DiscriminatorColumn is a special type column used on entity class (not entity property)
     * and creates a special column which will contain an entity type.
     * This type is required for entities which use single table inheritance pattern.
     */
    function DiscriminatorColumn(discriminatorOptions) {
        return function (target) {
            // if column options are not given then create a new empty options
            var options = {
                name: discriminatorOptions.name,
                type: discriminatorOptions.type
            };
            // create and register a new column metadata
            var args = {
                target: target,
                mode: "discriminator",
                propertyName: discriminatorOptions.name,
                options: options
            };
            index_6.getMetadataArgsStorage().columns.add(args);
        };
    }
    exports_157("DiscriminatorColumn", DiscriminatorColumn);
    var index_6;
    return {
        setters: [
            function (index_6_1) {
                index_6 = index_6_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/error/PrimaryColumnCannotBeNullableError", [], function (exports_158, context_158) {
    "use strict";
    var __moduleName = context_158 && context_158.id;
    var PrimaryColumnCannotBeNullableError;
    return {
        setters: [],
        execute: function () {
            PrimaryColumnCannotBeNullableError = (function (_super) {
                __extends(PrimaryColumnCannotBeNullableError, _super);
                function PrimaryColumnCannotBeNullableError(object, propertyName) {
                    var _this = _super.call(this) || this;
                    _this.name = "PrimaryColumnCannotBeNullableError";
                    _this.message = "Primary column " + object.constructor.name + "#" + propertyName + " cannot be nullable. " +
                        "Its not allowed for primary keys. Try to remove nullable option.";
                    return _this;
                }
                return PrimaryColumnCannotBeNullableError;
            }(Error));
            exports_158("PrimaryColumnCannotBeNullableError", PrimaryColumnCannotBeNullableError);
        }
    };
});
System.register("typeorm/decorator/columns/PrimaryGeneratedColumn", ["typeorm/index", "typeorm/decorator/error/PrimaryColumnCannotBeNullableError"], function (exports_159, context_159) {
    "use strict";
    var __moduleName = context_159 && context_159.id;
    /**
     * Column decorator is used to mark a specific class property as a table column.
     * Only properties decorated with this decorator will be persisted to the database when entity be saved.
     * This column creates an integer PRIMARY COLUMN with generated set to true.
     * This column creates is an alias for @PrimaryColumn("int", { generated: true }).
     */
    function PrimaryGeneratedColumn(options) {
        return function (object, propertyName) {
            // const reflectedType = ColumnTypes.typeToString((Reflect as any).getMetadata("design:type", object, propertyName));
            // if column options are not given then create a new empty options
            if (!options)
                options = {};
            // check if there is no type in column options then set the int type - by default for auto generated column
            if (!options.type)
                options = Object.assign({ type: "int" }, options);
            // check if column is not nullable, because we cannot allow a primary key to be nullable
            if (options.nullable)
                throw new PrimaryColumnCannotBeNullableError_1.PrimaryColumnCannotBeNullableError(object, propertyName);
            // implicitly set a primary and generated to column options
            options = Object.assign({ primary: true, generated: true }, options);
            // create and register a new column metadata
            var args = {
                target: object.constructor,
                propertyName: propertyName,
                // propertyType: reflectedType,
                mode: "regular",
                options: options
            };
            index_7.getMetadataArgsStorage().columns.add(args);
        };
    }
    exports_159("PrimaryGeneratedColumn", PrimaryGeneratedColumn);
    var index_7, PrimaryColumnCannotBeNullableError_1;
    return {
        setters: [
            function (index_7_1) {
                index_7 = index_7_1;
            },
            function (PrimaryColumnCannotBeNullableError_1_1) {
                PrimaryColumnCannotBeNullableError_1 = PrimaryColumnCannotBeNullableError_1_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/columns/PrimaryColumn", ["typeorm/metadata/types/ColumnTypes", "typeorm/decorator/error/ColumnTypeUndefinedError", "typeorm/index", "typeorm/decorator/error/PrimaryColumnCannotBeNullableError"], function (exports_160, context_160) {
    "use strict";
    var __moduleName = context_160 && context_160.id;
    /**
     * Column decorator is used to mark a specific class property as a table column.
     * Only properties decorated with this decorator will be persisted to the database when entity be saved.
     * Primary columns also creates a PRIMARY KEY for this column in a db.
     */
    function PrimaryColumn(typeOrOptions, options) {
        var type;
        if (typeof typeOrOptions === "string") {
            type = typeOrOptions;
        }
        else {
            options = typeOrOptions;
        }
        return function (object, propertyName) {
            // const reflectedType = ColumnTypes.typeToString((Reflect as any).getMetadata("design:type", object, propertyName));
            // if type is not given implicitly then try to guess it
            if (!type) {
                var reflectMetadataType = Reflect && Reflect.getMetadata ? Reflect.getMetadata("design:type", object, propertyName) : undefined;
                if (reflectMetadataType)
                    type = ColumnTypes_12.ColumnTypes.determineTypeFromFunction(reflectMetadataType);
            }
            // if column options are not given then create a new empty options
            if (!options)
                options = {};
            // check if there is no type in column options then set type from first function argument, or guessed one
            if (!options.type && type)
                options = Object.assign({ type: type }, options);
            // if we still don't have a type then we need to give error to user that type is required
            if (!options.type)
                throw new ColumnTypeUndefinedError_2.ColumnTypeUndefinedError(object, propertyName);
            // check if column is not nullable, because we cannot allow a primary key to be nullable
            if (options.nullable)
                throw new PrimaryColumnCannotBeNullableError_2.PrimaryColumnCannotBeNullableError(object, propertyName);
            // implicitly set a primary to column options
            options = Object.assign({ primary: true }, options);
            // create and register a new column metadata
            var args = {
                target: object.constructor,
                propertyName: propertyName,
                // propertyType: reflectedType,
                mode: "regular",
                options: options
            };
            index_8.getMetadataArgsStorage().columns.add(args);
        };
    }
    exports_160("PrimaryColumn", PrimaryColumn);
    var ColumnTypes_12, ColumnTypeUndefinedError_2, index_8, PrimaryColumnCannotBeNullableError_2;
    return {
        setters: [
            function (ColumnTypes_12_1) {
                ColumnTypes_12 = ColumnTypes_12_1;
            },
            function (ColumnTypeUndefinedError_2_1) {
                ColumnTypeUndefinedError_2 = ColumnTypeUndefinedError_2_1;
            },
            function (index_8_1) {
                index_8 = index_8_1;
            },
            function (PrimaryColumnCannotBeNullableError_2_1) {
                PrimaryColumnCannotBeNullableError_2 = PrimaryColumnCannotBeNullableError_2_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/columns/UpdateDateColumn", ["typeorm/metadata/types/ColumnTypes", "typeorm/index"], function (exports_161, context_161) {
    "use strict";
    var __moduleName = context_161 && context_161.id;
    /**
     * This column will store an update date of the updated object.
     * This date is being updated each time you persist the object.
     */
    function UpdateDateColumn(options) {
        return function (object, propertyName) {
            // const reflectedType = ColumnTypes.typeToString((Reflect as any).getMetadata("design:type", object, propertyName));
            // if column options are not given then create a new empty options
            if (!options)
                options = {};
            // implicitly set a type, because this column's type cannot be anything else except date
            options = Object.assign({ type: ColumnTypes_13.ColumnTypes.DATETIME }, options);
            // create and register a new column metadata
            var args = {
                target: object.constructor,
                propertyName: propertyName,
                // propertyType: reflectedType,
                mode: "updateDate",
                options: options
            };
            index_9.getMetadataArgsStorage().columns.add(args);
        };
    }
    exports_161("UpdateDateColumn", UpdateDateColumn);
    var ColumnTypes_13, index_9;
    return {
        setters: [
            function (ColumnTypes_13_1) {
                ColumnTypes_13 = ColumnTypes_13_1;
            },
            function (index_9_1) {
                index_9 = index_9_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/columns/VersionColumn", ["typeorm/metadata/types/ColumnTypes", "typeorm/index"], function (exports_162, context_162) {
    "use strict";
    var __moduleName = context_162 && context_162.id;
    /**
     * This column will store a number - version of the entity.
     * Every time your entity will be persisted, this number will be increased by one -
     * so you can organize visioning and update strategies of your entity.
     */
    function VersionColumn(options) {
        return function (object, propertyName) {
            // const reflectedType = ColumnTypes.typeToString((Reflect as any).getMetadata("design:type", object, propertyName));
            // if column options are not given then create a new empty options
            if (!options)
                options = {};
            // implicitly set a type, because this column's type cannot be anything else except date
            options = Object.assign({ type: ColumnTypes_14.ColumnTypes.INTEGER }, options);
            // todo: check if reflectedType is number too
            // create and register a new column metadata
            var args = {
                target: object.constructor,
                propertyName: propertyName,
                // propertyType: reflectedType,
                mode: "version",
                options: options
            };
            index_10.getMetadataArgsStorage().columns.add(args);
        };
    }
    exports_162("VersionColumn", VersionColumn);
    var ColumnTypes_14, index_10;
    return {
        setters: [
            function (ColumnTypes_14_1) {
                ColumnTypes_14 = ColumnTypes_14_1;
            },
            function (index_10_1) {
                index_10 = index_10_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/listeners/AfterInsert", ["typeorm/index", "typeorm/metadata/types/EventListenerTypes"], function (exports_163, context_163) {
    "use strict";
    var __moduleName = context_163 && context_163.id;
    /**
     * Calls a method on which this decorator is applied after this entity insertion.
     */
    function AfterInsert() {
        return function (object, propertyName) {
            var args = {
                target: object.constructor,
                propertyName: propertyName,
                type: EventListenerTypes_2.EventListenerTypes.AFTER_INSERT
            };
            index_11.getMetadataArgsStorage().entityListeners.add(args);
        };
    }
    exports_163("AfterInsert", AfterInsert);
    var index_11, EventListenerTypes_2;
    return {
        setters: [
            function (index_11_1) {
                index_11 = index_11_1;
            },
            function (EventListenerTypes_2_1) {
                EventListenerTypes_2 = EventListenerTypes_2_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/listeners/AfterLoad", ["typeorm/index", "typeorm/metadata/types/EventListenerTypes"], function (exports_164, context_164) {
    "use strict";
    var __moduleName = context_164 && context_164.id;
    /**
     * Calls a method on which this decorator is applied after entity is loaded.
     */
    function AfterLoad() {
        return function (object, propertyName) {
            var args = {
                target: object.constructor,
                propertyName: propertyName,
                type: EventListenerTypes_3.EventListenerTypes.AFTER_LOAD
            };
            index_12.getMetadataArgsStorage().entityListeners.add(args);
        };
    }
    exports_164("AfterLoad", AfterLoad);
    var index_12, EventListenerTypes_3;
    return {
        setters: [
            function (index_12_1) {
                index_12 = index_12_1;
            },
            function (EventListenerTypes_3_1) {
                EventListenerTypes_3 = EventListenerTypes_3_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/listeners/AfterRemove", ["typeorm/index", "typeorm/metadata/types/EventListenerTypes"], function (exports_165, context_165) {
    "use strict";
    var __moduleName = context_165 && context_165.id;
    /**
     * Calls a method on which this decorator is applied after this entity removal.
     */
    function AfterRemove() {
        return function (object, propertyName) {
            var args = {
                target: object.constructor,
                propertyName: propertyName,
                type: EventListenerTypes_4.EventListenerTypes.AFTER_REMOVE
            };
            index_13.getMetadataArgsStorage().entityListeners.add(args);
        };
    }
    exports_165("AfterRemove", AfterRemove);
    var index_13, EventListenerTypes_4;
    return {
        setters: [
            function (index_13_1) {
                index_13 = index_13_1;
            },
            function (EventListenerTypes_4_1) {
                EventListenerTypes_4 = EventListenerTypes_4_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/listeners/AfterUpdate", ["typeorm/index", "typeorm/metadata/types/EventListenerTypes"], function (exports_166, context_166) {
    "use strict";
    var __moduleName = context_166 && context_166.id;
    /**
     * Calls a method on which this decorator is applied after this entity update.
     */
    function AfterUpdate() {
        return function (object, propertyName) {
            var args = {
                target: object.constructor,
                propertyName: propertyName,
                type: EventListenerTypes_5.EventListenerTypes.AFTER_UPDATE
            };
            index_14.getMetadataArgsStorage().entityListeners.add(args);
        };
    }
    exports_166("AfterUpdate", AfterUpdate);
    var index_14, EventListenerTypes_5;
    return {
        setters: [
            function (index_14_1) {
                index_14 = index_14_1;
            },
            function (EventListenerTypes_5_1) {
                EventListenerTypes_5 = EventListenerTypes_5_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/listeners/BeforeInsert", ["typeorm/index", "typeorm/metadata/types/EventListenerTypes"], function (exports_167, context_167) {
    "use strict";
    var __moduleName = context_167 && context_167.id;
    /**
     * Calls a method on which this decorator is applied before this entity insertion.
     */
    function BeforeInsert() {
        return function (object, propertyName) {
            var args = {
                target: object.constructor,
                propertyName: propertyName,
                type: EventListenerTypes_6.EventListenerTypes.BEFORE_INSERT
            };
            index_15.getMetadataArgsStorage().entityListeners.add(args);
        };
    }
    exports_167("BeforeInsert", BeforeInsert);
    var index_15, EventListenerTypes_6;
    return {
        setters: [
            function (index_15_1) {
                index_15 = index_15_1;
            },
            function (EventListenerTypes_6_1) {
                EventListenerTypes_6 = EventListenerTypes_6_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/listeners/BeforeRemove", ["typeorm/index", "typeorm/metadata/types/EventListenerTypes"], function (exports_168, context_168) {
    "use strict";
    var __moduleName = context_168 && context_168.id;
    /**
     * Calls a method on which this decorator is applied before this entity removal.
     */
    function BeforeRemove() {
        return function (object, propertyName) {
            var args = {
                target: object.constructor,
                propertyName: propertyName,
                type: EventListenerTypes_7.EventListenerTypes.BEFORE_REMOVE
            };
            index_16.getMetadataArgsStorage().entityListeners.add(args);
        };
    }
    exports_168("BeforeRemove", BeforeRemove);
    var index_16, EventListenerTypes_7;
    return {
        setters: [
            function (index_16_1) {
                index_16 = index_16_1;
            },
            function (EventListenerTypes_7_1) {
                EventListenerTypes_7 = EventListenerTypes_7_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/listeners/BeforeUpdate", ["typeorm/index", "typeorm/metadata/types/EventListenerTypes"], function (exports_169, context_169) {
    "use strict";
    var __moduleName = context_169 && context_169.id;
    /**
     * Calls a method on which this decorator is applied before this entity update.
     */
    function BeforeUpdate() {
        return function (object, propertyName) {
            var args = {
                target: object.constructor,
                propertyName: propertyName,
                type: EventListenerTypes_8.EventListenerTypes.BEFORE_UPDATE
            };
            index_17.getMetadataArgsStorage().entityListeners.add(args);
        };
    }
    exports_169("BeforeUpdate", BeforeUpdate);
    var index_17, EventListenerTypes_8;
    return {
        setters: [
            function (index_17_1) {
                index_17 = index_17_1;
            },
            function (EventListenerTypes_8_1) {
                EventListenerTypes_8 = EventListenerTypes_8_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/listeners/EventSubscriber", ["typeorm/index"], function (exports_170, context_170) {
    "use strict";
    var __moduleName = context_170 && context_170.id;
    /**
     * Classes decorated with this decorator will listen to ORM events and their methods will be triggered when event
     * occurs. Those classes must implement EventSubscriberInterface interface.
     */
    function EventSubscriber() {
        return function (target) {
            var args = {
                target: target
            };
            index_18.getMetadataArgsStorage().entitySubscribers.add(args);
        };
    }
    exports_170("EventSubscriber", EventSubscriber);
    var index_18;
    return {
        setters: [
            function (index_18_1) {
                index_18 = index_18_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/options/IndexOptions", [], function (exports_171, context_171) {
    "use strict";
    var __moduleName = context_171 && context_171.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/options/JoinTableOptions", [], function (exports_172, context_172) {
    "use strict";
    var __moduleName = context_172 && context_172.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/options/EntityOptions", [], function (exports_173, context_173) {
    "use strict";
    var __moduleName = context_173 && context_173.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/relations/RelationCount", ["typeorm/index"], function (exports_174, context_174) {
    "use strict";
    var __moduleName = context_174 && context_174.id;
    /**
     * Holds a number of children in the closure table of the column.
     */
    function RelationCount(relation) {
        return function (object, propertyName) {
            // todo: need to check if property type is number?
            // const reflectedType = ColumnTypes.typeToString((Reflect as any).getMetadata("design:type", object, propertyName));
            // create and register a new column metadata
            var args = {
                target: object.constructor,
                propertyName: propertyName,
                relation: relation
            };
            index_19.getMetadataArgsStorage().relationCounts.add(args);
        };
    }
    exports_174("RelationCount", RelationCount);
    var index_19;
    return {
        setters: [
            function (index_19_1) {
                index_19 = index_19_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/relations/JoinColumn", ["typeorm/index"], function (exports_175, context_175) {
    "use strict";
    var __moduleName = context_175 && context_175.id;
    /**
     * JoinColumn decorator used on one-to-one relations to specify owner side of relationship.
     * It also can be used on both one-to-one and many-to-one relations to specify custom column name
     * or custom referenced column.
     */
    function JoinColumn(options) {
        return function (object, propertyName) {
            options = options || {};
            var args = {
                target: object.constructor,
                propertyName: propertyName,
                name: options.name,
                referencedColumnName: options.referencedColumnName
            };
            index_20.getMetadataArgsStorage().joinColumns.add(args);
        };
    }
    exports_175("JoinColumn", JoinColumn);
    var index_20;
    return {
        setters: [
            function (index_20_1) {
                index_20 = index_20_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/relations/JoinTable", ["typeorm/index"], function (exports_176, context_176) {
    "use strict";
    var __moduleName = context_176 && context_176.id;
    /**
     * JoinTable decorator is used in many-to-many relationship to specify owner side of relationship.
     * Its also used to set a custom junction table's name, column names and referenced columns.
     */
    function JoinTable(options) {
        return function (object, propertyName) {
            options = options || {};
            var args = {
                target: object.constructor,
                propertyName: propertyName,
                name: options.name,
                joinColumn: options.joinColumn,
                inverseJoinColumn: options.inverseJoinColumn
            };
            index_21.getMetadataArgsStorage().joinTables.add(args);
        };
    }
    exports_176("JoinTable", JoinTable);
    var index_21;
    return {
        setters: [
            function (index_21_1) {
                index_21 = index_21_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/relations/ManyToMany", ["typeorm/metadata/types/RelationTypes", "typeorm/index"], function (exports_177, context_177) {
    "use strict";
    var __moduleName = context_177 && context_177.id;
    /**
     * Many-to-many is a type of relationship when Entity1 can have multiple instances of Entity2, and Entity2 can have
     * multiple instances of Entity1. To achieve it, this type of relation creates a junction table, where it storage
     * entity1 and entity2 ids. This is owner side of the relationship.
     */
    function ManyToMany(typeFunction, inverseSideOrOptions, options) {
        var inverseSideProperty;
        if (typeof inverseSideOrOptions === "object") {
            options = inverseSideOrOptions;
        }
        else {
            inverseSideProperty = inverseSideOrOptions;
        }
        return function (object, propertyName) {
            if (!options)
                options = {};
            // now try to determine it its lazy relation
            var isLazy = options && options.lazy === true ? true : false;
            if (!isLazy && Reflect && Reflect.getMetadata) {
                var reflectedType = Reflect.getMetadata("design:type", object, propertyName);
                if (reflectedType && typeof reflectedType.name === "string" && reflectedType.name.toLowerCase() === "promise")
                    isLazy = true;
            }
            var args = {
                target: object.constructor,
                propertyName: propertyName,
                // propertyType: reflectedType,
                relationType: RelationTypes_3.RelationTypes.MANY_TO_MANY,
                isLazy: isLazy,
                type: typeFunction,
                inverseSideProperty: inverseSideProperty,
                options: options
            };
            index_22.getMetadataArgsStorage().relations.add(args);
        };
    }
    exports_177("ManyToMany", ManyToMany);
    var RelationTypes_3, index_22;
    return {
        setters: [
            function (RelationTypes_3_1) {
                RelationTypes_3 = RelationTypes_3_1;
            },
            function (index_22_1) {
                index_22 = index_22_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/relations/ManyToOne", ["typeorm/metadata/types/RelationTypes", "typeorm/index"], function (exports_178, context_178) {
    "use strict";
    var __moduleName = context_178 && context_178.id;
    /**
     * Many-to-one relation allows to create type of relation when Entity1 can have single instance of Entity2, but
     * Entity2 can have a multiple instances of Entity1. Entity1 is an owner of the relationship, and storages Entity2 id
     * on its own side.
     */
    function ManyToOne(typeFunction, inverseSideOrOptions, options) {
        var inverseSideProperty;
        if (typeof inverseSideOrOptions === "object") {
            options = inverseSideOrOptions;
        }
        else {
            inverseSideProperty = inverseSideOrOptions;
        }
        return function (object, propertyName) {
            if (!options)
                options = {};
            // now try to determine it its lazy relation
            var isLazy = options && options.lazy === true ? true : false;
            if (!isLazy && Reflect && Reflect.getMetadata) {
                var reflectedType = Reflect.getMetadata("design:type", object, propertyName);
                if (reflectedType && typeof reflectedType.name === "string" && reflectedType.name.toLowerCase() === "promise")
                    isLazy = true;
            }
            var args = {
                target: object.constructor,
                propertyName: propertyName,
                // propertyType: reflectedType,
                relationType: RelationTypes_4.RelationTypes.MANY_TO_ONE,
                isLazy: isLazy,
                type: typeFunction,
                inverseSideProperty: inverseSideProperty,
                options: options
            };
            index_23.getMetadataArgsStorage().relations.add(args);
        };
    }
    exports_178("ManyToOne", ManyToOne);
    var RelationTypes_4, index_23;
    return {
        setters: [
            function (RelationTypes_4_1) {
                RelationTypes_4 = RelationTypes_4_1;
            },
            function (index_23_1) {
                index_23 = index_23_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/relations/OneToMany", ["typeorm/metadata/types/RelationTypes", "typeorm/index"], function (exports_179, context_179) {
    "use strict";
    var __moduleName = context_179 && context_179.id;
    // todo: make decorators which use inverse side string separate
    /**
     * One-to-many relation allows to create type of relation when Entity2 can have multiple instances of Entity1.
     * Entity1 have only one Entity2. Entity1 is an owner of the relationship, and storages Entity2 id on its own side.
     */
    function OneToMany(typeFunction, inverseSide, options) {
        return function (object, propertyName) {
            if (!options)
                options = {};
            // now try to determine it its lazy relation
            var isLazy = options && options.lazy === true ? true : false;
            if (!isLazy && Reflect && Reflect.getMetadata) {
                var reflectedType = Reflect.getMetadata("design:type", object, propertyName);
                if (reflectedType && typeof reflectedType.name === "string" && reflectedType.name.toLowerCase() === "promise")
                    isLazy = true;
            }
            var args = {
                target: object.constructor,
                propertyName: propertyName,
                // propertyType: reflectedType,
                isLazy: isLazy,
                relationType: RelationTypes_5.RelationTypes.ONE_TO_MANY,
                type: typeFunction,
                inverseSideProperty: inverseSide,
                options: options
            };
            index_24.getMetadataArgsStorage().relations.add(args);
        };
    }
    exports_179("OneToMany", OneToMany);
    var RelationTypes_5, index_24;
    return {
        setters: [
            function (RelationTypes_5_1) {
                RelationTypes_5 = RelationTypes_5_1;
            },
            function (index_24_1) {
                index_24 = index_24_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/relations/OneToOne", ["typeorm/metadata/types/RelationTypes", "typeorm/index"], function (exports_180, context_180) {
    "use strict";
    var __moduleName = context_180 && context_180.id;
    /**
     * One-to-one relation allows to create direct relation between two entities. Entity1 have only one Entity2.
     * Entity1 is an owner of the relationship, and storages Entity1 id on its own side.
     */
    function OneToOne(typeFunction, inverseSideOrOptions, options) {
        var inverseSideProperty;
        if (typeof inverseSideOrOptions === "object") {
            options = inverseSideOrOptions;
        }
        else {
            inverseSideProperty = inverseSideOrOptions;
        }
        return function (object, propertyName) {
            if (!options)
                options = {};
            // now try to determine it its lazy relation
            var isLazy = options && options.lazy === true ? true : false;
            if (!isLazy && Reflect && Reflect.getMetadata) {
                var reflectedType = Reflect.getMetadata("design:type", object, propertyName);
                if (reflectedType && typeof reflectedType.name === "string" && reflectedType.name.toLowerCase() === "promise")
                    isLazy = true;
            }
            var args = {
                target: object.constructor,
                propertyName: propertyName,
                // propertyType: reflectedType,
                isLazy: isLazy,
                relationType: RelationTypes_6.RelationTypes.ONE_TO_ONE,
                type: typeFunction,
                inverseSideProperty: inverseSideProperty,
                options: options
            };
            index_25.getMetadataArgsStorage().relations.add(args);
        };
    }
    exports_180("OneToOne", OneToOne);
    var RelationTypes_6, index_25;
    return {
        setters: [
            function (RelationTypes_6_1) {
                RelationTypes_6 = RelationTypes_6_1;
            },
            function (index_25_1) {
                index_25 = index_25_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/relations/RelationId", ["typeorm/index"], function (exports_181, context_181) {
    "use strict";
    var __moduleName = context_181 && context_181.id;
    /**
     * Special decorator used to extract relation id into separate entity property.
     */
    function RelationId(relation) {
        return function (object, propertyName) {
            var args = {
                target: object.constructor,
                propertyName: propertyName,
                relation: relation
            };
            index_26.getMetadataArgsStorage().relationIds.add(args);
        };
    }
    exports_181("RelationId", RelationId);
    var index_26;
    return {
        setters: [
            function (index_26_1) {
                index_26 = index_26_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/entity/Entity", ["typeorm/index"], function (exports_182, context_182) {
    "use strict";
    var __moduleName = context_182 && context_182.id;
    /**
     * This decorator is used to mark classes that will be an entity (table or document depend on database type).
     * Database schema will be created for all classes decorated with it, and Repository can be retrieved and used for it.
     */
    function Entity(name, options) {
        return function (target) {
            var args = {
                target: target,
                name: name,
                type: "regular",
                orderBy: options && options.orderBy ? options.orderBy : undefined,
                engine: options && options.engine ? options.engine : undefined,
                skipSchemaSync: !!(options && options.skipSchemaSync === true)
            };
            index_27.getMetadataArgsStorage().tables.add(args);
        };
    }
    exports_182("Entity", Entity);
    var index_27;
    return {
        setters: [
            function (index_27_1) {
                index_27 = index_27_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/entity/AbstractEntity", ["typeorm/index"], function (exports_183, context_183) {
    "use strict";
    var __moduleName = context_183 && context_183.id;
    /**
     * Abstract entity is a class that contains columns and relations for all entities that will inherit this entity.
     * Database table for the abstract entity is not created.
     */
    function AbstractEntity() {
        return function (target) {
            var args = {
                target: target,
                name: undefined,
                type: "abstract"
            };
            index_28.getMetadataArgsStorage().tables.add(args);
        };
    }
    exports_183("AbstractEntity", AbstractEntity);
    var index_28;
    return {
        setters: [
            function (index_28_1) {
                index_28 = index_28_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/entity/ClassEntityChild", ["typeorm/index"], function (exports_184, context_184) {
    "use strict";
    var __moduleName = context_184 && context_184.id;
    /**
     * Special type of the entity used in the class-table inherited tables.
     */
    function ClassEntityChild(tableName, options) {
        return function (target) {
            var args = {
                target: target,
                name: tableName,
                type: "class-table-child",
                orderBy: options && options.orderBy ? options.orderBy : undefined,
                skipSchemaSync: !!(options && options.skipSchemaSync === true)
            };
            index_29.getMetadataArgsStorage().tables.add(args);
        };
    }
    exports_184("ClassEntityChild", ClassEntityChild);
    var index_29;
    return {
        setters: [
            function (index_29_1) {
                index_29 = index_29_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/entity/ClosureEntity", ["typeorm/index"], function (exports_185, context_185) {
    "use strict";
    var __moduleName = context_185 && context_185.id;
    /**
     * Used on a entities that stores its children in a tree using closure design pattern.
     */
    function ClosureEntity(name, options) {
        return function (target) {
            var args = {
                target: target,
                name: name,
                type: "closure",
                orderBy: options && options.orderBy ? options.orderBy : undefined,
                skipSchemaSync: !!(options && options.skipSchemaSync === true)
            };
            index_30.getMetadataArgsStorage().tables.add(args);
        };
    }
    exports_185("ClosureEntity", ClosureEntity);
    var index_30;
    return {
        setters: [
            function (index_30_1) {
                index_30 = index_30_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/entity/EmbeddableEntity", ["typeorm/index"], function (exports_186, context_186) {
    "use strict";
    var __moduleName = context_186 && context_186.id;
    /**
     * This decorator is used on the entities that must be embedded into another entities.
     */
    function EmbeddableEntity() {
        return function (target) {
            var args = {
                target: target,
                type: "embeddable",
                orderBy: undefined
            };
            index_31.getMetadataArgsStorage().tables.add(args);
        };
    }
    exports_186("EmbeddableEntity", EmbeddableEntity);
    var index_31;
    return {
        setters: [
            function (index_31_1) {
                index_31 = index_31_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/entity/SingleEntityChild", ["typeorm/index"], function (exports_187, context_187) {
    "use strict";
    var __moduleName = context_187 && context_187.id;
    /**
     * Special type of the table used in the single-table inherited tables.
     */
    function SingleEntityChild() {
        return function (target) {
            var args = {
                target: target,
                name: undefined,
                type: "single-table-child",
                orderBy: undefined
            };
            index_32.getMetadataArgsStorage().tables.add(args);
        };
    }
    exports_187("SingleEntityChild", SingleEntityChild);
    var index_32;
    return {
        setters: [
            function (index_32_1) {
                index_32 = index_32_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/entity/TableInheritance", ["typeorm/index"], function (exports_188, context_188) {
    "use strict";
    var __moduleName = context_188 && context_188.id;
    /**
     * Sets what kind of table-inheritance table will use.
     */
    function TableInheritance(type) {
        return function (target) {
            var args = {
                target: target,
                type: type
            };
            index_33.getMetadataArgsStorage().inheritances.add(args);
        };
    }
    exports_188("TableInheritance", TableInheritance);
    var index_33;
    return {
        setters: [
            function (index_33_1) {
                index_33 = index_33_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/transaction/Transaction", ["typeorm/index"], function (exports_189, context_189) {
    "use strict";
    var __moduleName = context_189 && context_189.id;
    /**
     * Wraps some method into the transaction.
     * Note, method result will return a promise if this decorator applied.
     * Note, all database operations in the wrapped method should be executed using entity managed passed as a first parameter
     * into the wrapped method.
     * If you want to control at what position in your method parameters entity manager should be injected,
     * then use @TransactionEntityManager() decorator.
     */
    function Transaction(connectionName) {
        if (connectionName === void 0) { connectionName = "default"; }
        return function (target, methodName, descriptor) {
            // save original method - we gonna need it
            var originalMethod = descriptor.value;
            // override method descriptor with proxy method
            descriptor.value = function () {
                var _this = this;
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return index_34.getConnection(connectionName)
                    .entityManager
                    .transaction(function (entityManager) {
                    // gets all @TransactionEntityManager() decorator usages for this method
                    var indices = index_34.getMetadataArgsStorage()
                        .transactionEntityManagers
                        .filterByTarget(target.constructor)
                        .toArray()
                        .filter(function (transactionEntityManager) { return transactionEntityManager.methodName === methodName; })
                        .map(function (transactionEntityManager) { return transactionEntityManager.index; });
                    var argsWithInjectedEntityManager;
                    if (indices.length) {
                        argsWithInjectedEntityManager = args.slice();
                        indices.forEach(function (index) { return argsWithInjectedEntityManager.splice(index, 0, entityManager); });
                    }
                    else {
                        argsWithInjectedEntityManager = [entityManager].concat(args);
                    }
                    return originalMethod.apply(_this, argsWithInjectedEntityManager);
                });
            };
        };
    }
    exports_189("Transaction", Transaction);
    var index_34;
    return {
        setters: [
            function (index_34_1) {
                index_34 = index_34_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/transaction/TransactionEntityManager", ["typeorm/index"], function (exports_190, context_190) {
    "use strict";
    var __moduleName = context_190 && context_190.id;
    /**
     * Injects transaction's entity manager into the method wrapped with @Transaction decorator.
     */
    function TransactionEntityManager() {
        return function (object, methodName, index) {
            var args = {
                target: object.constructor,
                methodName: methodName,
                index: index,
            };
            index_35.getMetadataArgsStorage().transactionEntityManagers.add(args);
        };
    }
    exports_190("TransactionEntityManager", TransactionEntityManager);
    var index_35;
    return {
        setters: [
            function (index_35_1) {
                index_35 = index_35_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/tree/TreeLevelColumn", ["typeorm/index", "typeorm/metadata/types/ColumnTypes"], function (exports_191, context_191) {
    "use strict";
    var __moduleName = context_191 && context_191.id;
    /**
     * Creates a "level"/"length" column to the table that holds a closure table.
     */
    function TreeLevelColumn() {
        return function (object, propertyName) {
            // const reflectedType = ColumnTypes.typeToString((Reflect as any).getMetadata("design:type", object, propertyName));
            // implicitly set a type, because this column's type cannot be anything else except number
            var options = { type: ColumnTypes_15.ColumnTypes.INTEGER };
            // create and register a new column metadata
            var args = {
                target: object.constructor,
                propertyName: propertyName,
                // propertyType: reflectedType,
                mode: "treeLevel",
                options: options
            };
            index_36.getMetadataArgsStorage().columns.add(args);
        };
    }
    exports_191("TreeLevelColumn", TreeLevelColumn);
    var index_36, ColumnTypes_15;
    return {
        setters: [
            function (index_36_1) {
                index_36 = index_36_1;
            },
            function (ColumnTypes_15_1) {
                ColumnTypes_15 = ColumnTypes_15_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/tree/TreeParent", ["typeorm/index", "typeorm/metadata/types/RelationTypes"], function (exports_192, context_192) {
    "use strict";
    var __moduleName = context_192 && context_192.id;
    /**
     * Marks a specific property of the class as a parent of the tree.
     */
    function TreeParent(options) {
        return function (object, propertyName) {
            if (!options)
                options = {};
            // now try to determine it its lazy relation
            var isLazy = options && options.lazy === true ? true : false;
            if (!isLazy && Reflect && Reflect.getMetadata) {
                var reflectedType = Reflect.getMetadata("design:type", object, propertyName);
                if (reflectedType && typeof reflectedType.name === "string" && reflectedType.name.toLowerCase() === "promise")
                    isLazy = true;
            }
            var args = {
                isTreeParent: true,
                target: object.constructor,
                propertyName: propertyName,
                // propertyType: reflectedType,
                isLazy: isLazy,
                relationType: RelationTypes_7.RelationTypes.MANY_TO_ONE,
                type: function () { return object.constructor; },
                options: options
            };
            index_37.getMetadataArgsStorage().relations.add(args);
        };
    }
    exports_192("TreeParent", TreeParent);
    var index_37, RelationTypes_7;
    return {
        setters: [
            function (index_37_1) {
                index_37 = index_37_1;
            },
            function (RelationTypes_7_1) {
                RelationTypes_7 = RelationTypes_7_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/tree/TreeChildren", ["typeorm/index", "typeorm/metadata/types/RelationTypes"], function (exports_193, context_193) {
    "use strict";
    var __moduleName = context_193 && context_193.id;
    /**
     * Marks a specific property of the class as a children of the tree.
     */
    function TreeChildren(options) {
        return function (object, propertyName) {
            if (!options)
                options = {};
            // now try to determine it its lazy relation
            var isLazy = options && options.lazy === true ? true : false;
            if (!isLazy && Reflect && Reflect.getMetadata) {
                var reflectedType = Reflect.getMetadata("design:type", object, propertyName);
                if (reflectedType && typeof reflectedType.name === "string" && reflectedType.name.toLowerCase() === "promise")
                    isLazy = true;
            }
            // add one-to-many relation for this 
            var args = {
                isTreeChildren: true,
                target: object.constructor,
                propertyName: propertyName,
                // propertyType: reflectedType,
                isLazy: isLazy,
                relationType: RelationTypes_8.RelationTypes.ONE_TO_MANY,
                type: function () { return object.constructor; },
                options: options
            };
            index_38.getMetadataArgsStorage().relations.add(args);
        };
    }
    exports_193("TreeChildren", TreeChildren);
    var index_38, RelationTypes_8;
    return {
        setters: [
            function (index_38_1) {
                index_38 = index_38_1;
            },
            function (RelationTypes_8_1) {
                RelationTypes_8 = RelationTypes_8_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/Index", ["typeorm/index"], function (exports_194, context_194) {
    "use strict";
    var __moduleName = context_194 && context_194.id;
    /**
     * Composite index must be set on entity classes and must specify entity's fields to be indexed.
     */
    function Index(nameOrFieldsOrOptions, maybeFieldsOrOptions, maybeOptions) {
        var name = typeof nameOrFieldsOrOptions === "string" ? nameOrFieldsOrOptions : undefined;
        var fields = typeof nameOrFieldsOrOptions === "string" ? maybeFieldsOrOptions : nameOrFieldsOrOptions;
        var options = (typeof nameOrFieldsOrOptions === "object" && !Array.isArray(nameOrFieldsOrOptions)) ? nameOrFieldsOrOptions : maybeOptions;
        if (!options)
            options = (typeof maybeFieldsOrOptions === "object" && !Array.isArray(maybeFieldsOrOptions)) ? nameOrFieldsOrOptions : maybeOptions;
        return function (clsOrObject, propertyName) {
            var args = {
                target: propertyName ? clsOrObject.constructor : clsOrObject,
                name: name,
                columns: propertyName ? [propertyName] : fields,
                unique: options && options.unique ? true : false
            };
            index_39.getMetadataArgsStorage().indices.add(args);
        };
    }
    exports_194("Index", Index);
    var index_39;
    return {
        setters: [
            function (index_39_1) {
                index_39 = index_39_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/NamingStrategy", ["typeorm/index"], function (exports_195, context_195) {
    "use strict";
    var __moduleName = context_195 && context_195.id;
    /**
     * Decorator registers a new naming strategy to be used in naming things.
     */
    function NamingStrategy(name) {
        return function (target) {
            var strategyName = name ? name : target.name;
            var args = {
                target: target,
                name: strategyName
            };
            index_40.getMetadataArgsStorage().namingStrategies.add(args);
        };
    }
    exports_195("NamingStrategy", NamingStrategy);
    var index_40;
    return {
        setters: [
            function (index_40_1) {
                index_40 = index_40_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/Embedded", ["typeorm/index"], function (exports_196, context_196) {
    "use strict";
    var __moduleName = context_196 && context_196.id;
    /**
     * Property in entity can be marked as Embedded, and on persist all columns from the embedded are mapped to the
     * single table of the entity where Embedded is used. And on hydration all columns which supposed to be in the
     * embedded will be mapped to it from the single table.
     */
    function Embedded(typeFunction) {
        return function (object, propertyName) {
            // const reflectedType = (Reflect as any).getMetadata("design:type", object, propertyName);
            var args = {
                target: object.constructor,
                propertyName: propertyName,
                // propertyType: reflectedType,
                type: typeFunction
            };
            index_41.getMetadataArgsStorage().embeddeds.add(args);
        };
    }
    exports_196("Embedded", Embedded);
    var index_41;
    return {
        setters: [
            function (index_41_1) {
                index_41 = index_41_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/DiscriminatorValue", ["typeorm/index"], function (exports_197, context_197) {
    "use strict";
    var __moduleName = context_197 && context_197.id;
    /**
     * If entity is a child table of some table, it should have a discriminator value.
     * This decorator sets custom discriminator value for the entity.
     */
    function DiscriminatorValue(value) {
        return function (target) {
            var args = {
                target: target,
                value: value
            };
            index_42.getMetadataArgsStorage().discriminatorValues.add(args);
        };
    }
    exports_197("DiscriminatorValue", DiscriminatorValue);
    var index_42;
    return {
        setters: [
            function (index_42_1) {
                index_42 = index_42_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/EntityRepository", ["typeorm/index"], function (exports_198, context_198) {
    "use strict";
    var __moduleName = context_198 && context_198.id;
    /**
     * Used to declare a class as a custom repository.
     * Custom repository can either manage some specific entity, either just be generic.
     * Custom repository can extend AbstractRepository or regular Repository or TreeRepository.
     */
    function EntityRepository(entityOrOptions, maybeOptions) {
        var entity = entityOrOptions instanceof Function ? entityOrOptions : undefined;
        var options = entityOrOptions instanceof Function ? maybeOptions : entityOrOptions;
        return function (target) {
            var args = {
                target: target,
                entity: entity,
                useContainer: !!(options && options.useContainer)
            };
            index_43.getMetadataArgsStorage().entityRepositories.add(args);
        };
    }
    exports_198("EntityRepository", EntityRepository);
    var index_43;
    return {
        setters: [
            function (index_43_1) {
                index_43 = index_43_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/tables/Table", ["typeorm/index"], function (exports_199, context_199) {
    "use strict";
    var __moduleName = context_199 && context_199.id;
    /**
     * This decorator is used to mark classes that will be a tables. Database schema will be created for all classes
     * decorated with it, and Repository can be retrieved and used for it.
     *
     * @deprecated Use @Entity decorator instead.
     */
    function Table(name, options) {
        return function (target) {
            var args = {
                target: target,
                name: name,
                type: "regular",
                orderBy: options && options.orderBy ? options.orderBy : undefined,
                engine: options && options.engine ? options.engine : undefined,
                skipSchemaSync: !!(options && options.skipSchemaSync === true)
            };
            index_44.getMetadataArgsStorage().tables.add(args);
        };
    }
    exports_199("Table", Table);
    var index_44;
    return {
        setters: [
            function (index_44_1) {
                index_44 = index_44_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/tables/AbstractTable", ["typeorm/index"], function (exports_200, context_200) {
    "use strict";
    var __moduleName = context_200 && context_200.id;
    /**
     * Abstract table is a table that contains columns and relations for all tables that will inherit this table.
     * Database table for the abstract table is not created.
     *
     * @deprecated Use @AbstractEntity decorator instead.
     */
    function AbstractTable() {
        return function (target) {
            var args = {
                target: target,
                name: undefined,
                type: "abstract"
            };
            index_45.getMetadataArgsStorage().tables.add(args);
        };
    }
    exports_200("AbstractTable", AbstractTable);
    var index_45;
    return {
        setters: [
            function (index_45_1) {
                index_45 = index_45_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/tables/ClassTableChild", ["typeorm/index"], function (exports_201, context_201) {
    "use strict";
    var __moduleName = context_201 && context_201.id;
    /**
     * Special type of the table used in the class-table inherited tables.
     *
     * @deprecated Use @ClassEntityChild decorator instead.
     */
    function ClassTableChild(tableName, options) {
        return function (target) {
            var args = {
                target: target,
                name: tableName,
                type: "class-table-child",
                orderBy: options && options.orderBy ? options.orderBy : undefined,
                skipSchemaSync: !!(options && options.skipSchemaSync === true)
            };
            index_46.getMetadataArgsStorage().tables.add(args);
        };
    }
    exports_201("ClassTableChild", ClassTableChild);
    var index_46;
    return {
        setters: [
            function (index_46_1) {
                index_46 = index_46_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/tables/ClosureTable", ["typeorm/index"], function (exports_202, context_202) {
    "use strict";
    var __moduleName = context_202 && context_202.id;
    /**
     * Used on a tables that stores its children in a tree using closure deisgn pattern.
     *
     * @deprecated Use @ClosureEntity decorator instead.
     */
    function ClosureTable(name, options) {
        return function (target) {
            var args = {
                target: target,
                name: name,
                type: "closure",
                orderBy: options && options.orderBy ? options.orderBy : undefined,
                skipSchemaSync: !!(options && options.skipSchemaSync === true)
            };
            index_47.getMetadataArgsStorage().tables.add(args);
        };
    }
    exports_202("ClosureTable", ClosureTable);
    var index_47;
    return {
        setters: [
            function (index_47_1) {
                index_47 = index_47_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/tables/EmbeddableTable", ["typeorm/index"], function (exports_203, context_203) {
    "use strict";
    var __moduleName = context_203 && context_203.id;
    /**
     * This decorators is used on the entities that must be embedded into the tables.
     *
     * @deprecated Use @EmbeddableEntity decorator instead.
     */
    function EmbeddableTable() {
        return function (target) {
            var args = {
                target: target,
                type: "embeddable",
                orderBy: undefined
            };
            index_48.getMetadataArgsStorage().tables.add(args);
        };
    }
    exports_203("EmbeddableTable", EmbeddableTable);
    var index_48;
    return {
        setters: [
            function (index_48_1) {
                index_48 = index_48_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/tables/SingleTableChild", ["typeorm/index"], function (exports_204, context_204) {
    "use strict";
    var __moduleName = context_204 && context_204.id;
    /**
     * Special type of the table used in the single-table inherited tables.
     *
     * @deprecated Use @SingleEntityChild decorator instead.
     */
    function SingleTableChild() {
        return function (target) {
            var args = {
                target: target,
                name: undefined,
                type: "single-table-child",
                orderBy: undefined
            };
            index_49.getMetadataArgsStorage().tables.add(args);
        };
    }
    exports_204("SingleTableChild", SingleTableChild);
    var index_49;
    return {
        setters: [
            function (index_49_1) {
                index_49 = index_49_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/index", ["typeorm/connection/ConnectionManager", "typeorm/metadata-args/MetadataArgsStorage", "typeorm/container", "typeorm/platform/PlatformTools", "typeorm/decorator/columns/Column", "typeorm/decorator/columns/CreateDateColumn", "typeorm/decorator/columns/DiscriminatorColumn", "typeorm/decorator/columns/PrimaryGeneratedColumn", "typeorm/decorator/columns/PrimaryColumn", "typeorm/decorator/columns/UpdateDateColumn", "typeorm/decorator/columns/VersionColumn", "typeorm/decorator/listeners/AfterInsert", "typeorm/decorator/listeners/AfterLoad", "typeorm/decorator/listeners/AfterRemove", "typeorm/decorator/listeners/AfterUpdate", "typeorm/decorator/listeners/BeforeInsert", "typeorm/decorator/listeners/BeforeRemove", "typeorm/decorator/listeners/BeforeUpdate", "typeorm/decorator/listeners/EventSubscriber", "typeorm/decorator/relations/RelationCount", "typeorm/decorator/relations/JoinColumn", "typeorm/decorator/relations/JoinTable", "typeorm/decorator/relations/ManyToMany", "typeorm/decorator/relations/ManyToOne", "typeorm/decorator/relations/OneToMany", "typeorm/decorator/relations/OneToOne", "typeorm/decorator/relations/RelationId", "typeorm/decorator/entity/Entity", "typeorm/decorator/entity/AbstractEntity", "typeorm/decorator/entity/ClassEntityChild", "typeorm/decorator/entity/ClosureEntity", "typeorm/decorator/entity/EmbeddableEntity", "typeorm/decorator/entity/SingleEntityChild", "typeorm/decorator/entity/TableInheritance", "typeorm/decorator/transaction/Transaction", "typeorm/decorator/transaction/TransactionEntityManager", "typeorm/decorator/tree/TreeLevelColumn", "typeorm/decorator/tree/TreeParent", "typeorm/decorator/tree/TreeChildren", "typeorm/decorator/Index", "typeorm/decorator/NamingStrategy", "typeorm/decorator/Embedded", "typeorm/decorator/DiscriminatorValue", "typeorm/decorator/EntityRepository", "typeorm/schema-builder/schema/ColumnSchema", "typeorm/schema-builder/schema/ForeignKeySchema", "typeorm/schema-builder/schema/IndexSchema", "typeorm/schema-builder/schema/PrimaryKeySchema", "typeorm/schema-builder/schema/TableSchema", "typeorm/connection/Connection", "typeorm/query-builder/QueryBuilder", "typeorm/entity-manager/EntityManager", "typeorm/naming-strategy/DefaultNamingStrategy", "typeorm/repository/Repository", "typeorm/repository/TreeRepository", "typeorm/repository/SpecificRepository", "typeorm/decorator/tables/Table", "typeorm/decorator/tables/AbstractTable", "typeorm/decorator/tables/ClassTableChild", "typeorm/decorator/tables/ClosureTable", "typeorm/decorator/tables/EmbeddableTable", "typeorm/decorator/tables/SingleTableChild"], function (exports_205, context_205) {
    "use strict";
    var __moduleName = context_205 && context_205.id;
    // -------------------------------------------------------------------------
    // Commonly used functionality
    // -------------------------------------------------------------------------
    /**
     * Gets metadata args storage.
     */
    function getMetadataArgsStorage() {
        // we should store metadata storage in a global variable otherwise it brings too much problems
        // one of the problem is that if any entity (or any other) will be imported before consumer will call
        // useContainer method with his own container implementation, that entity will be registered in the
        // old old container (default one post probably) and consumer will his entity.
        // calling useContainer before he imports any entity (or any other) is not always convenient.
        // another reason is that when we run migrations typeorm is being called from a global package
        // and it may load entities which register decorators in typeorm of local package
        // this leads to impossibility of usage of entities in migrations and cli related operations
        var globalScope = PlatformTools_10.PlatformTools.getGlobalVariable();
        if (!globalScope.typeormMetadataArgsStorage)
            globalScope.typeormMetadataArgsStorage = new MetadataArgsStorage_2.MetadataArgsStorage();
        return globalScope.typeormMetadataArgsStorage;
    }
    exports_205("getMetadataArgsStorage", getMetadataArgsStorage);
    /**
     * Gets a ConnectionManager which creates connections.
     */
    function getConnectionManager() {
        return container_1.getFromContainer(ConnectionManager_1.ConnectionManager);
    }
    exports_205("getConnectionManager", getConnectionManager);
    /**
     * Creates connection and and registers it in the manager.
     */
    function createConnection(optionsOrConnectionNameFromConfig, ormConfigPath) {
        return getConnectionManager().createAndConnect(optionsOrConnectionNameFromConfig, ormConfigPath);
    }
    exports_205("createConnection", createConnection);
    /**
     * Creates connections and and registers them in the manager.
     */
    function createConnections(optionsOrOrmConfigFilePath) {
        return getConnectionManager().createAndConnectToAll(optionsOrOrmConfigFilePath);
    }
    exports_205("createConnections", createConnections);
    /**
     * Gets connection from the connection manager.
     * If connection name wasn't specified, then "default" connection will be retrieved.
     */
    function getConnection(connectionName) {
        if (connectionName === void 0) { connectionName = "default"; }
        return getConnectionManager().get(connectionName);
    }
    exports_205("getConnection", getConnection);
    /**
     * Gets entity manager from the connection.
     * If connection name wasn't specified, then "default" connection will be retrieved.
     */
    function getEntityManager(connectionName) {
        if (connectionName === void 0) { connectionName = "default"; }
        return getConnectionManager().get(connectionName).entityManager;
    }
    exports_205("getEntityManager", getEntityManager);
    /**
     * Gets repository for the given entity class or name.
     */
    function getRepository(entityClassOrName, connectionName) {
        if (connectionName === void 0) { connectionName = "default"; }
        return getConnectionManager().get(connectionName).getRepository(entityClassOrName);
    }
    exports_205("getRepository", getRepository);
    var ConnectionManager_1, MetadataArgsStorage_2, container_1, PlatformTools_10;
    var exportedNames_1 = {
        "getMetadataArgsStorage": true,
        "getConnectionManager": true,
        "createConnection": true,
        "createConnections": true,
        "getConnection": true,
        "getEntityManager": true,
        "getRepository": true,
        "Connection": true,
        "ConnectionManager": true,
        "QueryBuilder": true,
        "EntityManager": true,
        "DefaultNamingStrategy": true,
        "Repository": true,
        "TreeRepository": true,
        "SpecificRepository": true
    };
    function exportStar_1(m) {
        var exports = {};
        for (var n in m) {
            if (n !== "default" && !exportedNames_1.hasOwnProperty(n)) exports[n] = m[n];
        }
        exports_205(exports);
    }
    return {
        setters: [
            function (ConnectionManager_1_1) {
                ConnectionManager_1 = ConnectionManager_1_1;
                exports_205({
                    "ConnectionManager": ConnectionManager_1_1["ConnectionManager"]
                });
            },
            function (MetadataArgsStorage_2_1) {
                MetadataArgsStorage_2 = MetadataArgsStorage_2_1;
            },
            function (container_1_1) {
                container_1 = container_1_1;
                exportStar_1(container_1_1);
            },
            function (PlatformTools_10_1) {
                PlatformTools_10 = PlatformTools_10_1;
            },
            function (Column_1_1) {
                exportStar_1(Column_1_1);
            },
            function (CreateDateColumn_1_1) {
                exportStar_1(CreateDateColumn_1_1);
            },
            function (DiscriminatorColumn_1_1) {
                exportStar_1(DiscriminatorColumn_1_1);
            },
            function (PrimaryGeneratedColumn_1_1) {
                exportStar_1(PrimaryGeneratedColumn_1_1);
            },
            function (PrimaryColumn_1_1) {
                exportStar_1(PrimaryColumn_1_1);
            },
            function (UpdateDateColumn_1_1) {
                exportStar_1(UpdateDateColumn_1_1);
            },
            function (VersionColumn_1_1) {
                exportStar_1(VersionColumn_1_1);
            },
            function (AfterInsert_1_1) {
                exportStar_1(AfterInsert_1_1);
            },
            function (AfterLoad_1_1) {
                exportStar_1(AfterLoad_1_1);
            },
            function (AfterRemove_1_1) {
                exportStar_1(AfterRemove_1_1);
            },
            function (AfterUpdate_1_1) {
                exportStar_1(AfterUpdate_1_1);
            },
            function (BeforeInsert_1_1) {
                exportStar_1(BeforeInsert_1_1);
            },
            function (BeforeRemove_1_1) {
                exportStar_1(BeforeRemove_1_1);
            },
            function (BeforeUpdate_1_1) {
                exportStar_1(BeforeUpdate_1_1);
            },
            function (EventSubscriber_1_1) {
                exportStar_1(EventSubscriber_1_1);
            },
            function (RelationCount_1_1) {
                exportStar_1(RelationCount_1_1);
                exportStar_1(RelationCount_1_1);
            },
            function (JoinColumn_1_1) {
                exportStar_1(JoinColumn_1_1);
            },
            function (JoinTable_1_1) {
                exportStar_1(JoinTable_1_1);
            },
            function (ManyToMany_1_1) {
                exportStar_1(ManyToMany_1_1);
            },
            function (ManyToOne_1_1) {
                exportStar_1(ManyToOne_1_1);
            },
            function (OneToMany_1_1) {
                exportStar_1(OneToMany_1_1);
            },
            function (OneToOne_1_1) {
                exportStar_1(OneToOne_1_1);
            },
            function (RelationId_1_1) {
                exportStar_1(RelationId_1_1);
            },
            function (Entity_1_1) {
                exportStar_1(Entity_1_1);
                exportStar_1(Entity_1_1);
            },
            function (AbstractEntity_1_1) {
                exportStar_1(AbstractEntity_1_1);
            },
            function (ClassEntityChild_1_1) {
                exportStar_1(ClassEntityChild_1_1);
            },
            function (ClosureEntity_1_1) {
                exportStar_1(ClosureEntity_1_1);
            },
            function (EmbeddableEntity_1_1) {
                exportStar_1(EmbeddableEntity_1_1);
            },
            function (SingleEntityChild_1_1) {
                exportStar_1(SingleEntityChild_1_1);
            },
            function (TableInheritance_1_1) {
                exportStar_1(TableInheritance_1_1);
            },
            function (Transaction_1_1) {
                exportStar_1(Transaction_1_1);
            },
            function (TransactionEntityManager_1_1) {
                exportStar_1(TransactionEntityManager_1_1);
            },
            function (TreeLevelColumn_1_1) {
                exportStar_1(TreeLevelColumn_1_1);
            },
            function (TreeParent_1_1) {
                exportStar_1(TreeParent_1_1);
            },
            function (TreeChildren_1_1) {
                exportStar_1(TreeChildren_1_1);
            },
            function (Index_1_1) {
                exportStar_1(Index_1_1);
            },
            function (NamingStrategy_1_1) {
                exportStar_1(NamingStrategy_1_1);
            },
            function (Embedded_1_1) {
                exportStar_1(Embedded_1_1);
            },
            function (DiscriminatorValue_1_1) {
                exportStar_1(DiscriminatorValue_1_1);
            },
            function (EntityRepository_1_1) {
                exportStar_1(EntityRepository_1_1);
            },
            function (ColumnSchema_10_1) {
                exportStar_1(ColumnSchema_10_1);
            },
            function (ForeignKeySchema_7_1) {
                exportStar_1(ForeignKeySchema_7_1);
            },
            function (IndexSchema_6_1) {
                exportStar_1(IndexSchema_6_1);
            },
            function (PrimaryKeySchema_7_1) {
                exportStar_1(PrimaryKeySchema_7_1);
            },
            function (TableSchema_9_1) {
                exportStar_1(TableSchema_9_1);
            },
            function (Connection_2_1) {
                exports_205({
                    "Connection": Connection_2_1["Connection"]
                });
            },
            function (QueryBuilder_5_1) {
                exports_205({
                    "QueryBuilder": QueryBuilder_5_1["QueryBuilder"]
                });
            },
            function (EntityManager_2_1) {
                exports_205({
                    "EntityManager": EntityManager_2_1["EntityManager"]
                });
            },
            function (DefaultNamingStrategy_2_1) {
                exports_205({
                    "DefaultNamingStrategy": DefaultNamingStrategy_2_1["DefaultNamingStrategy"]
                });
            },
            function (Repository_4_1) {
                exports_205({
                    "Repository": Repository_4_1["Repository"]
                });
            },
            function (TreeRepository_2_1) {
                exports_205({
                    "TreeRepository": TreeRepository_2_1["TreeRepository"]
                });
            },
            function (SpecificRepository_3_1) {
                exports_205({
                    "SpecificRepository": SpecificRepository_3_1["SpecificRepository"]
                });
            },
            function (Table_1_1) {
                exportStar_1(Table_1_1);
                exportStar_1(Table_1_1);
            },
            function (AbstractTable_1_1) {
                exportStar_1(AbstractTable_1_1);
            },
            function (ClassTableChild_1_1) {
                exportStar_1(ClassTableChild_1_1);
            },
            function (ClosureTable_1_1) {
                exportStar_1(ClosureTable_1_1);
            },
            function (EmbeddableTable_1_1) {
                exportStar_1(EmbeddableTable_1_1);
            },
            function (SingleTableChild_1_1) {
                exportStar_1(SingleTableChild_1_1);
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm", ["typeorm/index"], function (exports_206, context_206) {
    "use strict";
    var __moduleName = context_206 && context_206.id;
    function exportStar_2(m) {
        var exports = {};
        for (var n in m) {
            if (n !== "default") exports[n] = m[n];
        }
        exports_206(exports);
    }
    return {
        setters: [
            function (index_50_1) {
                exportStar_2(index_50_1);
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/metadata/EntitySubscriberMetadata", [], function (exports_207, context_207) {
    "use strict";
    var __moduleName = context_207 && context_207.id;
    var EntitySubscriberMetadata;
    return {
        setters: [],
        execute: function () {
            /**
             * Contains metadata information about ORM event subscribers.
             */
            EntitySubscriberMetadata = (function () {
                function EntitySubscriberMetadata(args) {
                    this.target = args.target;
                }
                return EntitySubscriberMetadata;
            }());
            exports_207("EntitySubscriberMetadata", EntitySubscriberMetadata);
        }
    };
});
System.register("typeorm/metadata/TargetMetadata", [], function (exports_208, context_208) {
    "use strict";
    var __moduleName = context_208 && context_208.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/metadata/PropertyMetadata", [], function (exports_209, context_209) {
    "use strict";
    var __moduleName = context_209 && context_209.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/metadata/RelationCountMetadata", [], function (exports_210, context_210) {
    "use strict";
    var __moduleName = context_210 && context_210.id;
    var RelationCountMetadata;
    return {
        setters: [],
        execute: function () {
            /**
             * Contains all information about entity's relation count.
             */
            RelationCountMetadata = (function () {
                // ---------------------------------------------------------------------
                // Constructor
                // ---------------------------------------------------------------------
                function RelationCountMetadata(args) {
                    this.target = args.target;
                    this.propertyName = args.propertyName;
                    this.relation = args.relation;
                }
                return RelationCountMetadata;
            }());
            exports_210("RelationCountMetadata", RelationCountMetadata);
        }
    };
});
System.register("typeorm/connection/error/CannotGetEntityManagerNotConnectedError", [], function (exports_211, context_211) {
    "use strict";
    var __moduleName = context_211 && context_211.id;
    var CannotGetEntityManagerNotConnectedError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown when consumer tries to access entity manager before connection is established.
             */
            CannotGetEntityManagerNotConnectedError = (function (_super) {
                __extends(CannotGetEntityManagerNotConnectedError, _super);
                function CannotGetEntityManagerNotConnectedError(connectionName) {
                    var _this = _super.call(this) || this;
                    _this.name = "CannotGetEntityManagerNotConnectedError";
                    _this.message = "Cannot get entity manager for \"" + connectionName + "\" connection because connection is not yet established.";
                    _this.stack = new Error().stack;
                    return _this;
                }
                return CannotGetEntityManagerNotConnectedError;
            }(Error));
            exports_211("CannotGetEntityManagerNotConnectedError", CannotGetEntityManagerNotConnectedError);
        }
    };
});
System.register("typeorm/connection/error/NoConnectionForRepositoryError", [], function (exports_212, context_212) {
    "use strict";
    var __moduleName = context_212 && context_212.id;
    var NoConnectionForRepositoryError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown when consumer tries to access repository before connection is established.
             */
            NoConnectionForRepositoryError = (function (_super) {
                __extends(NoConnectionForRepositoryError, _super);
                function NoConnectionForRepositoryError(connectionName) {
                    var _this = _super.call(this) || this;
                    _this.name = "NoConnectionForRepositoryError";
                    _this.message = "Cannot get a Repository for \"" + connectionName + " connection, because connection with the database " +
                        "is not established yet. Call connection#connect method to establish connection.";
                    _this.stack = new Error().stack;
                    return _this;
                }
                return NoConnectionForRepositoryError;
            }(Error));
            exports_212("NoConnectionForRepositoryError", NoConnectionForRepositoryError);
        }
    };
});
System.register("typeorm/driver/error/DriverPackageLoadError", [], function (exports_213, context_213) {
    "use strict";
    var __moduleName = context_213 && context_213.id;
    var DriverPackageLoadError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown when some unexpected error occur on driver packages load.
             */
            DriverPackageLoadError = (function (_super) {
                __extends(DriverPackageLoadError, _super);
                function DriverPackageLoadError() {
                    var _this = _super.call(this) || this;
                    _this.name = "DriverPackageLoadError";
                    _this.message = "Cannot load driver dependencies. Try to install all required dependencies.";
                    return _this;
                }
                return DriverPackageLoadError;
            }(Error));
            exports_213("DriverPackageLoadError", DriverPackageLoadError);
        }
    };
});
System.register("typeorm/driver/error/DriverPoolingNotSupportedError", [], function (exports_214, context_214) {
    "use strict";
    var __moduleName = context_214 && context_214.id;
    var DriverPoolingNotSupportedError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown if database driver does not support pooling.
             */
            DriverPoolingNotSupportedError = (function (_super) {
                __extends(DriverPoolingNotSupportedError, _super);
                function DriverPoolingNotSupportedError(driverName) {
                    var _this = _super.call(this) || this;
                    _this.name = "DriverPoolingNotSupportedError";
                    _this.message = "Connection pooling is not supported by (" + driverName + ") driver.";
                    return _this;
                }
                return DriverPoolingNotSupportedError;
            }(Error));
            exports_214("DriverPoolingNotSupportedError", DriverPoolingNotSupportedError);
        }
    };
});
System.register("typeorm/metadata-builder/error/MetadataWithSuchNameAlreadyExistsError", [], function (exports_215, context_215) {
    "use strict";
    var __moduleName = context_215 && context_215.id;
    var MetadataWithSuchNameAlreadyExistsError;
    return {
        setters: [],
        execute: function () {
            /**
             */
            MetadataWithSuchNameAlreadyExistsError = (function (_super) {
                __extends(MetadataWithSuchNameAlreadyExistsError, _super);
                function MetadataWithSuchNameAlreadyExistsError(metadataType, name) {
                    var _this = _super.call(this) || this;
                    _this.name = "MetadataWithSuchNameAlreadyExistsError";
                    _this.message = metadataType + " metadata with such name " + name + " already exists. " +
                        "Do you apply decorator twice? Or maybe try to change a name?";
                    return _this;
                }
                return MetadataWithSuchNameAlreadyExistsError;
            }(Error));
            exports_215("MetadataWithSuchNameAlreadyExistsError", MetadataWithSuchNameAlreadyExistsError);
        }
    };
});
System.register("typeorm/persistence/error/CascadesNotAllowedError", [], function (exports_216, context_216) {
    "use strict";
    var __moduleName = context_216 && context_216.id;
    var CascadesNotAllowedError;
    return {
        setters: [],
        execute: function () {
            /**
             */
            CascadesNotAllowedError = (function (_super) {
                __extends(CascadesNotAllowedError, _super);
                // todo: remove metadata attribute since its present in relation attribute
                function CascadesNotAllowedError(type, metadata, relation) {
                    var _this = _super.call(this) || this;
                    _this.name = "CascadesNotAllowedError";
                    _this.message = "Cascades (" + type + ") are not allowed for the given relation " + metadata.name + "#" + relation.name;
                    return _this;
                }
                return CascadesNotAllowedError;
            }(Error));
            exports_216("CascadesNotAllowedError", CascadesNotAllowedError);
        }
    };
});
System.register("typeorm/persistence/error/PersistedEntityNotFoundError", [], function (exports_217, context_217) {
    "use strict";
    var __moduleName = context_217 && context_217.id;
    var PersistedEntityNotFoundError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown . Theoretically can't be thrown.
             */
            PersistedEntityNotFoundError = (function (_super) {
                __extends(PersistedEntityNotFoundError, _super);
                function PersistedEntityNotFoundError() {
                    var _this = _super.call(this) || this;
                    _this.name = "PersistedEntityNotFoundError";
                    _this.message = "Internal error. Persisted entity was not found in the list of prepared operated entities.";
                    return _this;
                }
                return PersistedEntityNotFoundError;
            }(Error));
            exports_217("PersistedEntityNotFoundError", PersistedEntityNotFoundError);
        }
    };
});

//# sourceMappingURL=typeorm-browser.js.map
