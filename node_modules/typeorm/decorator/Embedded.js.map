{"version":3,"sources":["../../src/decorator/Embedded.ts"],"names":[],"mappings":";;AACA,kCAAgD;AAGhD;;;;GAIG;AACH,kBAA4B,YAA2C;IACnE,MAAM,CAAC,UAAU,MAAc,EAAE,YAAoB;QACjD,2FAA2F;QAE3F,IAAM,IAAI,GAAyB;YAC/B,MAAM,EAAE,MAAM,CAAC,WAAW;YAC1B,YAAY,EAAE,YAAY;YAC1B,+BAA+B;YAC/B,IAAI,EAAE,YAAY;SACrB,CAAC;QACF,8BAAsB,EAAE,CAAC,SAAS,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;IACjD,CAAC,CAAC;AACN,CAAC;AAZD,4BAYC","file":"Embedded.js","sourcesContent":["import {ObjectType} from \"../common/ObjectType\";\nimport {getMetadataArgsStorage} from \"../index\";\nimport {EmbeddedMetadataArgs} from \"../metadata-args/EmbeddedMetadataArgs\";\n\n/**\n * Property in entity can be marked as Embedded, and on persist all columns from the embedded are mapped to the\n * single table of the entity where Embedded is used. And on hydration all columns which supposed to be in the\n * embedded will be mapped to it from the single table.\n */\nexport function Embedded<T>(typeFunction: (type?: any) => ObjectType<T>) {\n    return function (object: Object, propertyName: string) {\n        // const reflectedType = (Reflect as any).getMetadata(\"design:type\", object, propertyName);\n\n        const args: EmbeddedMetadataArgs = {\n            target: object.constructor,\n            propertyName: propertyName,\n            // propertyType: reflectedType,\n            type: typeFunction\n        };\n        getMetadataArgsStorage().embeddeds.add(args);\n    };\n}"],"sourceRoot":".."}